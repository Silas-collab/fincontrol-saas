
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model RefreshToken
 * 
 */
export type RefreshToken = $Result.DefaultSelection<Prisma.$RefreshTokenPayload>
/**
 * Model PasswordReset
 * 
 */
export type PasswordReset = $Result.DefaultSelection<Prisma.$PasswordResetPayload>
/**
 * Model Workspace
 * 
 */
export type Workspace = $Result.DefaultSelection<Prisma.$WorkspacePayload>
/**
 * Model WorkspaceMember
 * 
 */
export type WorkspaceMember = $Result.DefaultSelection<Prisma.$WorkspaceMemberPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model Recurrence
 * 
 */
export type Recurrence = $Result.DefaultSelection<Prisma.$RecurrencePayload>
/**
 * Model Transfer
 * 
 */
export type Transfer = $Result.DefaultSelection<Prisma.$TransferPayload>
/**
 * Model Budget
 * 
 */
export type Budget = $Result.DefaultSelection<Prisma.$BudgetPayload>
/**
 * Model BudgetCategory
 * 
 */
export type BudgetCategory = $Result.DefaultSelection<Prisma.$BudgetCategoryPayload>
/**
 * Model Goal
 * 
 */
export type Goal = $Result.DefaultSelection<Prisma.$GoalPayload>
/**
 * Model GoalContribution
 * 
 */
export type GoalContribution = $Result.DefaultSelection<Prisma.$GoalContributionPayload>
/**
 * Model ImportJob
 * 
 */
export type ImportJob = $Result.DefaultSelection<Prisma.$ImportJobPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model UserGamification
 * 
 */
export type UserGamification = $Result.DefaultSelection<Prisma.$UserGamificationPayload>
/**
 * Model Achievement
 * 
 */
export type Achievement = $Result.DefaultSelection<Prisma.$AchievementPayload>
/**
 * Model UserAchievement
 * 
 */
export type UserAchievement = $Result.DefaultSelection<Prisma.$UserAchievementPayload>
/**
 * Model Envelope
 * 
 */
export type Envelope = $Result.DefaultSelection<Prisma.$EnvelopePayload>
/**
 * Model Asset
 * 
 */
export type Asset = $Result.DefaultSelection<Prisma.$AssetPayload>
/**
 * Model Liability
 * 
 */
export type Liability = $Result.DefaultSelection<Prisma.$LiabilityPayload>
/**
 * Model AIInsight
 * 
 */
export type AIInsight = $Result.DefaultSelection<Prisma.$AIInsightPayload>
/**
 * Model Scenario
 * 
 */
export type Scenario = $Result.DefaultSelection<Prisma.$ScenarioPayload>
/**
 * Model BankConnection
 * 
 */
export type BankConnection = $Result.DefaultSelection<Prisma.$BankConnectionPayload>
/**
 * Model AutoRule
 * 
 */
export type AutoRule = $Result.DefaultSelection<Prisma.$AutoRulePayload>
/**
 * Model CashFlowProjection
 * 
 */
export type CashFlowProjection = $Result.DefaultSelection<Prisma.$CashFlowProjectionPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs>;

  /**
   * `prisma.refreshToken`: Exposes CRUD operations for the **RefreshToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RefreshTokens
    * const refreshTokens = await prisma.refreshToken.findMany()
    * ```
    */
  get refreshToken(): Prisma.RefreshTokenDelegate<ExtArgs>;

  /**
   * `prisma.passwordReset`: Exposes CRUD operations for the **PasswordReset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordResets
    * const passwordResets = await prisma.passwordReset.findMany()
    * ```
    */
  get passwordReset(): Prisma.PasswordResetDelegate<ExtArgs>;

  /**
   * `prisma.workspace`: Exposes CRUD operations for the **Workspace** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Workspaces
    * const workspaces = await prisma.workspace.findMany()
    * ```
    */
  get workspace(): Prisma.WorkspaceDelegate<ExtArgs>;

  /**
   * `prisma.workspaceMember`: Exposes CRUD operations for the **WorkspaceMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkspaceMembers
    * const workspaceMembers = await prisma.workspaceMember.findMany()
    * ```
    */
  get workspaceMember(): Prisma.WorkspaceMemberDelegate<ExtArgs>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs>;

  /**
   * `prisma.recurrence`: Exposes CRUD operations for the **Recurrence** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Recurrences
    * const recurrences = await prisma.recurrence.findMany()
    * ```
    */
  get recurrence(): Prisma.RecurrenceDelegate<ExtArgs>;

  /**
   * `prisma.transfer`: Exposes CRUD operations for the **Transfer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transfers
    * const transfers = await prisma.transfer.findMany()
    * ```
    */
  get transfer(): Prisma.TransferDelegate<ExtArgs>;

  /**
   * `prisma.budget`: Exposes CRUD operations for the **Budget** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Budgets
    * const budgets = await prisma.budget.findMany()
    * ```
    */
  get budget(): Prisma.BudgetDelegate<ExtArgs>;

  /**
   * `prisma.budgetCategory`: Exposes CRUD operations for the **BudgetCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BudgetCategories
    * const budgetCategories = await prisma.budgetCategory.findMany()
    * ```
    */
  get budgetCategory(): Prisma.BudgetCategoryDelegate<ExtArgs>;

  /**
   * `prisma.goal`: Exposes CRUD operations for the **Goal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Goals
    * const goals = await prisma.goal.findMany()
    * ```
    */
  get goal(): Prisma.GoalDelegate<ExtArgs>;

  /**
   * `prisma.goalContribution`: Exposes CRUD operations for the **GoalContribution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GoalContributions
    * const goalContributions = await prisma.goalContribution.findMany()
    * ```
    */
  get goalContribution(): Prisma.GoalContributionDelegate<ExtArgs>;

  /**
   * `prisma.importJob`: Exposes CRUD operations for the **ImportJob** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ImportJobs
    * const importJobs = await prisma.importJob.findMany()
    * ```
    */
  get importJob(): Prisma.ImportJobDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;

  /**
   * `prisma.userGamification`: Exposes CRUD operations for the **UserGamification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserGamifications
    * const userGamifications = await prisma.userGamification.findMany()
    * ```
    */
  get userGamification(): Prisma.UserGamificationDelegate<ExtArgs>;

  /**
   * `prisma.achievement`: Exposes CRUD operations for the **Achievement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Achievements
    * const achievements = await prisma.achievement.findMany()
    * ```
    */
  get achievement(): Prisma.AchievementDelegate<ExtArgs>;

  /**
   * `prisma.userAchievement`: Exposes CRUD operations for the **UserAchievement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAchievements
    * const userAchievements = await prisma.userAchievement.findMany()
    * ```
    */
  get userAchievement(): Prisma.UserAchievementDelegate<ExtArgs>;

  /**
   * `prisma.envelope`: Exposes CRUD operations for the **Envelope** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Envelopes
    * const envelopes = await prisma.envelope.findMany()
    * ```
    */
  get envelope(): Prisma.EnvelopeDelegate<ExtArgs>;

  /**
   * `prisma.asset`: Exposes CRUD operations for the **Asset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Assets
    * const assets = await prisma.asset.findMany()
    * ```
    */
  get asset(): Prisma.AssetDelegate<ExtArgs>;

  /**
   * `prisma.liability`: Exposes CRUD operations for the **Liability** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Liabilities
    * const liabilities = await prisma.liability.findMany()
    * ```
    */
  get liability(): Prisma.LiabilityDelegate<ExtArgs>;

  /**
   * `prisma.aIInsight`: Exposes CRUD operations for the **AIInsight** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIInsights
    * const aIInsights = await prisma.aIInsight.findMany()
    * ```
    */
  get aIInsight(): Prisma.AIInsightDelegate<ExtArgs>;

  /**
   * `prisma.scenario`: Exposes CRUD operations for the **Scenario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Scenarios
    * const scenarios = await prisma.scenario.findMany()
    * ```
    */
  get scenario(): Prisma.ScenarioDelegate<ExtArgs>;

  /**
   * `prisma.bankConnection`: Exposes CRUD operations for the **BankConnection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BankConnections
    * const bankConnections = await prisma.bankConnection.findMany()
    * ```
    */
  get bankConnection(): Prisma.BankConnectionDelegate<ExtArgs>;

  /**
   * `prisma.autoRule`: Exposes CRUD operations for the **AutoRule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AutoRules
    * const autoRules = await prisma.autoRule.findMany()
    * ```
    */
  get autoRule(): Prisma.AutoRuleDelegate<ExtArgs>;

  /**
   * `prisma.cashFlowProjection`: Exposes CRUD operations for the **CashFlowProjection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CashFlowProjections
    * const cashFlowProjections = await prisma.cashFlowProjection.findMany()
    * ```
    */
  get cashFlowProjection(): Prisma.CashFlowProjectionDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Session: 'Session',
    RefreshToken: 'RefreshToken',
    PasswordReset: 'PasswordReset',
    Workspace: 'Workspace',
    WorkspaceMember: 'WorkspaceMember',
    Account: 'Account',
    Category: 'Category',
    Transaction: 'Transaction',
    Recurrence: 'Recurrence',
    Transfer: 'Transfer',
    Budget: 'Budget',
    BudgetCategory: 'BudgetCategory',
    Goal: 'Goal',
    GoalContribution: 'GoalContribution',
    ImportJob: 'ImportJob',
    Notification: 'Notification',
    AuditLog: 'AuditLog',
    UserGamification: 'UserGamification',
    Achievement: 'Achievement',
    UserAchievement: 'UserAchievement',
    Envelope: 'Envelope',
    Asset: 'Asset',
    Liability: 'Liability',
    AIInsight: 'AIInsight',
    Scenario: 'Scenario',
    BankConnection: 'BankConnection',
    AutoRule: 'AutoRule',
    CashFlowProjection: 'CashFlowProjection'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "session" | "refreshToken" | "passwordReset" | "workspace" | "workspaceMember" | "account" | "category" | "transaction" | "recurrence" | "transfer" | "budget" | "budgetCategory" | "goal" | "goalContribution" | "importJob" | "notification" | "auditLog" | "userGamification" | "achievement" | "userAchievement" | "envelope" | "asset" | "liability" | "aIInsight" | "scenario" | "bankConnection" | "autoRule" | "cashFlowProjection"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      RefreshToken: {
        payload: Prisma.$RefreshTokenPayload<ExtArgs>
        fields: Prisma.RefreshTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefreshTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefreshTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findFirst: {
            args: Prisma.RefreshTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefreshTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findMany: {
            args: Prisma.RefreshTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          create: {
            args: Prisma.RefreshTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          createMany: {
            args: Prisma.RefreshTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RefreshTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          delete: {
            args: Prisma.RefreshTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          update: {
            args: Prisma.RefreshTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          deleteMany: {
            args: Prisma.RefreshTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefreshTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RefreshTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          aggregate: {
            args: Prisma.RefreshTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefreshToken>
          }
          groupBy: {
            args: Prisma.RefreshTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefreshTokenCountArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenCountAggregateOutputType> | number
          }
        }
      }
      PasswordReset: {
        payload: Prisma.$PasswordResetPayload<ExtArgs>
        fields: Prisma.PasswordResetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordResetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordResetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>
          }
          findFirst: {
            args: Prisma.PasswordResetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordResetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>
          }
          findMany: {
            args: Prisma.PasswordResetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>[]
          }
          create: {
            args: Prisma.PasswordResetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>
          }
          createMany: {
            args: Prisma.PasswordResetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordResetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>[]
          }
          delete: {
            args: Prisma.PasswordResetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>
          }
          update: {
            args: Prisma.PasswordResetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>
          }
          deleteMany: {
            args: Prisma.PasswordResetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordResetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PasswordResetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>
          }
          aggregate: {
            args: Prisma.PasswordResetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordReset>
          }
          groupBy: {
            args: Prisma.PasswordResetGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordResetCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetCountAggregateOutputType> | number
          }
        }
      }
      Workspace: {
        payload: Prisma.$WorkspacePayload<ExtArgs>
        fields: Prisma.WorkspaceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkspaceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkspaceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          findFirst: {
            args: Prisma.WorkspaceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkspaceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          findMany: {
            args: Prisma.WorkspaceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>[]
          }
          create: {
            args: Prisma.WorkspaceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          createMany: {
            args: Prisma.WorkspaceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkspaceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>[]
          }
          delete: {
            args: Prisma.WorkspaceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          update: {
            args: Prisma.WorkspaceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          deleteMany: {
            args: Prisma.WorkspaceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkspaceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkspaceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          aggregate: {
            args: Prisma.WorkspaceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkspace>
          }
          groupBy: {
            args: Prisma.WorkspaceGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkspaceCountArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceCountAggregateOutputType> | number
          }
        }
      }
      WorkspaceMember: {
        payload: Prisma.$WorkspaceMemberPayload<ExtArgs>
        fields: Prisma.WorkspaceMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkspaceMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkspaceMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceMemberPayload>
          }
          findFirst: {
            args: Prisma.WorkspaceMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkspaceMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceMemberPayload>
          }
          findMany: {
            args: Prisma.WorkspaceMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceMemberPayload>[]
          }
          create: {
            args: Prisma.WorkspaceMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceMemberPayload>
          }
          createMany: {
            args: Prisma.WorkspaceMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkspaceMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceMemberPayload>[]
          }
          delete: {
            args: Prisma.WorkspaceMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceMemberPayload>
          }
          update: {
            args: Prisma.WorkspaceMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceMemberPayload>
          }
          deleteMany: {
            args: Prisma.WorkspaceMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkspaceMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkspaceMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceMemberPayload>
          }
          aggregate: {
            args: Prisma.WorkspaceMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkspaceMember>
          }
          groupBy: {
            args: Prisma.WorkspaceMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkspaceMemberCountArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceMemberCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      Recurrence: {
        payload: Prisma.$RecurrencePayload<ExtArgs>
        fields: Prisma.RecurrenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecurrenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurrencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecurrenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurrencePayload>
          }
          findFirst: {
            args: Prisma.RecurrenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurrencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecurrenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurrencePayload>
          }
          findMany: {
            args: Prisma.RecurrenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurrencePayload>[]
          }
          create: {
            args: Prisma.RecurrenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurrencePayload>
          }
          createMany: {
            args: Prisma.RecurrenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RecurrenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurrencePayload>[]
          }
          delete: {
            args: Prisma.RecurrenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurrencePayload>
          }
          update: {
            args: Prisma.RecurrenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurrencePayload>
          }
          deleteMany: {
            args: Prisma.RecurrenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecurrenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RecurrenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurrencePayload>
          }
          aggregate: {
            args: Prisma.RecurrenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecurrence>
          }
          groupBy: {
            args: Prisma.RecurrenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecurrenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecurrenceCountArgs<ExtArgs>
            result: $Utils.Optional<RecurrenceCountAggregateOutputType> | number
          }
        }
      }
      Transfer: {
        payload: Prisma.$TransferPayload<ExtArgs>
        fields: Prisma.TransferFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransferFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransferFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          findFirst: {
            args: Prisma.TransferFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransferFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          findMany: {
            args: Prisma.TransferFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>[]
          }
          create: {
            args: Prisma.TransferCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          createMany: {
            args: Prisma.TransferCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransferCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>[]
          }
          delete: {
            args: Prisma.TransferDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          update: {
            args: Prisma.TransferUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          deleteMany: {
            args: Prisma.TransferDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransferUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TransferUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          aggregate: {
            args: Prisma.TransferAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransfer>
          }
          groupBy: {
            args: Prisma.TransferGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransferGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransferCountArgs<ExtArgs>
            result: $Utils.Optional<TransferCountAggregateOutputType> | number
          }
        }
      }
      Budget: {
        payload: Prisma.$BudgetPayload<ExtArgs>
        fields: Prisma.BudgetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BudgetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BudgetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          findFirst: {
            args: Prisma.BudgetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BudgetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          findMany: {
            args: Prisma.BudgetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>[]
          }
          create: {
            args: Prisma.BudgetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          createMany: {
            args: Prisma.BudgetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BudgetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>[]
          }
          delete: {
            args: Prisma.BudgetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          update: {
            args: Prisma.BudgetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          deleteMany: {
            args: Prisma.BudgetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BudgetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BudgetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          aggregate: {
            args: Prisma.BudgetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBudget>
          }
          groupBy: {
            args: Prisma.BudgetGroupByArgs<ExtArgs>
            result: $Utils.Optional<BudgetGroupByOutputType>[]
          }
          count: {
            args: Prisma.BudgetCountArgs<ExtArgs>
            result: $Utils.Optional<BudgetCountAggregateOutputType> | number
          }
        }
      }
      BudgetCategory: {
        payload: Prisma.$BudgetCategoryPayload<ExtArgs>
        fields: Prisma.BudgetCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BudgetCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BudgetCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetCategoryPayload>
          }
          findFirst: {
            args: Prisma.BudgetCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BudgetCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetCategoryPayload>
          }
          findMany: {
            args: Prisma.BudgetCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetCategoryPayload>[]
          }
          create: {
            args: Prisma.BudgetCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetCategoryPayload>
          }
          createMany: {
            args: Prisma.BudgetCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BudgetCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetCategoryPayload>[]
          }
          delete: {
            args: Prisma.BudgetCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetCategoryPayload>
          }
          update: {
            args: Prisma.BudgetCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetCategoryPayload>
          }
          deleteMany: {
            args: Prisma.BudgetCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BudgetCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BudgetCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetCategoryPayload>
          }
          aggregate: {
            args: Prisma.BudgetCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBudgetCategory>
          }
          groupBy: {
            args: Prisma.BudgetCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<BudgetCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.BudgetCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<BudgetCategoryCountAggregateOutputType> | number
          }
        }
      }
      Goal: {
        payload: Prisma.$GoalPayload<ExtArgs>
        fields: Prisma.GoalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GoalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GoalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>
          }
          findFirst: {
            args: Prisma.GoalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GoalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>
          }
          findMany: {
            args: Prisma.GoalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>[]
          }
          create: {
            args: Prisma.GoalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>
          }
          createMany: {
            args: Prisma.GoalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GoalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>[]
          }
          delete: {
            args: Prisma.GoalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>
          }
          update: {
            args: Prisma.GoalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>
          }
          deleteMany: {
            args: Prisma.GoalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GoalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GoalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>
          }
          aggregate: {
            args: Prisma.GoalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGoal>
          }
          groupBy: {
            args: Prisma.GoalGroupByArgs<ExtArgs>
            result: $Utils.Optional<GoalGroupByOutputType>[]
          }
          count: {
            args: Prisma.GoalCountArgs<ExtArgs>
            result: $Utils.Optional<GoalCountAggregateOutputType> | number
          }
        }
      }
      GoalContribution: {
        payload: Prisma.$GoalContributionPayload<ExtArgs>
        fields: Prisma.GoalContributionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GoalContributionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalContributionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GoalContributionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalContributionPayload>
          }
          findFirst: {
            args: Prisma.GoalContributionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalContributionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GoalContributionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalContributionPayload>
          }
          findMany: {
            args: Prisma.GoalContributionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalContributionPayload>[]
          }
          create: {
            args: Prisma.GoalContributionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalContributionPayload>
          }
          createMany: {
            args: Prisma.GoalContributionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GoalContributionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalContributionPayload>[]
          }
          delete: {
            args: Prisma.GoalContributionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalContributionPayload>
          }
          update: {
            args: Prisma.GoalContributionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalContributionPayload>
          }
          deleteMany: {
            args: Prisma.GoalContributionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GoalContributionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GoalContributionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalContributionPayload>
          }
          aggregate: {
            args: Prisma.GoalContributionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGoalContribution>
          }
          groupBy: {
            args: Prisma.GoalContributionGroupByArgs<ExtArgs>
            result: $Utils.Optional<GoalContributionGroupByOutputType>[]
          }
          count: {
            args: Prisma.GoalContributionCountArgs<ExtArgs>
            result: $Utils.Optional<GoalContributionCountAggregateOutputType> | number
          }
        }
      }
      ImportJob: {
        payload: Prisma.$ImportJobPayload<ExtArgs>
        fields: Prisma.ImportJobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ImportJobFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportJobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ImportJobFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportJobPayload>
          }
          findFirst: {
            args: Prisma.ImportJobFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportJobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ImportJobFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportJobPayload>
          }
          findMany: {
            args: Prisma.ImportJobFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportJobPayload>[]
          }
          create: {
            args: Prisma.ImportJobCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportJobPayload>
          }
          createMany: {
            args: Prisma.ImportJobCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ImportJobCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportJobPayload>[]
          }
          delete: {
            args: Prisma.ImportJobDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportJobPayload>
          }
          update: {
            args: Prisma.ImportJobUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportJobPayload>
          }
          deleteMany: {
            args: Prisma.ImportJobDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ImportJobUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ImportJobUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportJobPayload>
          }
          aggregate: {
            args: Prisma.ImportJobAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImportJob>
          }
          groupBy: {
            args: Prisma.ImportJobGroupByArgs<ExtArgs>
            result: $Utils.Optional<ImportJobGroupByOutputType>[]
          }
          count: {
            args: Prisma.ImportJobCountArgs<ExtArgs>
            result: $Utils.Optional<ImportJobCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      UserGamification: {
        payload: Prisma.$UserGamificationPayload<ExtArgs>
        fields: Prisma.UserGamificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserGamificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGamificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserGamificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGamificationPayload>
          }
          findFirst: {
            args: Prisma.UserGamificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGamificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserGamificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGamificationPayload>
          }
          findMany: {
            args: Prisma.UserGamificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGamificationPayload>[]
          }
          create: {
            args: Prisma.UserGamificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGamificationPayload>
          }
          createMany: {
            args: Prisma.UserGamificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserGamificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGamificationPayload>[]
          }
          delete: {
            args: Prisma.UserGamificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGamificationPayload>
          }
          update: {
            args: Prisma.UserGamificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGamificationPayload>
          }
          deleteMany: {
            args: Prisma.UserGamificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserGamificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserGamificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGamificationPayload>
          }
          aggregate: {
            args: Prisma.UserGamificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserGamification>
          }
          groupBy: {
            args: Prisma.UserGamificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGamificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserGamificationCountArgs<ExtArgs>
            result: $Utils.Optional<UserGamificationCountAggregateOutputType> | number
          }
        }
      }
      Achievement: {
        payload: Prisma.$AchievementPayload<ExtArgs>
        fields: Prisma.AchievementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AchievementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AchievementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          findFirst: {
            args: Prisma.AchievementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AchievementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          findMany: {
            args: Prisma.AchievementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          create: {
            args: Prisma.AchievementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          createMany: {
            args: Prisma.AchievementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AchievementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          delete: {
            args: Prisma.AchievementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          update: {
            args: Prisma.AchievementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          deleteMany: {
            args: Prisma.AchievementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AchievementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AchievementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          aggregate: {
            args: Prisma.AchievementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAchievement>
          }
          groupBy: {
            args: Prisma.AchievementGroupByArgs<ExtArgs>
            result: $Utils.Optional<AchievementGroupByOutputType>[]
          }
          count: {
            args: Prisma.AchievementCountArgs<ExtArgs>
            result: $Utils.Optional<AchievementCountAggregateOutputType> | number
          }
        }
      }
      UserAchievement: {
        payload: Prisma.$UserAchievementPayload<ExtArgs>
        fields: Prisma.UserAchievementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserAchievementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserAchievementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          findFirst: {
            args: Prisma.UserAchievementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserAchievementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          findMany: {
            args: Prisma.UserAchievementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>[]
          }
          create: {
            args: Prisma.UserAchievementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          createMany: {
            args: Prisma.UserAchievementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserAchievementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>[]
          }
          delete: {
            args: Prisma.UserAchievementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          update: {
            args: Prisma.UserAchievementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          deleteMany: {
            args: Prisma.UserAchievementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserAchievementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserAchievementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          aggregate: {
            args: Prisma.UserAchievementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserAchievement>
          }
          groupBy: {
            args: Prisma.UserAchievementGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserAchievementGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserAchievementCountArgs<ExtArgs>
            result: $Utils.Optional<UserAchievementCountAggregateOutputType> | number
          }
        }
      }
      Envelope: {
        payload: Prisma.$EnvelopePayload<ExtArgs>
        fields: Prisma.EnvelopeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EnvelopeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvelopePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EnvelopeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvelopePayload>
          }
          findFirst: {
            args: Prisma.EnvelopeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvelopePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EnvelopeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvelopePayload>
          }
          findMany: {
            args: Prisma.EnvelopeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvelopePayload>[]
          }
          create: {
            args: Prisma.EnvelopeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvelopePayload>
          }
          createMany: {
            args: Prisma.EnvelopeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EnvelopeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvelopePayload>[]
          }
          delete: {
            args: Prisma.EnvelopeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvelopePayload>
          }
          update: {
            args: Prisma.EnvelopeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvelopePayload>
          }
          deleteMany: {
            args: Prisma.EnvelopeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EnvelopeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EnvelopeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvelopePayload>
          }
          aggregate: {
            args: Prisma.EnvelopeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEnvelope>
          }
          groupBy: {
            args: Prisma.EnvelopeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EnvelopeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EnvelopeCountArgs<ExtArgs>
            result: $Utils.Optional<EnvelopeCountAggregateOutputType> | number
          }
        }
      }
      Asset: {
        payload: Prisma.$AssetPayload<ExtArgs>
        fields: Prisma.AssetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          findFirst: {
            args: Prisma.AssetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          findMany: {
            args: Prisma.AssetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>[]
          }
          create: {
            args: Prisma.AssetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          createMany: {
            args: Prisma.AssetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>[]
          }
          delete: {
            args: Prisma.AssetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          update: {
            args: Prisma.AssetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          deleteMany: {
            args: Prisma.AssetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AssetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          aggregate: {
            args: Prisma.AssetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAsset>
          }
          groupBy: {
            args: Prisma.AssetGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssetGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssetCountArgs<ExtArgs>
            result: $Utils.Optional<AssetCountAggregateOutputType> | number
          }
        }
      }
      Liability: {
        payload: Prisma.$LiabilityPayload<ExtArgs>
        fields: Prisma.LiabilityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LiabilityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiabilityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LiabilityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiabilityPayload>
          }
          findFirst: {
            args: Prisma.LiabilityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiabilityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LiabilityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiabilityPayload>
          }
          findMany: {
            args: Prisma.LiabilityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiabilityPayload>[]
          }
          create: {
            args: Prisma.LiabilityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiabilityPayload>
          }
          createMany: {
            args: Prisma.LiabilityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LiabilityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiabilityPayload>[]
          }
          delete: {
            args: Prisma.LiabilityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiabilityPayload>
          }
          update: {
            args: Prisma.LiabilityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiabilityPayload>
          }
          deleteMany: {
            args: Prisma.LiabilityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LiabilityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LiabilityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiabilityPayload>
          }
          aggregate: {
            args: Prisma.LiabilityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLiability>
          }
          groupBy: {
            args: Prisma.LiabilityGroupByArgs<ExtArgs>
            result: $Utils.Optional<LiabilityGroupByOutputType>[]
          }
          count: {
            args: Prisma.LiabilityCountArgs<ExtArgs>
            result: $Utils.Optional<LiabilityCountAggregateOutputType> | number
          }
        }
      }
      AIInsight: {
        payload: Prisma.$AIInsightPayload<ExtArgs>
        fields: Prisma.AIInsightFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIInsightFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIInsightPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIInsightFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIInsightPayload>
          }
          findFirst: {
            args: Prisma.AIInsightFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIInsightPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIInsightFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIInsightPayload>
          }
          findMany: {
            args: Prisma.AIInsightFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIInsightPayload>[]
          }
          create: {
            args: Prisma.AIInsightCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIInsightPayload>
          }
          createMany: {
            args: Prisma.AIInsightCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AIInsightCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIInsightPayload>[]
          }
          delete: {
            args: Prisma.AIInsightDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIInsightPayload>
          }
          update: {
            args: Prisma.AIInsightUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIInsightPayload>
          }
          deleteMany: {
            args: Prisma.AIInsightDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIInsightUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AIInsightUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIInsightPayload>
          }
          aggregate: {
            args: Prisma.AIInsightAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIInsight>
          }
          groupBy: {
            args: Prisma.AIInsightGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIInsightGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIInsightCountArgs<ExtArgs>
            result: $Utils.Optional<AIInsightCountAggregateOutputType> | number
          }
        }
      }
      Scenario: {
        payload: Prisma.$ScenarioPayload<ExtArgs>
        fields: Prisma.ScenarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScenarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScenarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload>
          }
          findFirst: {
            args: Prisma.ScenarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScenarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload>
          }
          findMany: {
            args: Prisma.ScenarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload>[]
          }
          create: {
            args: Prisma.ScenarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload>
          }
          createMany: {
            args: Prisma.ScenarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScenarioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload>[]
          }
          delete: {
            args: Prisma.ScenarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload>
          }
          update: {
            args: Prisma.ScenarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload>
          }
          deleteMany: {
            args: Prisma.ScenarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScenarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ScenarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload>
          }
          aggregate: {
            args: Prisma.ScenarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScenario>
          }
          groupBy: {
            args: Prisma.ScenarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScenarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScenarioCountArgs<ExtArgs>
            result: $Utils.Optional<ScenarioCountAggregateOutputType> | number
          }
        }
      }
      BankConnection: {
        payload: Prisma.$BankConnectionPayload<ExtArgs>
        fields: Prisma.BankConnectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BankConnectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankConnectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BankConnectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankConnectionPayload>
          }
          findFirst: {
            args: Prisma.BankConnectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankConnectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BankConnectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankConnectionPayload>
          }
          findMany: {
            args: Prisma.BankConnectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankConnectionPayload>[]
          }
          create: {
            args: Prisma.BankConnectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankConnectionPayload>
          }
          createMany: {
            args: Prisma.BankConnectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BankConnectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankConnectionPayload>[]
          }
          delete: {
            args: Prisma.BankConnectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankConnectionPayload>
          }
          update: {
            args: Prisma.BankConnectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankConnectionPayload>
          }
          deleteMany: {
            args: Prisma.BankConnectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BankConnectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BankConnectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankConnectionPayload>
          }
          aggregate: {
            args: Prisma.BankConnectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBankConnection>
          }
          groupBy: {
            args: Prisma.BankConnectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<BankConnectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.BankConnectionCountArgs<ExtArgs>
            result: $Utils.Optional<BankConnectionCountAggregateOutputType> | number
          }
        }
      }
      AutoRule: {
        payload: Prisma.$AutoRulePayload<ExtArgs>
        fields: Prisma.AutoRuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AutoRuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoRulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AutoRuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoRulePayload>
          }
          findFirst: {
            args: Prisma.AutoRuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoRulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AutoRuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoRulePayload>
          }
          findMany: {
            args: Prisma.AutoRuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoRulePayload>[]
          }
          create: {
            args: Prisma.AutoRuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoRulePayload>
          }
          createMany: {
            args: Prisma.AutoRuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AutoRuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoRulePayload>[]
          }
          delete: {
            args: Prisma.AutoRuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoRulePayload>
          }
          update: {
            args: Prisma.AutoRuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoRulePayload>
          }
          deleteMany: {
            args: Prisma.AutoRuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AutoRuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AutoRuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoRulePayload>
          }
          aggregate: {
            args: Prisma.AutoRuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAutoRule>
          }
          groupBy: {
            args: Prisma.AutoRuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<AutoRuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.AutoRuleCountArgs<ExtArgs>
            result: $Utils.Optional<AutoRuleCountAggregateOutputType> | number
          }
        }
      }
      CashFlowProjection: {
        payload: Prisma.$CashFlowProjectionPayload<ExtArgs>
        fields: Prisma.CashFlowProjectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CashFlowProjectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashFlowProjectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CashFlowProjectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashFlowProjectionPayload>
          }
          findFirst: {
            args: Prisma.CashFlowProjectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashFlowProjectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CashFlowProjectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashFlowProjectionPayload>
          }
          findMany: {
            args: Prisma.CashFlowProjectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashFlowProjectionPayload>[]
          }
          create: {
            args: Prisma.CashFlowProjectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashFlowProjectionPayload>
          }
          createMany: {
            args: Prisma.CashFlowProjectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CashFlowProjectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashFlowProjectionPayload>[]
          }
          delete: {
            args: Prisma.CashFlowProjectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashFlowProjectionPayload>
          }
          update: {
            args: Prisma.CashFlowProjectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashFlowProjectionPayload>
          }
          deleteMany: {
            args: Prisma.CashFlowProjectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CashFlowProjectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CashFlowProjectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashFlowProjectionPayload>
          }
          aggregate: {
            args: Prisma.CashFlowProjectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCashFlowProjection>
          }
          groupBy: {
            args: Prisma.CashFlowProjectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CashFlowProjectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CashFlowProjectionCountArgs<ExtArgs>
            result: $Utils.Optional<CashFlowProjectionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    workspaces: number
    sessions: number
    notifications: number
    auditLogs: number
    passwordResets: number
    refreshTokens: number
    aiInsights: number
    scenarios: number
    autoRules: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspaces?: boolean | UserCountOutputTypeCountWorkspacesArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    passwordResets?: boolean | UserCountOutputTypeCountPasswordResetsArgs
    refreshTokens?: boolean | UserCountOutputTypeCountRefreshTokensArgs
    aiInsights?: boolean | UserCountOutputTypeCountAiInsightsArgs
    scenarios?: boolean | UserCountOutputTypeCountScenariosArgs
    autoRules?: boolean | UserCountOutputTypeCountAutoRulesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWorkspacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPasswordResetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRefreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAiInsightsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIInsightWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountScenariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScenarioWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAutoRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutoRuleWhereInput
  }


  /**
   * Count Type WorkspaceCountOutputType
   */

  export type WorkspaceCountOutputType = {
    members: number
    accounts: number
    categories: number
    goals: number
    budgets: number
    imports: number
    auditLogs: number
    envelopes: number
    assets: number
    liabilities: number
    aiInsights: number
    scenarios: number
    bankConnections: number
    autoRules: number
    cashFlowProjections: number
    Transaction: number
  }

  export type WorkspaceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | WorkspaceCountOutputTypeCountMembersArgs
    accounts?: boolean | WorkspaceCountOutputTypeCountAccountsArgs
    categories?: boolean | WorkspaceCountOutputTypeCountCategoriesArgs
    goals?: boolean | WorkspaceCountOutputTypeCountGoalsArgs
    budgets?: boolean | WorkspaceCountOutputTypeCountBudgetsArgs
    imports?: boolean | WorkspaceCountOutputTypeCountImportsArgs
    auditLogs?: boolean | WorkspaceCountOutputTypeCountAuditLogsArgs
    envelopes?: boolean | WorkspaceCountOutputTypeCountEnvelopesArgs
    assets?: boolean | WorkspaceCountOutputTypeCountAssetsArgs
    liabilities?: boolean | WorkspaceCountOutputTypeCountLiabilitiesArgs
    aiInsights?: boolean | WorkspaceCountOutputTypeCountAiInsightsArgs
    scenarios?: boolean | WorkspaceCountOutputTypeCountScenariosArgs
    bankConnections?: boolean | WorkspaceCountOutputTypeCountBankConnectionsArgs
    autoRules?: boolean | WorkspaceCountOutputTypeCountAutoRulesArgs
    cashFlowProjections?: boolean | WorkspaceCountOutputTypeCountCashFlowProjectionsArgs
    Transaction?: boolean | WorkspaceCountOutputTypeCountTransactionArgs
  }

  // Custom InputTypes
  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceCountOutputType
     */
    select?: WorkspaceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceMemberWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountGoalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GoalWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountBudgetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountImportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImportJobWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountEnvelopesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnvelopeWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountAssetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountLiabilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LiabilityWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountAiInsightsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIInsightWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountScenariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScenarioWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountBankConnectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BankConnectionWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountAutoRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutoRuleWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountCashFlowProjectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashFlowProjectionWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Count Type AccountCountOutputType
   */

  export type AccountCountOutputType = {
    transactions: number
    fromTransfers: number
    toTransfers: number
    bankConnections: number
  }

  export type AccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | AccountCountOutputTypeCountTransactionsArgs
    fromTransfers?: boolean | AccountCountOutputTypeCountFromTransfersArgs
    toTransfers?: boolean | AccountCountOutputTypeCountToTransfersArgs
    bankConnections?: boolean | AccountCountOutputTypeCountBankConnectionsArgs
  }

  // Custom InputTypes
  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountCountOutputType
     */
    select?: AccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountFromTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountToTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountBankConnectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BankConnectionWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    children: number
    transactions: number
    budgets: number
    envelopes: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | CategoryCountOutputTypeCountChildrenArgs
    transactions?: boolean | CategoryCountOutputTypeCountTransactionsArgs
    budgets?: boolean | CategoryCountOutputTypeCountBudgetsArgs
    envelopes?: boolean | CategoryCountOutputTypeCountEnvelopesArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountBudgetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetCategoryWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountEnvelopesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnvelopeWhereInput
  }


  /**
   * Count Type BudgetCountOutputType
   */

  export type BudgetCountOutputType = {
    categories: number
  }

  export type BudgetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | BudgetCountOutputTypeCountCategoriesArgs
  }

  // Custom InputTypes
  /**
   * BudgetCountOutputType without action
   */
  export type BudgetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetCountOutputType
     */
    select?: BudgetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BudgetCountOutputType without action
   */
  export type BudgetCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetCategoryWhereInput
  }


  /**
   * Count Type GoalCountOutputType
   */

  export type GoalCountOutputType = {
    contributions: number
  }

  export type GoalCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contributions?: boolean | GoalCountOutputTypeCountContributionsArgs
  }

  // Custom InputTypes
  /**
   * GoalCountOutputType without action
   */
  export type GoalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalCountOutputType
     */
    select?: GoalCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GoalCountOutputType without action
   */
  export type GoalCountOutputTypeCountContributionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GoalContributionWhereInput
  }


  /**
   * Count Type UserGamificationCountOutputType
   */

  export type UserGamificationCountOutputType = {
    achievements: number
  }

  export type UserGamificationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    achievements?: boolean | UserGamificationCountOutputTypeCountAchievementsArgs
  }

  // Custom InputTypes
  /**
   * UserGamificationCountOutputType without action
   */
  export type UserGamificationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGamificationCountOutputType
     */
    select?: UserGamificationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserGamificationCountOutputType without action
   */
  export type UserGamificationCountOutputTypeCountAchievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAchievementWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    firstName: string | null
    lastName: string | null
    avatarUrl: string | null
    phone: string | null
    emailVerified: boolean | null
    twoFactorEnabled: boolean | null
    twoFactorSecret: string | null
    lastLoginAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    firstName: string | null
    lastName: string | null
    avatarUrl: string | null
    phone: string | null
    emailVerified: boolean | null
    twoFactorEnabled: boolean | null
    twoFactorSecret: string | null
    lastLoginAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    firstName: number
    lastName: number
    avatarUrl: number
    phone: number
    emailVerified: number
    twoFactorEnabled: number
    twoFactorSecret: number
    lastLoginAt: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    avatarUrl?: true
    phone?: true
    emailVerified?: true
    twoFactorEnabled?: true
    twoFactorSecret?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    avatarUrl?: true
    phone?: true
    emailVerified?: true
    twoFactorEnabled?: true
    twoFactorSecret?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    avatarUrl?: true
    phone?: true
    emailVerified?: true
    twoFactorEnabled?: true
    twoFactorSecret?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    avatarUrl: string | null
    phone: string | null
    emailVerified: boolean
    twoFactorEnabled: boolean
    twoFactorSecret: string | null
    lastLoginAt: Date | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    avatarUrl?: boolean
    phone?: boolean
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    workspaces?: boolean | User$workspacesArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    passwordResets?: boolean | User$passwordResetsArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    gamification?: boolean | User$gamificationArgs<ExtArgs>
    aiInsights?: boolean | User$aiInsightsArgs<ExtArgs>
    scenarios?: boolean | User$scenariosArgs<ExtArgs>
    autoRules?: boolean | User$autoRulesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    avatarUrl?: boolean
    phone?: boolean
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    avatarUrl?: boolean
    phone?: boolean
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspaces?: boolean | User$workspacesArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    passwordResets?: boolean | User$passwordResetsArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    gamification?: boolean | User$gamificationArgs<ExtArgs>
    aiInsights?: boolean | User$aiInsightsArgs<ExtArgs>
    scenarios?: boolean | User$scenariosArgs<ExtArgs>
    autoRules?: boolean | User$autoRulesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      workspaces: Prisma.$WorkspaceMemberPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      passwordResets: Prisma.$PasswordResetPayload<ExtArgs>[]
      refreshTokens: Prisma.$RefreshTokenPayload<ExtArgs>[]
      gamification: Prisma.$UserGamificationPayload<ExtArgs> | null
      aiInsights: Prisma.$AIInsightPayload<ExtArgs>[]
      scenarios: Prisma.$ScenarioPayload<ExtArgs>[]
      autoRules: Prisma.$AutoRulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      passwordHash: string
      firstName: string
      lastName: string
      avatarUrl: string | null
      phone: string | null
      emailVerified: boolean
      twoFactorEnabled: boolean
      twoFactorSecret: string | null
      lastLoginAt: Date | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspaces<T extends User$workspacesArgs<ExtArgs> = {}>(args?: Subset<T, User$workspacesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceMemberPayload<ExtArgs>, T, "findMany"> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany"> | Null>
    passwordResets<T extends User$passwordResetsArgs<ExtArgs> = {}>(args?: Subset<T, User$passwordResetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "findMany"> | Null>
    refreshTokens<T extends User$refreshTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$refreshTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany"> | Null>
    gamification<T extends User$gamificationArgs<ExtArgs> = {}>(args?: Subset<T, User$gamificationArgs<ExtArgs>>): Prisma__UserGamificationClient<$Result.GetResult<Prisma.$UserGamificationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    aiInsights<T extends User$aiInsightsArgs<ExtArgs> = {}>(args?: Subset<T, User$aiInsightsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIInsightPayload<ExtArgs>, T, "findMany"> | Null>
    scenarios<T extends User$scenariosArgs<ExtArgs> = {}>(args?: Subset<T, User$scenariosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "findMany"> | Null>
    autoRules<T extends User$autoRulesArgs<ExtArgs> = {}>(args?: Subset<T, User$autoRulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutoRulePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly avatarUrl: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly twoFactorEnabled: FieldRef<"User", 'Boolean'>
    readonly twoFactorSecret: FieldRef<"User", 'String'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly deletedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.workspaces
   */
  export type User$workspacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceMember
     */
    select?: WorkspaceMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceMemberInclude<ExtArgs> | null
    where?: WorkspaceMemberWhereInput
    orderBy?: WorkspaceMemberOrderByWithRelationInput | WorkspaceMemberOrderByWithRelationInput[]
    cursor?: WorkspaceMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkspaceMemberScalarFieldEnum | WorkspaceMemberScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.passwordResets
   */
  export type User$passwordResetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    where?: PasswordResetWhereInput
    orderBy?: PasswordResetOrderByWithRelationInput | PasswordResetOrderByWithRelationInput[]
    cursor?: PasswordResetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordResetScalarFieldEnum | PasswordResetScalarFieldEnum[]
  }

  /**
   * User.refreshTokens
   */
  export type User$refreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    cursor?: RefreshTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * User.gamification
   */
  export type User$gamificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGamification
     */
    select?: UserGamificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGamificationInclude<ExtArgs> | null
    where?: UserGamificationWhereInput
  }

  /**
   * User.aiInsights
   */
  export type User$aiInsightsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIInsight
     */
    select?: AIInsightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIInsightInclude<ExtArgs> | null
    where?: AIInsightWhereInput
    orderBy?: AIInsightOrderByWithRelationInput | AIInsightOrderByWithRelationInput[]
    cursor?: AIInsightWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIInsightScalarFieldEnum | AIInsightScalarFieldEnum[]
  }

  /**
   * User.scenarios
   */
  export type User$scenariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    where?: ScenarioWhereInput
    orderBy?: ScenarioOrderByWithRelationInput | ScenarioOrderByWithRelationInput[]
    cursor?: ScenarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScenarioScalarFieldEnum | ScenarioScalarFieldEnum[]
  }

  /**
   * User.autoRules
   */
  export type User$autoRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoRule
     */
    select?: AutoRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoRuleInclude<ExtArgs> | null
    where?: AutoRuleWhereInput
    orderBy?: AutoRuleOrderByWithRelationInput | AutoRuleOrderByWithRelationInput[]
    cursor?: AutoRuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AutoRuleScalarFieldEnum | AutoRuleScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    ipAddress: string | null
    userAgent: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    ipAddress: string | null
    userAgent: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    ipAddress: number
    userAgent: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    ipAddress?: true
    userAgent?: true
    expiresAt?: true
    createdAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    ipAddress?: true
    userAgent?: true
    expiresAt?: true
    createdAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    ipAddress?: true
    userAgent?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    userId: string
    token: string
    ipAddress: string | null
    userAgent: string | null
    expiresAt: Date
    createdAt: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      token: string
      ipAddress: string | null
      userAgent: string | null
      expiresAt: Date
      createdAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly token: FieldRef<"Session", 'String'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model RefreshToken
   */

  export type AggregateRefreshToken = {
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  export type RefreshTokenMinAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    createdAt: Date | null
    revokedAt: Date | null
  }

  export type RefreshTokenMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    createdAt: Date | null
    revokedAt: Date | null
  }

  export type RefreshTokenCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    expiresAt: number
    createdAt: number
    revokedAt: number
    _all: number
  }


  export type RefreshTokenMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    revokedAt?: true
  }

  export type RefreshTokenMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    revokedAt?: true
  }

  export type RefreshTokenCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    revokedAt?: true
    _all?: true
  }

  export type RefreshTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshToken to aggregate.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RefreshTokens
    **/
    _count?: true | RefreshTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefreshTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type GetRefreshTokenAggregateType<T extends RefreshTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateRefreshToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefreshToken[P]>
      : GetScalarType<T[P], AggregateRefreshToken[P]>
  }




  export type RefreshTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithAggregationInput | RefreshTokenOrderByWithAggregationInput[]
    by: RefreshTokenScalarFieldEnum[] | RefreshTokenScalarFieldEnum
    having?: RefreshTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefreshTokenCountAggregateInputType | true
    _min?: RefreshTokenMinAggregateInputType
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type RefreshTokenGroupByOutputType = {
    id: string
    userId: string
    token: string
    expiresAt: Date
    createdAt: Date
    revokedAt: Date | null
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  type GetRefreshTokenGroupByPayload<T extends RefreshTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefreshTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefreshTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
            : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
        }
      >
    >


  export type RefreshTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    revokedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    revokedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    revokedAt?: boolean
  }

  export type RefreshTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RefreshTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RefreshToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      token: string
      expiresAt: Date
      createdAt: Date
      revokedAt: Date | null
    }, ExtArgs["result"]["refreshToken"]>
    composites: {}
  }

  type RefreshTokenGetPayload<S extends boolean | null | undefined | RefreshTokenDefaultArgs> = $Result.GetResult<Prisma.$RefreshTokenPayload, S>

  type RefreshTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RefreshTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RefreshTokenCountAggregateInputType | true
    }

  export interface RefreshTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RefreshToken'], meta: { name: 'RefreshToken' } }
    /**
     * Find zero or one RefreshToken that matches the filter.
     * @param {RefreshTokenFindUniqueArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefreshTokenFindUniqueArgs>(args: SelectSubset<T, RefreshTokenFindUniqueArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RefreshToken that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RefreshTokenFindUniqueOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefreshTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, RefreshTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RefreshToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefreshTokenFindFirstArgs>(args?: SelectSubset<T, RefreshTokenFindFirstArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RefreshToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefreshTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, RefreshTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RefreshTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany()
     * 
     * // Get first 10 RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RefreshTokenFindManyArgs>(args?: SelectSubset<T, RefreshTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RefreshToken.
     * @param {RefreshTokenCreateArgs} args - Arguments to create a RefreshToken.
     * @example
     * // Create one RefreshToken
     * const RefreshToken = await prisma.refreshToken.create({
     *   data: {
     *     // ... data to create a RefreshToken
     *   }
     * })
     * 
     */
    create<T extends RefreshTokenCreateArgs>(args: SelectSubset<T, RefreshTokenCreateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RefreshTokens.
     * @param {RefreshTokenCreateManyArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefreshTokenCreateManyArgs>(args?: SelectSubset<T, RefreshTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RefreshTokens and returns the data saved in the database.
     * @param {RefreshTokenCreateManyAndReturnArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RefreshTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, RefreshTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RefreshToken.
     * @param {RefreshTokenDeleteArgs} args - Arguments to delete one RefreshToken.
     * @example
     * // Delete one RefreshToken
     * const RefreshToken = await prisma.refreshToken.delete({
     *   where: {
     *     // ... filter to delete one RefreshToken
     *   }
     * })
     * 
     */
    delete<T extends RefreshTokenDeleteArgs>(args: SelectSubset<T, RefreshTokenDeleteArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RefreshToken.
     * @param {RefreshTokenUpdateArgs} args - Arguments to update one RefreshToken.
     * @example
     * // Update one RefreshToken
     * const refreshToken = await prisma.refreshToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefreshTokenUpdateArgs>(args: SelectSubset<T, RefreshTokenUpdateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RefreshTokens.
     * @param {RefreshTokenDeleteManyArgs} args - Arguments to filter RefreshTokens to delete.
     * @example
     * // Delete a few RefreshTokens
     * const { count } = await prisma.refreshToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefreshTokenDeleteManyArgs>(args?: SelectSubset<T, RefreshTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefreshTokenUpdateManyArgs>(args: SelectSubset<T, RefreshTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RefreshToken.
     * @param {RefreshTokenUpsertArgs} args - Arguments to update or create a RefreshToken.
     * @example
     * // Update or create a RefreshToken
     * const refreshToken = await prisma.refreshToken.upsert({
     *   create: {
     *     // ... data to create a RefreshToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefreshToken we want to update
     *   }
     * })
     */
    upsert<T extends RefreshTokenUpsertArgs>(args: SelectSubset<T, RefreshTokenUpsertArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenCountArgs} args - Arguments to filter RefreshTokens to count.
     * @example
     * // Count the number of RefreshTokens
     * const count = await prisma.refreshToken.count({
     *   where: {
     *     // ... the filter for the RefreshTokens we want to count
     *   }
     * })
    **/
    count<T extends RefreshTokenCountArgs>(
      args?: Subset<T, RefreshTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefreshTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefreshTokenAggregateArgs>(args: Subset<T, RefreshTokenAggregateArgs>): Prisma.PrismaPromise<GetRefreshTokenAggregateType<T>>

    /**
     * Group by RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefreshTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefreshTokenGroupByArgs['orderBy'] }
        : { orderBy?: RefreshTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefreshTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefreshTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RefreshToken model
   */
  readonly fields: RefreshTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefreshToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefreshTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RefreshToken model
   */ 
  interface RefreshTokenFieldRefs {
    readonly id: FieldRef<"RefreshToken", 'String'>
    readonly userId: FieldRef<"RefreshToken", 'String'>
    readonly token: FieldRef<"RefreshToken", 'String'>
    readonly expiresAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly createdAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly revokedAt: FieldRef<"RefreshToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RefreshToken findUnique
   */
  export type RefreshTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findUniqueOrThrow
   */
  export type RefreshTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findFirst
   */
  export type RefreshTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findFirstOrThrow
   */
  export type RefreshTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findMany
   */
  export type RefreshTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshTokens to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken create
   */
  export type RefreshTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a RefreshToken.
     */
    data: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
  }

  /**
   * RefreshToken createMany
   */
  export type RefreshTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
  }

  /**
   * RefreshToken createManyAndReturn
   */
  export type RefreshTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken update
   */
  export type RefreshTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a RefreshToken.
     */
    data: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
    /**
     * Choose, which RefreshToken to update.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken updateMany
   */
  export type RefreshTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
  }

  /**
   * RefreshToken upsert
   */
  export type RefreshTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the RefreshToken to update in case it exists.
     */
    where: RefreshTokenWhereUniqueInput
    /**
     * In case the RefreshToken found by the `where` argument doesn't exist, create a new RefreshToken with this data.
     */
    create: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
    /**
     * In case the RefreshToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
  }

  /**
   * RefreshToken delete
   */
  export type RefreshTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter which RefreshToken to delete.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken deleteMany
   */
  export type RefreshTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshTokens to delete
     */
    where?: RefreshTokenWhereInput
  }

  /**
   * RefreshToken without action
   */
  export type RefreshTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
  }


  /**
   * Model PasswordReset
   */

  export type AggregatePasswordReset = {
    _count: PasswordResetCountAggregateOutputType | null
    _min: PasswordResetMinAggregateOutputType | null
    _max: PasswordResetMaxAggregateOutputType | null
  }

  export type PasswordResetMinAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    usedAt: Date | null
    createdAt: Date | null
  }

  export type PasswordResetMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    usedAt: Date | null
    createdAt: Date | null
  }

  export type PasswordResetCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    expiresAt: number
    usedAt: number
    createdAt: number
    _all: number
  }


  export type PasswordResetMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    usedAt?: true
    createdAt?: true
  }

  export type PasswordResetMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    usedAt?: true
    createdAt?: true
  }

  export type PasswordResetCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    usedAt?: true
    createdAt?: true
    _all?: true
  }

  export type PasswordResetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordReset to aggregate.
     */
    where?: PasswordResetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResets to fetch.
     */
    orderBy?: PasswordResetOrderByWithRelationInput | PasswordResetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordResetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordResets
    **/
    _count?: true | PasswordResetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordResetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordResetMaxAggregateInputType
  }

  export type GetPasswordResetAggregateType<T extends PasswordResetAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordReset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordReset[P]>
      : GetScalarType<T[P], AggregatePasswordReset[P]>
  }




  export type PasswordResetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetWhereInput
    orderBy?: PasswordResetOrderByWithAggregationInput | PasswordResetOrderByWithAggregationInput[]
    by: PasswordResetScalarFieldEnum[] | PasswordResetScalarFieldEnum
    having?: PasswordResetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordResetCountAggregateInputType | true
    _min?: PasswordResetMinAggregateInputType
    _max?: PasswordResetMaxAggregateInputType
  }

  export type PasswordResetGroupByOutputType = {
    id: string
    userId: string
    token: string
    expiresAt: Date
    usedAt: Date | null
    createdAt: Date
    _count: PasswordResetCountAggregateOutputType | null
    _min: PasswordResetMinAggregateOutputType | null
    _max: PasswordResetMaxAggregateOutputType | null
  }

  type GetPasswordResetGroupByPayload<T extends PasswordResetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordResetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordResetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordResetGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordResetGroupByOutputType[P]>
        }
      >
    >


  export type PasswordResetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    usedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordReset"]>

  export type PasswordResetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    usedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordReset"]>

  export type PasswordResetSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    usedAt?: boolean
    createdAt?: boolean
  }

  export type PasswordResetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordResetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PasswordResetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordReset"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      token: string
      expiresAt: Date
      usedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["passwordReset"]>
    composites: {}
  }

  type PasswordResetGetPayload<S extends boolean | null | undefined | PasswordResetDefaultArgs> = $Result.GetResult<Prisma.$PasswordResetPayload, S>

  type PasswordResetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PasswordResetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PasswordResetCountAggregateInputType | true
    }

  export interface PasswordResetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordReset'], meta: { name: 'PasswordReset' } }
    /**
     * Find zero or one PasswordReset that matches the filter.
     * @param {PasswordResetFindUniqueArgs} args - Arguments to find a PasswordReset
     * @example
     * // Get one PasswordReset
     * const passwordReset = await prisma.passwordReset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordResetFindUniqueArgs>(args: SelectSubset<T, PasswordResetFindUniqueArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PasswordReset that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PasswordResetFindUniqueOrThrowArgs} args - Arguments to find a PasswordReset
     * @example
     * // Get one PasswordReset
     * const passwordReset = await prisma.passwordReset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordResetFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordResetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PasswordReset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetFindFirstArgs} args - Arguments to find a PasswordReset
     * @example
     * // Get one PasswordReset
     * const passwordReset = await prisma.passwordReset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordResetFindFirstArgs>(args?: SelectSubset<T, PasswordResetFindFirstArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PasswordReset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetFindFirstOrThrowArgs} args - Arguments to find a PasswordReset
     * @example
     * // Get one PasswordReset
     * const passwordReset = await prisma.passwordReset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordResetFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordResetFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PasswordResets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordResets
     * const passwordResets = await prisma.passwordReset.findMany()
     * 
     * // Get first 10 PasswordResets
     * const passwordResets = await prisma.passwordReset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordResetWithIdOnly = await prisma.passwordReset.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordResetFindManyArgs>(args?: SelectSubset<T, PasswordResetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PasswordReset.
     * @param {PasswordResetCreateArgs} args - Arguments to create a PasswordReset.
     * @example
     * // Create one PasswordReset
     * const PasswordReset = await prisma.passwordReset.create({
     *   data: {
     *     // ... data to create a PasswordReset
     *   }
     * })
     * 
     */
    create<T extends PasswordResetCreateArgs>(args: SelectSubset<T, PasswordResetCreateArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PasswordResets.
     * @param {PasswordResetCreateManyArgs} args - Arguments to create many PasswordResets.
     * @example
     * // Create many PasswordResets
     * const passwordReset = await prisma.passwordReset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordResetCreateManyArgs>(args?: SelectSubset<T, PasswordResetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordResets and returns the data saved in the database.
     * @param {PasswordResetCreateManyAndReturnArgs} args - Arguments to create many PasswordResets.
     * @example
     * // Create many PasswordResets
     * const passwordReset = await prisma.passwordReset.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordResets and only return the `id`
     * const passwordResetWithIdOnly = await prisma.passwordReset.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordResetCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordResetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PasswordReset.
     * @param {PasswordResetDeleteArgs} args - Arguments to delete one PasswordReset.
     * @example
     * // Delete one PasswordReset
     * const PasswordReset = await prisma.passwordReset.delete({
     *   where: {
     *     // ... filter to delete one PasswordReset
     *   }
     * })
     * 
     */
    delete<T extends PasswordResetDeleteArgs>(args: SelectSubset<T, PasswordResetDeleteArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PasswordReset.
     * @param {PasswordResetUpdateArgs} args - Arguments to update one PasswordReset.
     * @example
     * // Update one PasswordReset
     * const passwordReset = await prisma.passwordReset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordResetUpdateArgs>(args: SelectSubset<T, PasswordResetUpdateArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PasswordResets.
     * @param {PasswordResetDeleteManyArgs} args - Arguments to filter PasswordResets to delete.
     * @example
     * // Delete a few PasswordResets
     * const { count } = await prisma.passwordReset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordResetDeleteManyArgs>(args?: SelectSubset<T, PasswordResetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordResets
     * const passwordReset = await prisma.passwordReset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordResetUpdateManyArgs>(args: SelectSubset<T, PasswordResetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PasswordReset.
     * @param {PasswordResetUpsertArgs} args - Arguments to update or create a PasswordReset.
     * @example
     * // Update or create a PasswordReset
     * const passwordReset = await prisma.passwordReset.upsert({
     *   create: {
     *     // ... data to create a PasswordReset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordReset we want to update
     *   }
     * })
     */
    upsert<T extends PasswordResetUpsertArgs>(args: SelectSubset<T, PasswordResetUpsertArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PasswordResets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetCountArgs} args - Arguments to filter PasswordResets to count.
     * @example
     * // Count the number of PasswordResets
     * const count = await prisma.passwordReset.count({
     *   where: {
     *     // ... the filter for the PasswordResets we want to count
     *   }
     * })
    **/
    count<T extends PasswordResetCountArgs>(
      args?: Subset<T, PasswordResetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordResetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordReset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordResetAggregateArgs>(args: Subset<T, PasswordResetAggregateArgs>): Prisma.PrismaPromise<GetPasswordResetAggregateType<T>>

    /**
     * Group by PasswordReset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordResetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordResetGroupByArgs['orderBy'] }
        : { orderBy?: PasswordResetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordResetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordResetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordReset model
   */
  readonly fields: PasswordResetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordReset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordResetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordReset model
   */ 
  interface PasswordResetFieldRefs {
    readonly id: FieldRef<"PasswordReset", 'String'>
    readonly userId: FieldRef<"PasswordReset", 'String'>
    readonly token: FieldRef<"PasswordReset", 'String'>
    readonly expiresAt: FieldRef<"PasswordReset", 'DateTime'>
    readonly usedAt: FieldRef<"PasswordReset", 'DateTime'>
    readonly createdAt: FieldRef<"PasswordReset", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PasswordReset findUnique
   */
  export type PasswordResetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * Filter, which PasswordReset to fetch.
     */
    where: PasswordResetWhereUniqueInput
  }

  /**
   * PasswordReset findUniqueOrThrow
   */
  export type PasswordResetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * Filter, which PasswordReset to fetch.
     */
    where: PasswordResetWhereUniqueInput
  }

  /**
   * PasswordReset findFirst
   */
  export type PasswordResetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * Filter, which PasswordReset to fetch.
     */
    where?: PasswordResetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResets to fetch.
     */
    orderBy?: PasswordResetOrderByWithRelationInput | PasswordResetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResets.
     */
    cursor?: PasswordResetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResets.
     */
    distinct?: PasswordResetScalarFieldEnum | PasswordResetScalarFieldEnum[]
  }

  /**
   * PasswordReset findFirstOrThrow
   */
  export type PasswordResetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * Filter, which PasswordReset to fetch.
     */
    where?: PasswordResetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResets to fetch.
     */
    orderBy?: PasswordResetOrderByWithRelationInput | PasswordResetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResets.
     */
    cursor?: PasswordResetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResets.
     */
    distinct?: PasswordResetScalarFieldEnum | PasswordResetScalarFieldEnum[]
  }

  /**
   * PasswordReset findMany
   */
  export type PasswordResetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResets to fetch.
     */
    where?: PasswordResetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResets to fetch.
     */
    orderBy?: PasswordResetOrderByWithRelationInput | PasswordResetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordResets.
     */
    cursor?: PasswordResetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResets.
     */
    skip?: number
    distinct?: PasswordResetScalarFieldEnum | PasswordResetScalarFieldEnum[]
  }

  /**
   * PasswordReset create
   */
  export type PasswordResetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * The data needed to create a PasswordReset.
     */
    data: XOR<PasswordResetCreateInput, PasswordResetUncheckedCreateInput>
  }

  /**
   * PasswordReset createMany
   */
  export type PasswordResetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordResets.
     */
    data: PasswordResetCreateManyInput | PasswordResetCreateManyInput[]
  }

  /**
   * PasswordReset createManyAndReturn
   */
  export type PasswordResetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PasswordResets.
     */
    data: PasswordResetCreateManyInput | PasswordResetCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordReset update
   */
  export type PasswordResetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * The data needed to update a PasswordReset.
     */
    data: XOR<PasswordResetUpdateInput, PasswordResetUncheckedUpdateInput>
    /**
     * Choose, which PasswordReset to update.
     */
    where: PasswordResetWhereUniqueInput
  }

  /**
   * PasswordReset updateMany
   */
  export type PasswordResetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordResets.
     */
    data: XOR<PasswordResetUpdateManyMutationInput, PasswordResetUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResets to update
     */
    where?: PasswordResetWhereInput
  }

  /**
   * PasswordReset upsert
   */
  export type PasswordResetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * The filter to search for the PasswordReset to update in case it exists.
     */
    where: PasswordResetWhereUniqueInput
    /**
     * In case the PasswordReset found by the `where` argument doesn't exist, create a new PasswordReset with this data.
     */
    create: XOR<PasswordResetCreateInput, PasswordResetUncheckedCreateInput>
    /**
     * In case the PasswordReset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordResetUpdateInput, PasswordResetUncheckedUpdateInput>
  }

  /**
   * PasswordReset delete
   */
  export type PasswordResetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * Filter which PasswordReset to delete.
     */
    where: PasswordResetWhereUniqueInput
  }

  /**
   * PasswordReset deleteMany
   */
  export type PasswordResetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResets to delete
     */
    where?: PasswordResetWhereInput
  }

  /**
   * PasswordReset without action
   */
  export type PasswordResetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
  }


  /**
   * Model Workspace
   */

  export type AggregateWorkspace = {
    _count: WorkspaceCountAggregateOutputType | null
    _min: WorkspaceMinAggregateOutputType | null
    _max: WorkspaceMaxAggregateOutputType | null
  }

  export type WorkspaceMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    type: string | null
    currency: string | null
    timezone: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkspaceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    type: string | null
    currency: string | null
    timezone: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkspaceCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    type: number
    currency: number
    timezone: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WorkspaceMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    type?: true
    currency?: true
    timezone?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkspaceMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    type?: true
    currency?: true
    timezone?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkspaceCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    type?: true
    currency?: true
    timezone?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WorkspaceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workspace to aggregate.
     */
    where?: WorkspaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workspaces to fetch.
     */
    orderBy?: WorkspaceOrderByWithRelationInput | WorkspaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkspaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workspaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workspaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Workspaces
    **/
    _count?: true | WorkspaceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkspaceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkspaceMaxAggregateInputType
  }

  export type GetWorkspaceAggregateType<T extends WorkspaceAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkspace]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkspace[P]>
      : GetScalarType<T[P], AggregateWorkspace[P]>
  }




  export type WorkspaceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceWhereInput
    orderBy?: WorkspaceOrderByWithAggregationInput | WorkspaceOrderByWithAggregationInput[]
    by: WorkspaceScalarFieldEnum[] | WorkspaceScalarFieldEnum
    having?: WorkspaceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkspaceCountAggregateInputType | true
    _min?: WorkspaceMinAggregateInputType
    _max?: WorkspaceMaxAggregateInputType
  }

  export type WorkspaceGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    type: string
    currency: string
    timezone: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: WorkspaceCountAggregateOutputType | null
    _min: WorkspaceMinAggregateOutputType | null
    _max: WorkspaceMaxAggregateOutputType | null
  }

  type GetWorkspaceGroupByPayload<T extends WorkspaceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkspaceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkspaceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkspaceGroupByOutputType[P]>
            : GetScalarType<T[P], WorkspaceGroupByOutputType[P]>
        }
      >
    >


  export type WorkspaceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    type?: boolean
    currency?: boolean
    timezone?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    members?: boolean | Workspace$membersArgs<ExtArgs>
    accounts?: boolean | Workspace$accountsArgs<ExtArgs>
    categories?: boolean | Workspace$categoriesArgs<ExtArgs>
    goals?: boolean | Workspace$goalsArgs<ExtArgs>
    budgets?: boolean | Workspace$budgetsArgs<ExtArgs>
    imports?: boolean | Workspace$importsArgs<ExtArgs>
    auditLogs?: boolean | Workspace$auditLogsArgs<ExtArgs>
    envelopes?: boolean | Workspace$envelopesArgs<ExtArgs>
    assets?: boolean | Workspace$assetsArgs<ExtArgs>
    liabilities?: boolean | Workspace$liabilitiesArgs<ExtArgs>
    aiInsights?: boolean | Workspace$aiInsightsArgs<ExtArgs>
    scenarios?: boolean | Workspace$scenariosArgs<ExtArgs>
    bankConnections?: boolean | Workspace$bankConnectionsArgs<ExtArgs>
    autoRules?: boolean | Workspace$autoRulesArgs<ExtArgs>
    cashFlowProjections?: boolean | Workspace$cashFlowProjectionsArgs<ExtArgs>
    Transaction?: boolean | Workspace$TransactionArgs<ExtArgs>
    _count?: boolean | WorkspaceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspace"]>

  export type WorkspaceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    type?: boolean
    currency?: boolean
    timezone?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["workspace"]>

  export type WorkspaceSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    type?: boolean
    currency?: boolean
    timezone?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WorkspaceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | Workspace$membersArgs<ExtArgs>
    accounts?: boolean | Workspace$accountsArgs<ExtArgs>
    categories?: boolean | Workspace$categoriesArgs<ExtArgs>
    goals?: boolean | Workspace$goalsArgs<ExtArgs>
    budgets?: boolean | Workspace$budgetsArgs<ExtArgs>
    imports?: boolean | Workspace$importsArgs<ExtArgs>
    auditLogs?: boolean | Workspace$auditLogsArgs<ExtArgs>
    envelopes?: boolean | Workspace$envelopesArgs<ExtArgs>
    assets?: boolean | Workspace$assetsArgs<ExtArgs>
    liabilities?: boolean | Workspace$liabilitiesArgs<ExtArgs>
    aiInsights?: boolean | Workspace$aiInsightsArgs<ExtArgs>
    scenarios?: boolean | Workspace$scenariosArgs<ExtArgs>
    bankConnections?: boolean | Workspace$bankConnectionsArgs<ExtArgs>
    autoRules?: boolean | Workspace$autoRulesArgs<ExtArgs>
    cashFlowProjections?: boolean | Workspace$cashFlowProjectionsArgs<ExtArgs>
    Transaction?: boolean | Workspace$TransactionArgs<ExtArgs>
    _count?: boolean | WorkspaceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkspaceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $WorkspacePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Workspace"
    objects: {
      members: Prisma.$WorkspaceMemberPayload<ExtArgs>[]
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      categories: Prisma.$CategoryPayload<ExtArgs>[]
      goals: Prisma.$GoalPayload<ExtArgs>[]
      budgets: Prisma.$BudgetPayload<ExtArgs>[]
      imports: Prisma.$ImportJobPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      envelopes: Prisma.$EnvelopePayload<ExtArgs>[]
      assets: Prisma.$AssetPayload<ExtArgs>[]
      liabilities: Prisma.$LiabilityPayload<ExtArgs>[]
      aiInsights: Prisma.$AIInsightPayload<ExtArgs>[]
      scenarios: Prisma.$ScenarioPayload<ExtArgs>[]
      bankConnections: Prisma.$BankConnectionPayload<ExtArgs>[]
      autoRules: Prisma.$AutoRulePayload<ExtArgs>[]
      cashFlowProjections: Prisma.$CashFlowProjectionPayload<ExtArgs>[]
      Transaction: Prisma.$TransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string | null
      type: string
      currency: string
      timezone: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["workspace"]>
    composites: {}
  }

  type WorkspaceGetPayload<S extends boolean | null | undefined | WorkspaceDefaultArgs> = $Result.GetResult<Prisma.$WorkspacePayload, S>

  type WorkspaceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkspaceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkspaceCountAggregateInputType | true
    }

  export interface WorkspaceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Workspace'], meta: { name: 'Workspace' } }
    /**
     * Find zero or one Workspace that matches the filter.
     * @param {WorkspaceFindUniqueArgs} args - Arguments to find a Workspace
     * @example
     * // Get one Workspace
     * const workspace = await prisma.workspace.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkspaceFindUniqueArgs>(args: SelectSubset<T, WorkspaceFindUniqueArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Workspace that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkspaceFindUniqueOrThrowArgs} args - Arguments to find a Workspace
     * @example
     * // Get one Workspace
     * const workspace = await prisma.workspace.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkspaceFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkspaceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Workspace that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceFindFirstArgs} args - Arguments to find a Workspace
     * @example
     * // Get one Workspace
     * const workspace = await prisma.workspace.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkspaceFindFirstArgs>(args?: SelectSubset<T, WorkspaceFindFirstArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Workspace that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceFindFirstOrThrowArgs} args - Arguments to find a Workspace
     * @example
     * // Get one Workspace
     * const workspace = await prisma.workspace.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkspaceFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkspaceFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Workspaces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Workspaces
     * const workspaces = await prisma.workspace.findMany()
     * 
     * // Get first 10 Workspaces
     * const workspaces = await prisma.workspace.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workspaceWithIdOnly = await prisma.workspace.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkspaceFindManyArgs>(args?: SelectSubset<T, WorkspaceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Workspace.
     * @param {WorkspaceCreateArgs} args - Arguments to create a Workspace.
     * @example
     * // Create one Workspace
     * const Workspace = await prisma.workspace.create({
     *   data: {
     *     // ... data to create a Workspace
     *   }
     * })
     * 
     */
    create<T extends WorkspaceCreateArgs>(args: SelectSubset<T, WorkspaceCreateArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Workspaces.
     * @param {WorkspaceCreateManyArgs} args - Arguments to create many Workspaces.
     * @example
     * // Create many Workspaces
     * const workspace = await prisma.workspace.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkspaceCreateManyArgs>(args?: SelectSubset<T, WorkspaceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Workspaces and returns the data saved in the database.
     * @param {WorkspaceCreateManyAndReturnArgs} args - Arguments to create many Workspaces.
     * @example
     * // Create many Workspaces
     * const workspace = await prisma.workspace.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Workspaces and only return the `id`
     * const workspaceWithIdOnly = await prisma.workspace.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkspaceCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkspaceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Workspace.
     * @param {WorkspaceDeleteArgs} args - Arguments to delete one Workspace.
     * @example
     * // Delete one Workspace
     * const Workspace = await prisma.workspace.delete({
     *   where: {
     *     // ... filter to delete one Workspace
     *   }
     * })
     * 
     */
    delete<T extends WorkspaceDeleteArgs>(args: SelectSubset<T, WorkspaceDeleteArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Workspace.
     * @param {WorkspaceUpdateArgs} args - Arguments to update one Workspace.
     * @example
     * // Update one Workspace
     * const workspace = await prisma.workspace.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkspaceUpdateArgs>(args: SelectSubset<T, WorkspaceUpdateArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Workspaces.
     * @param {WorkspaceDeleteManyArgs} args - Arguments to filter Workspaces to delete.
     * @example
     * // Delete a few Workspaces
     * const { count } = await prisma.workspace.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkspaceDeleteManyArgs>(args?: SelectSubset<T, WorkspaceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workspaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Workspaces
     * const workspace = await prisma.workspace.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkspaceUpdateManyArgs>(args: SelectSubset<T, WorkspaceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Workspace.
     * @param {WorkspaceUpsertArgs} args - Arguments to update or create a Workspace.
     * @example
     * // Update or create a Workspace
     * const workspace = await prisma.workspace.upsert({
     *   create: {
     *     // ... data to create a Workspace
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Workspace we want to update
     *   }
     * })
     */
    upsert<T extends WorkspaceUpsertArgs>(args: SelectSubset<T, WorkspaceUpsertArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Workspaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceCountArgs} args - Arguments to filter Workspaces to count.
     * @example
     * // Count the number of Workspaces
     * const count = await prisma.workspace.count({
     *   where: {
     *     // ... the filter for the Workspaces we want to count
     *   }
     * })
    **/
    count<T extends WorkspaceCountArgs>(
      args?: Subset<T, WorkspaceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkspaceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Workspace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkspaceAggregateArgs>(args: Subset<T, WorkspaceAggregateArgs>): Prisma.PrismaPromise<GetWorkspaceAggregateType<T>>

    /**
     * Group by Workspace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkspaceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkspaceGroupByArgs['orderBy'] }
        : { orderBy?: WorkspaceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkspaceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkspaceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Workspace model
   */
  readonly fields: WorkspaceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Workspace.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkspaceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    members<T extends Workspace$membersArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceMemberPayload<ExtArgs>, T, "findMany"> | Null>
    accounts<T extends Workspace$accountsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany"> | Null>
    categories<T extends Workspace$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany"> | Null>
    goals<T extends Workspace$goalsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$goalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findMany"> | Null>
    budgets<T extends Workspace$budgetsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$budgetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findMany"> | Null>
    imports<T extends Workspace$importsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$importsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImportJobPayload<ExtArgs>, T, "findMany"> | Null>
    auditLogs<T extends Workspace$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany"> | Null>
    envelopes<T extends Workspace$envelopesArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$envelopesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnvelopePayload<ExtArgs>, T, "findMany"> | Null>
    assets<T extends Workspace$assetsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$assetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findMany"> | Null>
    liabilities<T extends Workspace$liabilitiesArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$liabilitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiabilityPayload<ExtArgs>, T, "findMany"> | Null>
    aiInsights<T extends Workspace$aiInsightsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$aiInsightsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIInsightPayload<ExtArgs>, T, "findMany"> | Null>
    scenarios<T extends Workspace$scenariosArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$scenariosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "findMany"> | Null>
    bankConnections<T extends Workspace$bankConnectionsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$bankConnectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankConnectionPayload<ExtArgs>, T, "findMany"> | Null>
    autoRules<T extends Workspace$autoRulesArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$autoRulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutoRulePayload<ExtArgs>, T, "findMany"> | Null>
    cashFlowProjections<T extends Workspace$cashFlowProjectionsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$cashFlowProjectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashFlowProjectionPayload<ExtArgs>, T, "findMany"> | Null>
    Transaction<T extends Workspace$TransactionArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$TransactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Workspace model
   */ 
  interface WorkspaceFieldRefs {
    readonly id: FieldRef<"Workspace", 'String'>
    readonly name: FieldRef<"Workspace", 'String'>
    readonly slug: FieldRef<"Workspace", 'String'>
    readonly description: FieldRef<"Workspace", 'String'>
    readonly type: FieldRef<"Workspace", 'String'>
    readonly currency: FieldRef<"Workspace", 'String'>
    readonly timezone: FieldRef<"Workspace", 'String'>
    readonly isActive: FieldRef<"Workspace", 'Boolean'>
    readonly createdAt: FieldRef<"Workspace", 'DateTime'>
    readonly updatedAt: FieldRef<"Workspace", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Workspace findUnique
   */
  export type WorkspaceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspace to fetch.
     */
    where: WorkspaceWhereUniqueInput
  }

  /**
   * Workspace findUniqueOrThrow
   */
  export type WorkspaceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspace to fetch.
     */
    where: WorkspaceWhereUniqueInput
  }

  /**
   * Workspace findFirst
   */
  export type WorkspaceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspace to fetch.
     */
    where?: WorkspaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workspaces to fetch.
     */
    orderBy?: WorkspaceOrderByWithRelationInput | WorkspaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workspaces.
     */
    cursor?: WorkspaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workspaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workspaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workspaces.
     */
    distinct?: WorkspaceScalarFieldEnum | WorkspaceScalarFieldEnum[]
  }

  /**
   * Workspace findFirstOrThrow
   */
  export type WorkspaceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspace to fetch.
     */
    where?: WorkspaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workspaces to fetch.
     */
    orderBy?: WorkspaceOrderByWithRelationInput | WorkspaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workspaces.
     */
    cursor?: WorkspaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workspaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workspaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workspaces.
     */
    distinct?: WorkspaceScalarFieldEnum | WorkspaceScalarFieldEnum[]
  }

  /**
   * Workspace findMany
   */
  export type WorkspaceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspaces to fetch.
     */
    where?: WorkspaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workspaces to fetch.
     */
    orderBy?: WorkspaceOrderByWithRelationInput | WorkspaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Workspaces.
     */
    cursor?: WorkspaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workspaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workspaces.
     */
    skip?: number
    distinct?: WorkspaceScalarFieldEnum | WorkspaceScalarFieldEnum[]
  }

  /**
   * Workspace create
   */
  export type WorkspaceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * The data needed to create a Workspace.
     */
    data: XOR<WorkspaceCreateInput, WorkspaceUncheckedCreateInput>
  }

  /**
   * Workspace createMany
   */
  export type WorkspaceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Workspaces.
     */
    data: WorkspaceCreateManyInput | WorkspaceCreateManyInput[]
  }

  /**
   * Workspace createManyAndReturn
   */
  export type WorkspaceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Workspaces.
     */
    data: WorkspaceCreateManyInput | WorkspaceCreateManyInput[]
  }

  /**
   * Workspace update
   */
  export type WorkspaceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * The data needed to update a Workspace.
     */
    data: XOR<WorkspaceUpdateInput, WorkspaceUncheckedUpdateInput>
    /**
     * Choose, which Workspace to update.
     */
    where: WorkspaceWhereUniqueInput
  }

  /**
   * Workspace updateMany
   */
  export type WorkspaceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Workspaces.
     */
    data: XOR<WorkspaceUpdateManyMutationInput, WorkspaceUncheckedUpdateManyInput>
    /**
     * Filter which Workspaces to update
     */
    where?: WorkspaceWhereInput
  }

  /**
   * Workspace upsert
   */
  export type WorkspaceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * The filter to search for the Workspace to update in case it exists.
     */
    where: WorkspaceWhereUniqueInput
    /**
     * In case the Workspace found by the `where` argument doesn't exist, create a new Workspace with this data.
     */
    create: XOR<WorkspaceCreateInput, WorkspaceUncheckedCreateInput>
    /**
     * In case the Workspace was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkspaceUpdateInput, WorkspaceUncheckedUpdateInput>
  }

  /**
   * Workspace delete
   */
  export type WorkspaceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter which Workspace to delete.
     */
    where: WorkspaceWhereUniqueInput
  }

  /**
   * Workspace deleteMany
   */
  export type WorkspaceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workspaces to delete
     */
    where?: WorkspaceWhereInput
  }

  /**
   * Workspace.members
   */
  export type Workspace$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceMember
     */
    select?: WorkspaceMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceMemberInclude<ExtArgs> | null
    where?: WorkspaceMemberWhereInput
    orderBy?: WorkspaceMemberOrderByWithRelationInput | WorkspaceMemberOrderByWithRelationInput[]
    cursor?: WorkspaceMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkspaceMemberScalarFieldEnum | WorkspaceMemberScalarFieldEnum[]
  }

  /**
   * Workspace.accounts
   */
  export type Workspace$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Workspace.categories
   */
  export type Workspace$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    cursor?: CategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Workspace.goals
   */
  export type Workspace$goalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    where?: GoalWhereInput
    orderBy?: GoalOrderByWithRelationInput | GoalOrderByWithRelationInput[]
    cursor?: GoalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GoalScalarFieldEnum | GoalScalarFieldEnum[]
  }

  /**
   * Workspace.budgets
   */
  export type Workspace$budgetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    where?: BudgetWhereInput
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    cursor?: BudgetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * Workspace.imports
   */
  export type Workspace$importsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportJob
     */
    select?: ImportJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportJobInclude<ExtArgs> | null
    where?: ImportJobWhereInput
    orderBy?: ImportJobOrderByWithRelationInput | ImportJobOrderByWithRelationInput[]
    cursor?: ImportJobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImportJobScalarFieldEnum | ImportJobScalarFieldEnum[]
  }

  /**
   * Workspace.auditLogs
   */
  export type Workspace$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * Workspace.envelopes
   */
  export type Workspace$envelopesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Envelope
     */
    select?: EnvelopeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvelopeInclude<ExtArgs> | null
    where?: EnvelopeWhereInput
    orderBy?: EnvelopeOrderByWithRelationInput | EnvelopeOrderByWithRelationInput[]
    cursor?: EnvelopeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnvelopeScalarFieldEnum | EnvelopeScalarFieldEnum[]
  }

  /**
   * Workspace.assets
   */
  export type Workspace$assetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    where?: AssetWhereInput
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    cursor?: AssetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Workspace.liabilities
   */
  export type Workspace$liabilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liability
     */
    select?: LiabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiabilityInclude<ExtArgs> | null
    where?: LiabilityWhereInput
    orderBy?: LiabilityOrderByWithRelationInput | LiabilityOrderByWithRelationInput[]
    cursor?: LiabilityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LiabilityScalarFieldEnum | LiabilityScalarFieldEnum[]
  }

  /**
   * Workspace.aiInsights
   */
  export type Workspace$aiInsightsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIInsight
     */
    select?: AIInsightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIInsightInclude<ExtArgs> | null
    where?: AIInsightWhereInput
    orderBy?: AIInsightOrderByWithRelationInput | AIInsightOrderByWithRelationInput[]
    cursor?: AIInsightWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIInsightScalarFieldEnum | AIInsightScalarFieldEnum[]
  }

  /**
   * Workspace.scenarios
   */
  export type Workspace$scenariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    where?: ScenarioWhereInput
    orderBy?: ScenarioOrderByWithRelationInput | ScenarioOrderByWithRelationInput[]
    cursor?: ScenarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScenarioScalarFieldEnum | ScenarioScalarFieldEnum[]
  }

  /**
   * Workspace.bankConnections
   */
  export type Workspace$bankConnectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankConnection
     */
    select?: BankConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankConnectionInclude<ExtArgs> | null
    where?: BankConnectionWhereInput
    orderBy?: BankConnectionOrderByWithRelationInput | BankConnectionOrderByWithRelationInput[]
    cursor?: BankConnectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BankConnectionScalarFieldEnum | BankConnectionScalarFieldEnum[]
  }

  /**
   * Workspace.autoRules
   */
  export type Workspace$autoRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoRule
     */
    select?: AutoRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoRuleInclude<ExtArgs> | null
    where?: AutoRuleWhereInput
    orderBy?: AutoRuleOrderByWithRelationInput | AutoRuleOrderByWithRelationInput[]
    cursor?: AutoRuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AutoRuleScalarFieldEnum | AutoRuleScalarFieldEnum[]
  }

  /**
   * Workspace.cashFlowProjections
   */
  export type Workspace$cashFlowProjectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashFlowProjection
     */
    select?: CashFlowProjectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashFlowProjectionInclude<ExtArgs> | null
    where?: CashFlowProjectionWhereInput
    orderBy?: CashFlowProjectionOrderByWithRelationInput | CashFlowProjectionOrderByWithRelationInput[]
    cursor?: CashFlowProjectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CashFlowProjectionScalarFieldEnum | CashFlowProjectionScalarFieldEnum[]
  }

  /**
   * Workspace.Transaction
   */
  export type Workspace$TransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Workspace without action
   */
  export type WorkspaceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
  }


  /**
   * Model WorkspaceMember
   */

  export type AggregateWorkspaceMember = {
    _count: WorkspaceMemberCountAggregateOutputType | null
    _min: WorkspaceMemberMinAggregateOutputType | null
    _max: WorkspaceMemberMaxAggregateOutputType | null
  }

  export type WorkspaceMemberMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    userId: string | null
    role: string | null
    joinedAt: Date | null
    invitedBy: string | null
  }

  export type WorkspaceMemberMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    userId: string | null
    role: string | null
    joinedAt: Date | null
    invitedBy: string | null
  }

  export type WorkspaceMemberCountAggregateOutputType = {
    id: number
    workspaceId: number
    userId: number
    role: number
    joinedAt: number
    invitedBy: number
    _all: number
  }


  export type WorkspaceMemberMinAggregateInputType = {
    id?: true
    workspaceId?: true
    userId?: true
    role?: true
    joinedAt?: true
    invitedBy?: true
  }

  export type WorkspaceMemberMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    userId?: true
    role?: true
    joinedAt?: true
    invitedBy?: true
  }

  export type WorkspaceMemberCountAggregateInputType = {
    id?: true
    workspaceId?: true
    userId?: true
    role?: true
    joinedAt?: true
    invitedBy?: true
    _all?: true
  }

  export type WorkspaceMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkspaceMember to aggregate.
     */
    where?: WorkspaceMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceMembers to fetch.
     */
    orderBy?: WorkspaceMemberOrderByWithRelationInput | WorkspaceMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkspaceMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkspaceMembers
    **/
    _count?: true | WorkspaceMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkspaceMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkspaceMemberMaxAggregateInputType
  }

  export type GetWorkspaceMemberAggregateType<T extends WorkspaceMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkspaceMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkspaceMember[P]>
      : GetScalarType<T[P], AggregateWorkspaceMember[P]>
  }




  export type WorkspaceMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceMemberWhereInput
    orderBy?: WorkspaceMemberOrderByWithAggregationInput | WorkspaceMemberOrderByWithAggregationInput[]
    by: WorkspaceMemberScalarFieldEnum[] | WorkspaceMemberScalarFieldEnum
    having?: WorkspaceMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkspaceMemberCountAggregateInputType | true
    _min?: WorkspaceMemberMinAggregateInputType
    _max?: WorkspaceMemberMaxAggregateInputType
  }

  export type WorkspaceMemberGroupByOutputType = {
    id: string
    workspaceId: string
    userId: string
    role: string
    joinedAt: Date
    invitedBy: string | null
    _count: WorkspaceMemberCountAggregateOutputType | null
    _min: WorkspaceMemberMinAggregateOutputType | null
    _max: WorkspaceMemberMaxAggregateOutputType | null
  }

  type GetWorkspaceMemberGroupByPayload<T extends WorkspaceMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkspaceMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkspaceMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkspaceMemberGroupByOutputType[P]>
            : GetScalarType<T[P], WorkspaceMemberGroupByOutputType[P]>
        }
      >
    >


  export type WorkspaceMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    invitedBy?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceMember"]>

  export type WorkspaceMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    invitedBy?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceMember"]>

  export type WorkspaceMemberSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    invitedBy?: boolean
  }

  export type WorkspaceMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WorkspaceMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WorkspaceMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkspaceMember"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      userId: string
      role: string
      joinedAt: Date
      invitedBy: string | null
    }, ExtArgs["result"]["workspaceMember"]>
    composites: {}
  }

  type WorkspaceMemberGetPayload<S extends boolean | null | undefined | WorkspaceMemberDefaultArgs> = $Result.GetResult<Prisma.$WorkspaceMemberPayload, S>

  type WorkspaceMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkspaceMemberFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkspaceMemberCountAggregateInputType | true
    }

  export interface WorkspaceMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkspaceMember'], meta: { name: 'WorkspaceMember' } }
    /**
     * Find zero or one WorkspaceMember that matches the filter.
     * @param {WorkspaceMemberFindUniqueArgs} args - Arguments to find a WorkspaceMember
     * @example
     * // Get one WorkspaceMember
     * const workspaceMember = await prisma.workspaceMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkspaceMemberFindUniqueArgs>(args: SelectSubset<T, WorkspaceMemberFindUniqueArgs<ExtArgs>>): Prisma__WorkspaceMemberClient<$Result.GetResult<Prisma.$WorkspaceMemberPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WorkspaceMember that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkspaceMemberFindUniqueOrThrowArgs} args - Arguments to find a WorkspaceMember
     * @example
     * // Get one WorkspaceMember
     * const workspaceMember = await prisma.workspaceMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkspaceMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkspaceMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkspaceMemberClient<$Result.GetResult<Prisma.$WorkspaceMemberPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WorkspaceMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceMemberFindFirstArgs} args - Arguments to find a WorkspaceMember
     * @example
     * // Get one WorkspaceMember
     * const workspaceMember = await prisma.workspaceMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkspaceMemberFindFirstArgs>(args?: SelectSubset<T, WorkspaceMemberFindFirstArgs<ExtArgs>>): Prisma__WorkspaceMemberClient<$Result.GetResult<Prisma.$WorkspaceMemberPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WorkspaceMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceMemberFindFirstOrThrowArgs} args - Arguments to find a WorkspaceMember
     * @example
     * // Get one WorkspaceMember
     * const workspaceMember = await prisma.workspaceMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkspaceMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkspaceMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkspaceMemberClient<$Result.GetResult<Prisma.$WorkspaceMemberPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WorkspaceMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkspaceMembers
     * const workspaceMembers = await prisma.workspaceMember.findMany()
     * 
     * // Get first 10 WorkspaceMembers
     * const workspaceMembers = await prisma.workspaceMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workspaceMemberWithIdOnly = await prisma.workspaceMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkspaceMemberFindManyArgs>(args?: SelectSubset<T, WorkspaceMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceMemberPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WorkspaceMember.
     * @param {WorkspaceMemberCreateArgs} args - Arguments to create a WorkspaceMember.
     * @example
     * // Create one WorkspaceMember
     * const WorkspaceMember = await prisma.workspaceMember.create({
     *   data: {
     *     // ... data to create a WorkspaceMember
     *   }
     * })
     * 
     */
    create<T extends WorkspaceMemberCreateArgs>(args: SelectSubset<T, WorkspaceMemberCreateArgs<ExtArgs>>): Prisma__WorkspaceMemberClient<$Result.GetResult<Prisma.$WorkspaceMemberPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WorkspaceMembers.
     * @param {WorkspaceMemberCreateManyArgs} args - Arguments to create many WorkspaceMembers.
     * @example
     * // Create many WorkspaceMembers
     * const workspaceMember = await prisma.workspaceMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkspaceMemberCreateManyArgs>(args?: SelectSubset<T, WorkspaceMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkspaceMembers and returns the data saved in the database.
     * @param {WorkspaceMemberCreateManyAndReturnArgs} args - Arguments to create many WorkspaceMembers.
     * @example
     * // Create many WorkspaceMembers
     * const workspaceMember = await prisma.workspaceMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkspaceMembers and only return the `id`
     * const workspaceMemberWithIdOnly = await prisma.workspaceMember.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkspaceMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkspaceMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceMemberPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WorkspaceMember.
     * @param {WorkspaceMemberDeleteArgs} args - Arguments to delete one WorkspaceMember.
     * @example
     * // Delete one WorkspaceMember
     * const WorkspaceMember = await prisma.workspaceMember.delete({
     *   where: {
     *     // ... filter to delete one WorkspaceMember
     *   }
     * })
     * 
     */
    delete<T extends WorkspaceMemberDeleteArgs>(args: SelectSubset<T, WorkspaceMemberDeleteArgs<ExtArgs>>): Prisma__WorkspaceMemberClient<$Result.GetResult<Prisma.$WorkspaceMemberPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WorkspaceMember.
     * @param {WorkspaceMemberUpdateArgs} args - Arguments to update one WorkspaceMember.
     * @example
     * // Update one WorkspaceMember
     * const workspaceMember = await prisma.workspaceMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkspaceMemberUpdateArgs>(args: SelectSubset<T, WorkspaceMemberUpdateArgs<ExtArgs>>): Prisma__WorkspaceMemberClient<$Result.GetResult<Prisma.$WorkspaceMemberPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WorkspaceMembers.
     * @param {WorkspaceMemberDeleteManyArgs} args - Arguments to filter WorkspaceMembers to delete.
     * @example
     * // Delete a few WorkspaceMembers
     * const { count } = await prisma.workspaceMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkspaceMemberDeleteManyArgs>(args?: SelectSubset<T, WorkspaceMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkspaceMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkspaceMembers
     * const workspaceMember = await prisma.workspaceMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkspaceMemberUpdateManyArgs>(args: SelectSubset<T, WorkspaceMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkspaceMember.
     * @param {WorkspaceMemberUpsertArgs} args - Arguments to update or create a WorkspaceMember.
     * @example
     * // Update or create a WorkspaceMember
     * const workspaceMember = await prisma.workspaceMember.upsert({
     *   create: {
     *     // ... data to create a WorkspaceMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkspaceMember we want to update
     *   }
     * })
     */
    upsert<T extends WorkspaceMemberUpsertArgs>(args: SelectSubset<T, WorkspaceMemberUpsertArgs<ExtArgs>>): Prisma__WorkspaceMemberClient<$Result.GetResult<Prisma.$WorkspaceMemberPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WorkspaceMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceMemberCountArgs} args - Arguments to filter WorkspaceMembers to count.
     * @example
     * // Count the number of WorkspaceMembers
     * const count = await prisma.workspaceMember.count({
     *   where: {
     *     // ... the filter for the WorkspaceMembers we want to count
     *   }
     * })
    **/
    count<T extends WorkspaceMemberCountArgs>(
      args?: Subset<T, WorkspaceMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkspaceMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkspaceMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkspaceMemberAggregateArgs>(args: Subset<T, WorkspaceMemberAggregateArgs>): Prisma.PrismaPromise<GetWorkspaceMemberAggregateType<T>>

    /**
     * Group by WorkspaceMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkspaceMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkspaceMemberGroupByArgs['orderBy'] }
        : { orderBy?: WorkspaceMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkspaceMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkspaceMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkspaceMember model
   */
  readonly fields: WorkspaceMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkspaceMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkspaceMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkspaceMember model
   */ 
  interface WorkspaceMemberFieldRefs {
    readonly id: FieldRef<"WorkspaceMember", 'String'>
    readonly workspaceId: FieldRef<"WorkspaceMember", 'String'>
    readonly userId: FieldRef<"WorkspaceMember", 'String'>
    readonly role: FieldRef<"WorkspaceMember", 'String'>
    readonly joinedAt: FieldRef<"WorkspaceMember", 'DateTime'>
    readonly invitedBy: FieldRef<"WorkspaceMember", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WorkspaceMember findUnique
   */
  export type WorkspaceMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceMember
     */
    select?: WorkspaceMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceMemberInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceMember to fetch.
     */
    where: WorkspaceMemberWhereUniqueInput
  }

  /**
   * WorkspaceMember findUniqueOrThrow
   */
  export type WorkspaceMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceMember
     */
    select?: WorkspaceMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceMemberInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceMember to fetch.
     */
    where: WorkspaceMemberWhereUniqueInput
  }

  /**
   * WorkspaceMember findFirst
   */
  export type WorkspaceMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceMember
     */
    select?: WorkspaceMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceMemberInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceMember to fetch.
     */
    where?: WorkspaceMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceMembers to fetch.
     */
    orderBy?: WorkspaceMemberOrderByWithRelationInput | WorkspaceMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkspaceMembers.
     */
    cursor?: WorkspaceMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkspaceMembers.
     */
    distinct?: WorkspaceMemberScalarFieldEnum | WorkspaceMemberScalarFieldEnum[]
  }

  /**
   * WorkspaceMember findFirstOrThrow
   */
  export type WorkspaceMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceMember
     */
    select?: WorkspaceMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceMemberInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceMember to fetch.
     */
    where?: WorkspaceMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceMembers to fetch.
     */
    orderBy?: WorkspaceMemberOrderByWithRelationInput | WorkspaceMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkspaceMembers.
     */
    cursor?: WorkspaceMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkspaceMembers.
     */
    distinct?: WorkspaceMemberScalarFieldEnum | WorkspaceMemberScalarFieldEnum[]
  }

  /**
   * WorkspaceMember findMany
   */
  export type WorkspaceMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceMember
     */
    select?: WorkspaceMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceMemberInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceMembers to fetch.
     */
    where?: WorkspaceMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceMembers to fetch.
     */
    orderBy?: WorkspaceMemberOrderByWithRelationInput | WorkspaceMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkspaceMembers.
     */
    cursor?: WorkspaceMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceMembers.
     */
    skip?: number
    distinct?: WorkspaceMemberScalarFieldEnum | WorkspaceMemberScalarFieldEnum[]
  }

  /**
   * WorkspaceMember create
   */
  export type WorkspaceMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceMember
     */
    select?: WorkspaceMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkspaceMember.
     */
    data: XOR<WorkspaceMemberCreateInput, WorkspaceMemberUncheckedCreateInput>
  }

  /**
   * WorkspaceMember createMany
   */
  export type WorkspaceMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkspaceMembers.
     */
    data: WorkspaceMemberCreateManyInput | WorkspaceMemberCreateManyInput[]
  }

  /**
   * WorkspaceMember createManyAndReturn
   */
  export type WorkspaceMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceMember
     */
    select?: WorkspaceMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WorkspaceMembers.
     */
    data: WorkspaceMemberCreateManyInput | WorkspaceMemberCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkspaceMember update
   */
  export type WorkspaceMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceMember
     */
    select?: WorkspaceMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkspaceMember.
     */
    data: XOR<WorkspaceMemberUpdateInput, WorkspaceMemberUncheckedUpdateInput>
    /**
     * Choose, which WorkspaceMember to update.
     */
    where: WorkspaceMemberWhereUniqueInput
  }

  /**
   * WorkspaceMember updateMany
   */
  export type WorkspaceMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkspaceMembers.
     */
    data: XOR<WorkspaceMemberUpdateManyMutationInput, WorkspaceMemberUncheckedUpdateManyInput>
    /**
     * Filter which WorkspaceMembers to update
     */
    where?: WorkspaceMemberWhereInput
  }

  /**
   * WorkspaceMember upsert
   */
  export type WorkspaceMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceMember
     */
    select?: WorkspaceMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkspaceMember to update in case it exists.
     */
    where: WorkspaceMemberWhereUniqueInput
    /**
     * In case the WorkspaceMember found by the `where` argument doesn't exist, create a new WorkspaceMember with this data.
     */
    create: XOR<WorkspaceMemberCreateInput, WorkspaceMemberUncheckedCreateInput>
    /**
     * In case the WorkspaceMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkspaceMemberUpdateInput, WorkspaceMemberUncheckedUpdateInput>
  }

  /**
   * WorkspaceMember delete
   */
  export type WorkspaceMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceMember
     */
    select?: WorkspaceMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceMemberInclude<ExtArgs> | null
    /**
     * Filter which WorkspaceMember to delete.
     */
    where: WorkspaceMemberWhereUniqueInput
  }

  /**
   * WorkspaceMember deleteMany
   */
  export type WorkspaceMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkspaceMembers to delete
     */
    where?: WorkspaceMemberWhereInput
  }

  /**
   * WorkspaceMember without action
   */
  export type WorkspaceMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceMember
     */
    select?: WorkspaceMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceMemberInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    initialBalance: number | null
    currentBalance: number | null
    creditLimit: number | null
    closingDay: number | null
    dueDay: number | null
  }

  export type AccountSumAggregateOutputType = {
    initialBalance: number | null
    currentBalance: number | null
    creditLimit: number | null
    closingDay: number | null
    dueDay: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    name: string | null
    type: string | null
    description: string | null
    bankName: string | null
    bankCode: string | null
    agency: string | null
    accountNumber: string | null
    initialBalance: number | null
    currentBalance: number | null
    creditLimit: number | null
    closingDay: number | null
    dueDay: number | null
    color: string | null
    icon: string | null
    isActive: boolean | null
    archivedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    name: string | null
    type: string | null
    description: string | null
    bankName: string | null
    bankCode: string | null
    agency: string | null
    accountNumber: string | null
    initialBalance: number | null
    currentBalance: number | null
    creditLimit: number | null
    closingDay: number | null
    dueDay: number | null
    color: string | null
    icon: string | null
    isActive: boolean | null
    archivedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    workspaceId: number
    name: number
    type: number
    description: number
    bankName: number
    bankCode: number
    agency: number
    accountNumber: number
    initialBalance: number
    currentBalance: number
    creditLimit: number
    closingDay: number
    dueDay: number
    color: number
    icon: number
    isActive: number
    archivedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    initialBalance?: true
    currentBalance?: true
    creditLimit?: true
    closingDay?: true
    dueDay?: true
  }

  export type AccountSumAggregateInputType = {
    initialBalance?: true
    currentBalance?: true
    creditLimit?: true
    closingDay?: true
    dueDay?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    type?: true
    description?: true
    bankName?: true
    bankCode?: true
    agency?: true
    accountNumber?: true
    initialBalance?: true
    currentBalance?: true
    creditLimit?: true
    closingDay?: true
    dueDay?: true
    color?: true
    icon?: true
    isActive?: true
    archivedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    type?: true
    description?: true
    bankName?: true
    bankCode?: true
    agency?: true
    accountNumber?: true
    initialBalance?: true
    currentBalance?: true
    creditLimit?: true
    closingDay?: true
    dueDay?: true
    color?: true
    icon?: true
    isActive?: true
    archivedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    type?: true
    description?: true
    bankName?: true
    bankCode?: true
    agency?: true
    accountNumber?: true
    initialBalance?: true
    currentBalance?: true
    creditLimit?: true
    closingDay?: true
    dueDay?: true
    color?: true
    icon?: true
    isActive?: true
    archivedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    workspaceId: string
    name: string
    type: string
    description: string | null
    bankName: string | null
    bankCode: string | null
    agency: string | null
    accountNumber: string | null
    initialBalance: number
    currentBalance: number
    creditLimit: number | null
    closingDay: number | null
    dueDay: number | null
    color: string
    icon: string
    isActive: boolean
    archivedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    bankName?: boolean
    bankCode?: boolean
    agency?: boolean
    accountNumber?: boolean
    initialBalance?: boolean
    currentBalance?: boolean
    creditLimit?: boolean
    closingDay?: boolean
    dueDay?: boolean
    color?: boolean
    icon?: boolean
    isActive?: boolean
    archivedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    transactions?: boolean | Account$transactionsArgs<ExtArgs>
    fromTransfers?: boolean | Account$fromTransfersArgs<ExtArgs>
    toTransfers?: boolean | Account$toTransfersArgs<ExtArgs>
    bankConnections?: boolean | Account$bankConnectionsArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    bankName?: boolean
    bankCode?: boolean
    agency?: boolean
    accountNumber?: boolean
    initialBalance?: boolean
    currentBalance?: boolean
    creditLimit?: boolean
    closingDay?: boolean
    dueDay?: boolean
    color?: boolean
    icon?: boolean
    isActive?: boolean
    archivedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    bankName?: boolean
    bankCode?: boolean
    agency?: boolean
    accountNumber?: boolean
    initialBalance?: boolean
    currentBalance?: boolean
    creditLimit?: boolean
    closingDay?: boolean
    dueDay?: boolean
    color?: boolean
    icon?: boolean
    isActive?: boolean
    archivedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    transactions?: boolean | Account$transactionsArgs<ExtArgs>
    fromTransfers?: boolean | Account$fromTransfersArgs<ExtArgs>
    toTransfers?: boolean | Account$toTransfersArgs<ExtArgs>
    bankConnections?: boolean | Account$bankConnectionsArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      fromTransfers: Prisma.$TransferPayload<ExtArgs>[]
      toTransfers: Prisma.$TransferPayload<ExtArgs>[]
      bankConnections: Prisma.$BankConnectionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      name: string
      type: string
      description: string | null
      bankName: string | null
      bankCode: string | null
      agency: string | null
      accountNumber: string | null
      initialBalance: number
      currentBalance: number
      creditLimit: number | null
      closingDay: number | null
      dueDay: number | null
      color: string
      icon: string
      isActive: boolean
      archivedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    transactions<T extends Account$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Account$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany"> | Null>
    fromTransfers<T extends Account$fromTransfersArgs<ExtArgs> = {}>(args?: Subset<T, Account$fromTransfersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findMany"> | Null>
    toTransfers<T extends Account$toTransfersArgs<ExtArgs> = {}>(args?: Subset<T, Account$toTransfersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findMany"> | Null>
    bankConnections<T extends Account$bankConnectionsArgs<ExtArgs> = {}>(args?: Subset<T, Account$bankConnectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankConnectionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */ 
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly workspaceId: FieldRef<"Account", 'String'>
    readonly name: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly description: FieldRef<"Account", 'String'>
    readonly bankName: FieldRef<"Account", 'String'>
    readonly bankCode: FieldRef<"Account", 'String'>
    readonly agency: FieldRef<"Account", 'String'>
    readonly accountNumber: FieldRef<"Account", 'String'>
    readonly initialBalance: FieldRef<"Account", 'Float'>
    readonly currentBalance: FieldRef<"Account", 'Float'>
    readonly creditLimit: FieldRef<"Account", 'Float'>
    readonly closingDay: FieldRef<"Account", 'Int'>
    readonly dueDay: FieldRef<"Account", 'Int'>
    readonly color: FieldRef<"Account", 'String'>
    readonly icon: FieldRef<"Account", 'String'>
    readonly isActive: FieldRef<"Account", 'Boolean'>
    readonly archivedAt: FieldRef<"Account", 'DateTime'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
  }

  /**
   * Account.transactions
   */
  export type Account$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Account.fromTransfers
   */
  export type Account$fromTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    where?: TransferWhereInput
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    cursor?: TransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Account.toTransfers
   */
  export type Account$toTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    where?: TransferWhereInput
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    cursor?: TransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Account.bankConnections
   */
  export type Account$bankConnectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankConnection
     */
    select?: BankConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankConnectionInclude<ExtArgs> | null
    where?: BankConnectionWhereInput
    orderBy?: BankConnectionOrderByWithRelationInput | BankConnectionOrderByWithRelationInput[]
    cursor?: BankConnectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BankConnectionScalarFieldEnum | BankConnectionScalarFieldEnum[]
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    parentId: string | null
    name: string | null
    type: string | null
    color: string | null
    icon: string | null
    description: string | null
    keywords: string | null
    isSystem: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    parentId: string | null
    name: string | null
    type: string | null
    color: string | null
    icon: string | null
    description: string | null
    keywords: string | null
    isSystem: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    workspaceId: number
    parentId: number
    name: number
    type: number
    color: number
    icon: number
    description: number
    keywords: number
    isSystem: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CategoryMinAggregateInputType = {
    id?: true
    workspaceId?: true
    parentId?: true
    name?: true
    type?: true
    color?: true
    icon?: true
    description?: true
    keywords?: true
    isSystem?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    parentId?: true
    name?: true
    type?: true
    color?: true
    icon?: true
    description?: true
    keywords?: true
    isSystem?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    workspaceId?: true
    parentId?: true
    name?: true
    type?: true
    color?: true
    icon?: true
    description?: true
    keywords?: true
    isSystem?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    workspaceId: string
    parentId: string | null
    name: string
    type: string
    color: string
    icon: string
    description: string | null
    keywords: string
    isSystem: boolean
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    parentId?: boolean
    name?: boolean
    type?: boolean
    color?: boolean
    icon?: boolean
    description?: boolean
    keywords?: boolean
    isSystem?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    parent?: boolean | Category$parentArgs<ExtArgs>
    children?: boolean | Category$childrenArgs<ExtArgs>
    transactions?: boolean | Category$transactionsArgs<ExtArgs>
    budgets?: boolean | Category$budgetsArgs<ExtArgs>
    envelopes?: boolean | Category$envelopesArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    parentId?: boolean
    name?: boolean
    type?: boolean
    color?: boolean
    icon?: boolean
    description?: boolean
    keywords?: boolean
    isSystem?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    parent?: boolean | Category$parentArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    workspaceId?: boolean
    parentId?: boolean
    name?: boolean
    type?: boolean
    color?: boolean
    icon?: boolean
    description?: boolean
    keywords?: boolean
    isSystem?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    parent?: boolean | Category$parentArgs<ExtArgs>
    children?: boolean | Category$childrenArgs<ExtArgs>
    transactions?: boolean | Category$transactionsArgs<ExtArgs>
    budgets?: boolean | Category$budgetsArgs<ExtArgs>
    envelopes?: boolean | Category$envelopesArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    parent?: boolean | Category$parentArgs<ExtArgs>
  }

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      parent: Prisma.$CategoryPayload<ExtArgs> | null
      children: Prisma.$CategoryPayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      budgets: Prisma.$BudgetCategoryPayload<ExtArgs>[]
      envelopes: Prisma.$EnvelopePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      parentId: string | null
      name: string
      type: string
      color: string
      icon: string
      description: string | null
      keywords: string
      isSystem: boolean
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    parent<T extends Category$parentArgs<ExtArgs> = {}>(args?: Subset<T, Category$parentArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    children<T extends Category$childrenArgs<ExtArgs> = {}>(args?: Subset<T, Category$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany"> | Null>
    transactions<T extends Category$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Category$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany"> | Null>
    budgets<T extends Category$budgetsArgs<ExtArgs> = {}>(args?: Subset<T, Category$budgetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetCategoryPayload<ExtArgs>, T, "findMany"> | Null>
    envelopes<T extends Category$envelopesArgs<ExtArgs> = {}>(args?: Subset<T, Category$envelopesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnvelopePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */ 
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly workspaceId: FieldRef<"Category", 'String'>
    readonly parentId: FieldRef<"Category", 'String'>
    readonly name: FieldRef<"Category", 'String'>
    readonly type: FieldRef<"Category", 'String'>
    readonly color: FieldRef<"Category", 'String'>
    readonly icon: FieldRef<"Category", 'String'>
    readonly description: FieldRef<"Category", 'String'>
    readonly keywords: FieldRef<"Category", 'String'>
    readonly isSystem: FieldRef<"Category", 'Boolean'>
    readonly isActive: FieldRef<"Category", 'Boolean'>
    readonly createdAt: FieldRef<"Category", 'DateTime'>
    readonly updatedAt: FieldRef<"Category", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
  }

  /**
   * Category.parent
   */
  export type Category$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * Category.children
   */
  export type Category$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    cursor?: CategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category.transactions
   */
  export type Category$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Category.budgets
   */
  export type Category$budgetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetCategory
     */
    select?: BudgetCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetCategoryInclude<ExtArgs> | null
    where?: BudgetCategoryWhereInput
    orderBy?: BudgetCategoryOrderByWithRelationInput | BudgetCategoryOrderByWithRelationInput[]
    cursor?: BudgetCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BudgetCategoryScalarFieldEnum | BudgetCategoryScalarFieldEnum[]
  }

  /**
   * Category.envelopes
   */
  export type Category$envelopesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Envelope
     */
    select?: EnvelopeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvelopeInclude<ExtArgs> | null
    where?: EnvelopeWhereInput
    orderBy?: EnvelopeOrderByWithRelationInput | EnvelopeOrderByWithRelationInput[]
    cursor?: EnvelopeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnvelopeScalarFieldEnum | EnvelopeScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    amount: number | null
    aiConfidence: number | null
  }

  export type TransactionSumAggregateOutputType = {
    amount: number | null
    aiConfidence: number | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    accountId: string | null
    categoryId: string | null
    creditCardId: string | null
    type: string | null
    description: string | null
    amount: number | null
    currency: string | null
    status: string | null
    transactionDate: Date | null
    confirmedAt: Date | null
    recurrenceId: string | null
    notes: string | null
    tags: string | null
    attachmentUrl: string | null
    location: string | null
    importId: string | null
    rawData: string | null
    aiConfidence: number | null
    aiCategory: string | null
    aiCategorizedAt: Date | null
    aiModelVersion: string | null
    autoRuleId: string | null
    bankConnectionId: string | null
    externalId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    accountId: string | null
    categoryId: string | null
    creditCardId: string | null
    type: string | null
    description: string | null
    amount: number | null
    currency: string | null
    status: string | null
    transactionDate: Date | null
    confirmedAt: Date | null
    recurrenceId: string | null
    notes: string | null
    tags: string | null
    attachmentUrl: string | null
    location: string | null
    importId: string | null
    rawData: string | null
    aiConfidence: number | null
    aiCategory: string | null
    aiCategorizedAt: Date | null
    aiModelVersion: string | null
    autoRuleId: string | null
    bankConnectionId: string | null
    externalId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    workspaceId: number
    accountId: number
    categoryId: number
    creditCardId: number
    type: number
    description: number
    amount: number
    currency: number
    status: number
    transactionDate: number
    confirmedAt: number
    recurrenceId: number
    notes: number
    tags: number
    attachmentUrl: number
    location: number
    importId: number
    rawData: number
    aiConfidence: number
    aiCategory: number
    aiCategorizedAt: number
    aiModelVersion: number
    autoRuleId: number
    bankConnectionId: number
    externalId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    amount?: true
    aiConfidence?: true
  }

  export type TransactionSumAggregateInputType = {
    amount?: true
    aiConfidence?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    workspaceId?: true
    accountId?: true
    categoryId?: true
    creditCardId?: true
    type?: true
    description?: true
    amount?: true
    currency?: true
    status?: true
    transactionDate?: true
    confirmedAt?: true
    recurrenceId?: true
    notes?: true
    tags?: true
    attachmentUrl?: true
    location?: true
    importId?: true
    rawData?: true
    aiConfidence?: true
    aiCategory?: true
    aiCategorizedAt?: true
    aiModelVersion?: true
    autoRuleId?: true
    bankConnectionId?: true
    externalId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    accountId?: true
    categoryId?: true
    creditCardId?: true
    type?: true
    description?: true
    amount?: true
    currency?: true
    status?: true
    transactionDate?: true
    confirmedAt?: true
    recurrenceId?: true
    notes?: true
    tags?: true
    attachmentUrl?: true
    location?: true
    importId?: true
    rawData?: true
    aiConfidence?: true
    aiCategory?: true
    aiCategorizedAt?: true
    aiModelVersion?: true
    autoRuleId?: true
    bankConnectionId?: true
    externalId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    workspaceId?: true
    accountId?: true
    categoryId?: true
    creditCardId?: true
    type?: true
    description?: true
    amount?: true
    currency?: true
    status?: true
    transactionDate?: true
    confirmedAt?: true
    recurrenceId?: true
    notes?: true
    tags?: true
    attachmentUrl?: true
    location?: true
    importId?: true
    rawData?: true
    aiConfidence?: true
    aiCategory?: true
    aiCategorizedAt?: true
    aiModelVersion?: true
    autoRuleId?: true
    bankConnectionId?: true
    externalId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: string
    workspaceId: string
    accountId: string
    categoryId: string | null
    creditCardId: string | null
    type: string
    description: string
    amount: number
    currency: string
    status: string
    transactionDate: Date
    confirmedAt: Date | null
    recurrenceId: string | null
    notes: string | null
    tags: string
    attachmentUrl: string | null
    location: string | null
    importId: string | null
    rawData: string | null
    aiConfidence: number | null
    aiCategory: string | null
    aiCategorizedAt: Date | null
    aiModelVersion: string | null
    autoRuleId: string | null
    bankConnectionId: string | null
    externalId: string | null
    createdAt: Date
    updatedAt: Date
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    accountId?: boolean
    categoryId?: boolean
    creditCardId?: boolean
    type?: boolean
    description?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    transactionDate?: boolean
    confirmedAt?: boolean
    recurrenceId?: boolean
    notes?: boolean
    tags?: boolean
    attachmentUrl?: boolean
    location?: boolean
    importId?: boolean
    rawData?: boolean
    aiConfidence?: boolean
    aiCategory?: boolean
    aiCategorizedAt?: boolean
    aiModelVersion?: boolean
    autoRuleId?: boolean
    bankConnectionId?: boolean
    externalId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
    category?: boolean | Transaction$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    accountId?: boolean
    categoryId?: boolean
    creditCardId?: boolean
    type?: boolean
    description?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    transactionDate?: boolean
    confirmedAt?: boolean
    recurrenceId?: boolean
    notes?: boolean
    tags?: boolean
    attachmentUrl?: boolean
    location?: boolean
    importId?: boolean
    rawData?: boolean
    aiConfidence?: boolean
    aiCategory?: boolean
    aiCategorizedAt?: boolean
    aiModelVersion?: boolean
    autoRuleId?: boolean
    bankConnectionId?: boolean
    externalId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
    category?: boolean | Transaction$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    accountId?: boolean
    categoryId?: boolean
    creditCardId?: boolean
    type?: boolean
    description?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    transactionDate?: boolean
    confirmedAt?: boolean
    recurrenceId?: boolean
    notes?: boolean
    tags?: boolean
    attachmentUrl?: boolean
    location?: boolean
    importId?: boolean
    rawData?: boolean
    aiConfidence?: boolean
    aiCategory?: boolean
    aiCategorizedAt?: boolean
    aiModelVersion?: boolean
    autoRuleId?: boolean
    bankConnectionId?: boolean
    externalId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
    category?: boolean | Transaction$categoryArgs<ExtArgs>
  }
  export type TransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
    category?: boolean | Transaction$categoryArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      account: Prisma.$AccountPayload<ExtArgs>
      category: Prisma.$CategoryPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      accountId: string
      categoryId: string | null
      creditCardId: string | null
      type: string
      description: string
      amount: number
      currency: string
      status: string
      transactionDate: Date
      confirmedAt: Date | null
      recurrenceId: string | null
      notes: string | null
      tags: string
      attachmentUrl: string | null
      location: string | null
      importId: string | null
      rawData: string | null
      aiConfidence: number | null
      aiCategory: string | null
      aiCategorizedAt: Date | null
      aiModelVersion: string | null
      autoRuleId: string | null
      bankConnectionId: string | null
      externalId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    category<T extends Transaction$categoryArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$categoryArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */ 
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'String'>
    readonly workspaceId: FieldRef<"Transaction", 'String'>
    readonly accountId: FieldRef<"Transaction", 'String'>
    readonly categoryId: FieldRef<"Transaction", 'String'>
    readonly creditCardId: FieldRef<"Transaction", 'String'>
    readonly type: FieldRef<"Transaction", 'String'>
    readonly description: FieldRef<"Transaction", 'String'>
    readonly amount: FieldRef<"Transaction", 'Float'>
    readonly currency: FieldRef<"Transaction", 'String'>
    readonly status: FieldRef<"Transaction", 'String'>
    readonly transactionDate: FieldRef<"Transaction", 'DateTime'>
    readonly confirmedAt: FieldRef<"Transaction", 'DateTime'>
    readonly recurrenceId: FieldRef<"Transaction", 'String'>
    readonly notes: FieldRef<"Transaction", 'String'>
    readonly tags: FieldRef<"Transaction", 'String'>
    readonly attachmentUrl: FieldRef<"Transaction", 'String'>
    readonly location: FieldRef<"Transaction", 'String'>
    readonly importId: FieldRef<"Transaction", 'String'>
    readonly rawData: FieldRef<"Transaction", 'String'>
    readonly aiConfidence: FieldRef<"Transaction", 'Float'>
    readonly aiCategory: FieldRef<"Transaction", 'String'>
    readonly aiCategorizedAt: FieldRef<"Transaction", 'DateTime'>
    readonly aiModelVersion: FieldRef<"Transaction", 'String'>
    readonly autoRuleId: FieldRef<"Transaction", 'String'>
    readonly bankConnectionId: FieldRef<"Transaction", 'String'>
    readonly externalId: FieldRef<"Transaction", 'String'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
    readonly updatedAt: FieldRef<"Transaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
  }

  /**
   * Transaction createManyAndReturn
   */
  export type TransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
  }

  /**
   * Transaction.category
   */
  export type Transaction$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model Recurrence
   */

  export type AggregateRecurrence = {
    _count: RecurrenceCountAggregateOutputType | null
    _avg: RecurrenceAvgAggregateOutputType | null
    _sum: RecurrenceSumAggregateOutputType | null
    _min: RecurrenceMinAggregateOutputType | null
    _max: RecurrenceMaxAggregateOutputType | null
  }

  export type RecurrenceAvgAggregateOutputType = {
    amount: number | null
    notifyBefore: number | null
  }

  export type RecurrenceSumAggregateOutputType = {
    amount: number | null
    notifyBefore: number | null
  }

  export type RecurrenceMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    accountId: string | null
    categoryId: string | null
    type: string | null
    description: string | null
    amount: number | null
    frequency: string | null
    startDate: Date | null
    endDate: Date | null
    nextOccurrence: Date | null
    isActive: boolean | null
    autoConfirm: boolean | null
    notifyBefore: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RecurrenceMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    accountId: string | null
    categoryId: string | null
    type: string | null
    description: string | null
    amount: number | null
    frequency: string | null
    startDate: Date | null
    endDate: Date | null
    nextOccurrence: Date | null
    isActive: boolean | null
    autoConfirm: boolean | null
    notifyBefore: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RecurrenceCountAggregateOutputType = {
    id: number
    workspaceId: number
    accountId: number
    categoryId: number
    type: number
    description: number
    amount: number
    frequency: number
    startDate: number
    endDate: number
    nextOccurrence: number
    isActive: number
    autoConfirm: number
    notifyBefore: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RecurrenceAvgAggregateInputType = {
    amount?: true
    notifyBefore?: true
  }

  export type RecurrenceSumAggregateInputType = {
    amount?: true
    notifyBefore?: true
  }

  export type RecurrenceMinAggregateInputType = {
    id?: true
    workspaceId?: true
    accountId?: true
    categoryId?: true
    type?: true
    description?: true
    amount?: true
    frequency?: true
    startDate?: true
    endDate?: true
    nextOccurrence?: true
    isActive?: true
    autoConfirm?: true
    notifyBefore?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RecurrenceMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    accountId?: true
    categoryId?: true
    type?: true
    description?: true
    amount?: true
    frequency?: true
    startDate?: true
    endDate?: true
    nextOccurrence?: true
    isActive?: true
    autoConfirm?: true
    notifyBefore?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RecurrenceCountAggregateInputType = {
    id?: true
    workspaceId?: true
    accountId?: true
    categoryId?: true
    type?: true
    description?: true
    amount?: true
    frequency?: true
    startDate?: true
    endDate?: true
    nextOccurrence?: true
    isActive?: true
    autoConfirm?: true
    notifyBefore?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RecurrenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Recurrence to aggregate.
     */
    where?: RecurrenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recurrences to fetch.
     */
    orderBy?: RecurrenceOrderByWithRelationInput | RecurrenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecurrenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recurrences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recurrences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Recurrences
    **/
    _count?: true | RecurrenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecurrenceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecurrenceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecurrenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecurrenceMaxAggregateInputType
  }

  export type GetRecurrenceAggregateType<T extends RecurrenceAggregateArgs> = {
        [P in keyof T & keyof AggregateRecurrence]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecurrence[P]>
      : GetScalarType<T[P], AggregateRecurrence[P]>
  }




  export type RecurrenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecurrenceWhereInput
    orderBy?: RecurrenceOrderByWithAggregationInput | RecurrenceOrderByWithAggregationInput[]
    by: RecurrenceScalarFieldEnum[] | RecurrenceScalarFieldEnum
    having?: RecurrenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecurrenceCountAggregateInputType | true
    _avg?: RecurrenceAvgAggregateInputType
    _sum?: RecurrenceSumAggregateInputType
    _min?: RecurrenceMinAggregateInputType
    _max?: RecurrenceMaxAggregateInputType
  }

  export type RecurrenceGroupByOutputType = {
    id: string
    workspaceId: string
    accountId: string
    categoryId: string | null
    type: string
    description: string
    amount: number
    frequency: string
    startDate: Date
    endDate: Date | null
    nextOccurrence: Date
    isActive: boolean
    autoConfirm: boolean
    notifyBefore: number
    createdAt: Date
    updatedAt: Date
    _count: RecurrenceCountAggregateOutputType | null
    _avg: RecurrenceAvgAggregateOutputType | null
    _sum: RecurrenceSumAggregateOutputType | null
    _min: RecurrenceMinAggregateOutputType | null
    _max: RecurrenceMaxAggregateOutputType | null
  }

  type GetRecurrenceGroupByPayload<T extends RecurrenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecurrenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecurrenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecurrenceGroupByOutputType[P]>
            : GetScalarType<T[P], RecurrenceGroupByOutputType[P]>
        }
      >
    >


  export type RecurrenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    accountId?: boolean
    categoryId?: boolean
    type?: boolean
    description?: boolean
    amount?: boolean
    frequency?: boolean
    startDate?: boolean
    endDate?: boolean
    nextOccurrence?: boolean
    isActive?: boolean
    autoConfirm?: boolean
    notifyBefore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["recurrence"]>

  export type RecurrenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    accountId?: boolean
    categoryId?: boolean
    type?: boolean
    description?: boolean
    amount?: boolean
    frequency?: boolean
    startDate?: boolean
    endDate?: boolean
    nextOccurrence?: boolean
    isActive?: boolean
    autoConfirm?: boolean
    notifyBefore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["recurrence"]>

  export type RecurrenceSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    accountId?: boolean
    categoryId?: boolean
    type?: boolean
    description?: boolean
    amount?: boolean
    frequency?: boolean
    startDate?: boolean
    endDate?: boolean
    nextOccurrence?: boolean
    isActive?: boolean
    autoConfirm?: boolean
    notifyBefore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $RecurrencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Recurrence"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      accountId: string
      categoryId: string | null
      type: string
      description: string
      amount: number
      frequency: string
      startDate: Date
      endDate: Date | null
      nextOccurrence: Date
      isActive: boolean
      autoConfirm: boolean
      notifyBefore: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["recurrence"]>
    composites: {}
  }

  type RecurrenceGetPayload<S extends boolean | null | undefined | RecurrenceDefaultArgs> = $Result.GetResult<Prisma.$RecurrencePayload, S>

  type RecurrenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RecurrenceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RecurrenceCountAggregateInputType | true
    }

  export interface RecurrenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Recurrence'], meta: { name: 'Recurrence' } }
    /**
     * Find zero or one Recurrence that matches the filter.
     * @param {RecurrenceFindUniqueArgs} args - Arguments to find a Recurrence
     * @example
     * // Get one Recurrence
     * const recurrence = await prisma.recurrence.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecurrenceFindUniqueArgs>(args: SelectSubset<T, RecurrenceFindUniqueArgs<ExtArgs>>): Prisma__RecurrenceClient<$Result.GetResult<Prisma.$RecurrencePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Recurrence that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RecurrenceFindUniqueOrThrowArgs} args - Arguments to find a Recurrence
     * @example
     * // Get one Recurrence
     * const recurrence = await prisma.recurrence.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecurrenceFindUniqueOrThrowArgs>(args: SelectSubset<T, RecurrenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecurrenceClient<$Result.GetResult<Prisma.$RecurrencePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Recurrence that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurrenceFindFirstArgs} args - Arguments to find a Recurrence
     * @example
     * // Get one Recurrence
     * const recurrence = await prisma.recurrence.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecurrenceFindFirstArgs>(args?: SelectSubset<T, RecurrenceFindFirstArgs<ExtArgs>>): Prisma__RecurrenceClient<$Result.GetResult<Prisma.$RecurrencePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Recurrence that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurrenceFindFirstOrThrowArgs} args - Arguments to find a Recurrence
     * @example
     * // Get one Recurrence
     * const recurrence = await prisma.recurrence.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecurrenceFindFirstOrThrowArgs>(args?: SelectSubset<T, RecurrenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecurrenceClient<$Result.GetResult<Prisma.$RecurrencePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Recurrences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurrenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Recurrences
     * const recurrences = await prisma.recurrence.findMany()
     * 
     * // Get first 10 Recurrences
     * const recurrences = await prisma.recurrence.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recurrenceWithIdOnly = await prisma.recurrence.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecurrenceFindManyArgs>(args?: SelectSubset<T, RecurrenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurrencePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Recurrence.
     * @param {RecurrenceCreateArgs} args - Arguments to create a Recurrence.
     * @example
     * // Create one Recurrence
     * const Recurrence = await prisma.recurrence.create({
     *   data: {
     *     // ... data to create a Recurrence
     *   }
     * })
     * 
     */
    create<T extends RecurrenceCreateArgs>(args: SelectSubset<T, RecurrenceCreateArgs<ExtArgs>>): Prisma__RecurrenceClient<$Result.GetResult<Prisma.$RecurrencePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Recurrences.
     * @param {RecurrenceCreateManyArgs} args - Arguments to create many Recurrences.
     * @example
     * // Create many Recurrences
     * const recurrence = await prisma.recurrence.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecurrenceCreateManyArgs>(args?: SelectSubset<T, RecurrenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Recurrences and returns the data saved in the database.
     * @param {RecurrenceCreateManyAndReturnArgs} args - Arguments to create many Recurrences.
     * @example
     * // Create many Recurrences
     * const recurrence = await prisma.recurrence.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Recurrences and only return the `id`
     * const recurrenceWithIdOnly = await prisma.recurrence.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RecurrenceCreateManyAndReturnArgs>(args?: SelectSubset<T, RecurrenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurrencePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Recurrence.
     * @param {RecurrenceDeleteArgs} args - Arguments to delete one Recurrence.
     * @example
     * // Delete one Recurrence
     * const Recurrence = await prisma.recurrence.delete({
     *   where: {
     *     // ... filter to delete one Recurrence
     *   }
     * })
     * 
     */
    delete<T extends RecurrenceDeleteArgs>(args: SelectSubset<T, RecurrenceDeleteArgs<ExtArgs>>): Prisma__RecurrenceClient<$Result.GetResult<Prisma.$RecurrencePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Recurrence.
     * @param {RecurrenceUpdateArgs} args - Arguments to update one Recurrence.
     * @example
     * // Update one Recurrence
     * const recurrence = await prisma.recurrence.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecurrenceUpdateArgs>(args: SelectSubset<T, RecurrenceUpdateArgs<ExtArgs>>): Prisma__RecurrenceClient<$Result.GetResult<Prisma.$RecurrencePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Recurrences.
     * @param {RecurrenceDeleteManyArgs} args - Arguments to filter Recurrences to delete.
     * @example
     * // Delete a few Recurrences
     * const { count } = await prisma.recurrence.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecurrenceDeleteManyArgs>(args?: SelectSubset<T, RecurrenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Recurrences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurrenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Recurrences
     * const recurrence = await prisma.recurrence.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecurrenceUpdateManyArgs>(args: SelectSubset<T, RecurrenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Recurrence.
     * @param {RecurrenceUpsertArgs} args - Arguments to update or create a Recurrence.
     * @example
     * // Update or create a Recurrence
     * const recurrence = await prisma.recurrence.upsert({
     *   create: {
     *     // ... data to create a Recurrence
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Recurrence we want to update
     *   }
     * })
     */
    upsert<T extends RecurrenceUpsertArgs>(args: SelectSubset<T, RecurrenceUpsertArgs<ExtArgs>>): Prisma__RecurrenceClient<$Result.GetResult<Prisma.$RecurrencePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Recurrences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurrenceCountArgs} args - Arguments to filter Recurrences to count.
     * @example
     * // Count the number of Recurrences
     * const count = await prisma.recurrence.count({
     *   where: {
     *     // ... the filter for the Recurrences we want to count
     *   }
     * })
    **/
    count<T extends RecurrenceCountArgs>(
      args?: Subset<T, RecurrenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecurrenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Recurrence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurrenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecurrenceAggregateArgs>(args: Subset<T, RecurrenceAggregateArgs>): Prisma.PrismaPromise<GetRecurrenceAggregateType<T>>

    /**
     * Group by Recurrence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurrenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecurrenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecurrenceGroupByArgs['orderBy'] }
        : { orderBy?: RecurrenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecurrenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecurrenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Recurrence model
   */
  readonly fields: RecurrenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Recurrence.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecurrenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Recurrence model
   */ 
  interface RecurrenceFieldRefs {
    readonly id: FieldRef<"Recurrence", 'String'>
    readonly workspaceId: FieldRef<"Recurrence", 'String'>
    readonly accountId: FieldRef<"Recurrence", 'String'>
    readonly categoryId: FieldRef<"Recurrence", 'String'>
    readonly type: FieldRef<"Recurrence", 'String'>
    readonly description: FieldRef<"Recurrence", 'String'>
    readonly amount: FieldRef<"Recurrence", 'Float'>
    readonly frequency: FieldRef<"Recurrence", 'String'>
    readonly startDate: FieldRef<"Recurrence", 'DateTime'>
    readonly endDate: FieldRef<"Recurrence", 'DateTime'>
    readonly nextOccurrence: FieldRef<"Recurrence", 'DateTime'>
    readonly isActive: FieldRef<"Recurrence", 'Boolean'>
    readonly autoConfirm: FieldRef<"Recurrence", 'Boolean'>
    readonly notifyBefore: FieldRef<"Recurrence", 'Int'>
    readonly createdAt: FieldRef<"Recurrence", 'DateTime'>
    readonly updatedAt: FieldRef<"Recurrence", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Recurrence findUnique
   */
  export type RecurrenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recurrence
     */
    select?: RecurrenceSelect<ExtArgs> | null
    /**
     * Filter, which Recurrence to fetch.
     */
    where: RecurrenceWhereUniqueInput
  }

  /**
   * Recurrence findUniqueOrThrow
   */
  export type RecurrenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recurrence
     */
    select?: RecurrenceSelect<ExtArgs> | null
    /**
     * Filter, which Recurrence to fetch.
     */
    where: RecurrenceWhereUniqueInput
  }

  /**
   * Recurrence findFirst
   */
  export type RecurrenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recurrence
     */
    select?: RecurrenceSelect<ExtArgs> | null
    /**
     * Filter, which Recurrence to fetch.
     */
    where?: RecurrenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recurrences to fetch.
     */
    orderBy?: RecurrenceOrderByWithRelationInput | RecurrenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recurrences.
     */
    cursor?: RecurrenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recurrences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recurrences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recurrences.
     */
    distinct?: RecurrenceScalarFieldEnum | RecurrenceScalarFieldEnum[]
  }

  /**
   * Recurrence findFirstOrThrow
   */
  export type RecurrenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recurrence
     */
    select?: RecurrenceSelect<ExtArgs> | null
    /**
     * Filter, which Recurrence to fetch.
     */
    where?: RecurrenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recurrences to fetch.
     */
    orderBy?: RecurrenceOrderByWithRelationInput | RecurrenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recurrences.
     */
    cursor?: RecurrenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recurrences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recurrences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recurrences.
     */
    distinct?: RecurrenceScalarFieldEnum | RecurrenceScalarFieldEnum[]
  }

  /**
   * Recurrence findMany
   */
  export type RecurrenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recurrence
     */
    select?: RecurrenceSelect<ExtArgs> | null
    /**
     * Filter, which Recurrences to fetch.
     */
    where?: RecurrenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recurrences to fetch.
     */
    orderBy?: RecurrenceOrderByWithRelationInput | RecurrenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Recurrences.
     */
    cursor?: RecurrenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recurrences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recurrences.
     */
    skip?: number
    distinct?: RecurrenceScalarFieldEnum | RecurrenceScalarFieldEnum[]
  }

  /**
   * Recurrence create
   */
  export type RecurrenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recurrence
     */
    select?: RecurrenceSelect<ExtArgs> | null
    /**
     * The data needed to create a Recurrence.
     */
    data: XOR<RecurrenceCreateInput, RecurrenceUncheckedCreateInput>
  }

  /**
   * Recurrence createMany
   */
  export type RecurrenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Recurrences.
     */
    data: RecurrenceCreateManyInput | RecurrenceCreateManyInput[]
  }

  /**
   * Recurrence createManyAndReturn
   */
  export type RecurrenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recurrence
     */
    select?: RecurrenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Recurrences.
     */
    data: RecurrenceCreateManyInput | RecurrenceCreateManyInput[]
  }

  /**
   * Recurrence update
   */
  export type RecurrenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recurrence
     */
    select?: RecurrenceSelect<ExtArgs> | null
    /**
     * The data needed to update a Recurrence.
     */
    data: XOR<RecurrenceUpdateInput, RecurrenceUncheckedUpdateInput>
    /**
     * Choose, which Recurrence to update.
     */
    where: RecurrenceWhereUniqueInput
  }

  /**
   * Recurrence updateMany
   */
  export type RecurrenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Recurrences.
     */
    data: XOR<RecurrenceUpdateManyMutationInput, RecurrenceUncheckedUpdateManyInput>
    /**
     * Filter which Recurrences to update
     */
    where?: RecurrenceWhereInput
  }

  /**
   * Recurrence upsert
   */
  export type RecurrenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recurrence
     */
    select?: RecurrenceSelect<ExtArgs> | null
    /**
     * The filter to search for the Recurrence to update in case it exists.
     */
    where: RecurrenceWhereUniqueInput
    /**
     * In case the Recurrence found by the `where` argument doesn't exist, create a new Recurrence with this data.
     */
    create: XOR<RecurrenceCreateInput, RecurrenceUncheckedCreateInput>
    /**
     * In case the Recurrence was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecurrenceUpdateInput, RecurrenceUncheckedUpdateInput>
  }

  /**
   * Recurrence delete
   */
  export type RecurrenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recurrence
     */
    select?: RecurrenceSelect<ExtArgs> | null
    /**
     * Filter which Recurrence to delete.
     */
    where: RecurrenceWhereUniqueInput
  }

  /**
   * Recurrence deleteMany
   */
  export type RecurrenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Recurrences to delete
     */
    where?: RecurrenceWhereInput
  }

  /**
   * Recurrence without action
   */
  export type RecurrenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recurrence
     */
    select?: RecurrenceSelect<ExtArgs> | null
  }


  /**
   * Model Transfer
   */

  export type AggregateTransfer = {
    _count: TransferCountAggregateOutputType | null
    _avg: TransferAvgAggregateOutputType | null
    _sum: TransferSumAggregateOutputType | null
    _min: TransferMinAggregateOutputType | null
    _max: TransferMaxAggregateOutputType | null
  }

  export type TransferAvgAggregateOutputType = {
    amount: number | null
    fee: number | null
  }

  export type TransferSumAggregateOutputType = {
    amount: number | null
    fee: number | null
  }

  export type TransferMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    fromAccountId: string | null
    toAccountId: string | null
    description: string | null
    amount: number | null
    fee: number | null
    transferDate: Date | null
    createdAt: Date | null
  }

  export type TransferMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    fromAccountId: string | null
    toAccountId: string | null
    description: string | null
    amount: number | null
    fee: number | null
    transferDate: Date | null
    createdAt: Date | null
  }

  export type TransferCountAggregateOutputType = {
    id: number
    workspaceId: number
    fromAccountId: number
    toAccountId: number
    description: number
    amount: number
    fee: number
    transferDate: number
    createdAt: number
    _all: number
  }


  export type TransferAvgAggregateInputType = {
    amount?: true
    fee?: true
  }

  export type TransferSumAggregateInputType = {
    amount?: true
    fee?: true
  }

  export type TransferMinAggregateInputType = {
    id?: true
    workspaceId?: true
    fromAccountId?: true
    toAccountId?: true
    description?: true
    amount?: true
    fee?: true
    transferDate?: true
    createdAt?: true
  }

  export type TransferMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    fromAccountId?: true
    toAccountId?: true
    description?: true
    amount?: true
    fee?: true
    transferDate?: true
    createdAt?: true
  }

  export type TransferCountAggregateInputType = {
    id?: true
    workspaceId?: true
    fromAccountId?: true
    toAccountId?: true
    description?: true
    amount?: true
    fee?: true
    transferDate?: true
    createdAt?: true
    _all?: true
  }

  export type TransferAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transfer to aggregate.
     */
    where?: TransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transfers to fetch.
     */
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transfers
    **/
    _count?: true | TransferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransferAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransferSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransferMaxAggregateInputType
  }

  export type GetTransferAggregateType<T extends TransferAggregateArgs> = {
        [P in keyof T & keyof AggregateTransfer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransfer[P]>
      : GetScalarType<T[P], AggregateTransfer[P]>
  }




  export type TransferGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferWhereInput
    orderBy?: TransferOrderByWithAggregationInput | TransferOrderByWithAggregationInput[]
    by: TransferScalarFieldEnum[] | TransferScalarFieldEnum
    having?: TransferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransferCountAggregateInputType | true
    _avg?: TransferAvgAggregateInputType
    _sum?: TransferSumAggregateInputType
    _min?: TransferMinAggregateInputType
    _max?: TransferMaxAggregateInputType
  }

  export type TransferGroupByOutputType = {
    id: string
    workspaceId: string
    fromAccountId: string
    toAccountId: string
    description: string
    amount: number
    fee: number | null
    transferDate: Date
    createdAt: Date
    _count: TransferCountAggregateOutputType | null
    _avg: TransferAvgAggregateOutputType | null
    _sum: TransferSumAggregateOutputType | null
    _min: TransferMinAggregateOutputType | null
    _max: TransferMaxAggregateOutputType | null
  }

  type GetTransferGroupByPayload<T extends TransferGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransferGroupByOutputType[P]>
            : GetScalarType<T[P], TransferGroupByOutputType[P]>
        }
      >
    >


  export type TransferSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    fromAccountId?: boolean
    toAccountId?: boolean
    description?: boolean
    amount?: boolean
    fee?: boolean
    transferDate?: boolean
    createdAt?: boolean
    fromAccount?: boolean | AccountDefaultArgs<ExtArgs>
    toAccount?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transfer"]>

  export type TransferSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    fromAccountId?: boolean
    toAccountId?: boolean
    description?: boolean
    amount?: boolean
    fee?: boolean
    transferDate?: boolean
    createdAt?: boolean
    fromAccount?: boolean | AccountDefaultArgs<ExtArgs>
    toAccount?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transfer"]>

  export type TransferSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    fromAccountId?: boolean
    toAccountId?: boolean
    description?: boolean
    amount?: boolean
    fee?: boolean
    transferDate?: boolean
    createdAt?: boolean
  }

  export type TransferInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromAccount?: boolean | AccountDefaultArgs<ExtArgs>
    toAccount?: boolean | AccountDefaultArgs<ExtArgs>
  }
  export type TransferIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromAccount?: boolean | AccountDefaultArgs<ExtArgs>
    toAccount?: boolean | AccountDefaultArgs<ExtArgs>
  }

  export type $TransferPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transfer"
    objects: {
      fromAccount: Prisma.$AccountPayload<ExtArgs>
      toAccount: Prisma.$AccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      fromAccountId: string
      toAccountId: string
      description: string
      amount: number
      fee: number | null
      transferDate: Date
      createdAt: Date
    }, ExtArgs["result"]["transfer"]>
    composites: {}
  }

  type TransferGetPayload<S extends boolean | null | undefined | TransferDefaultArgs> = $Result.GetResult<Prisma.$TransferPayload, S>

  type TransferCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TransferFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TransferCountAggregateInputType | true
    }

  export interface TransferDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transfer'], meta: { name: 'Transfer' } }
    /**
     * Find zero or one Transfer that matches the filter.
     * @param {TransferFindUniqueArgs} args - Arguments to find a Transfer
     * @example
     * // Get one Transfer
     * const transfer = await prisma.transfer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransferFindUniqueArgs>(args: SelectSubset<T, TransferFindUniqueArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Transfer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TransferFindUniqueOrThrowArgs} args - Arguments to find a Transfer
     * @example
     * // Get one Transfer
     * const transfer = await prisma.transfer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransferFindUniqueOrThrowArgs>(args: SelectSubset<T, TransferFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Transfer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferFindFirstArgs} args - Arguments to find a Transfer
     * @example
     * // Get one Transfer
     * const transfer = await prisma.transfer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransferFindFirstArgs>(args?: SelectSubset<T, TransferFindFirstArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Transfer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferFindFirstOrThrowArgs} args - Arguments to find a Transfer
     * @example
     * // Get one Transfer
     * const transfer = await prisma.transfer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransferFindFirstOrThrowArgs>(args?: SelectSubset<T, TransferFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Transfers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transfers
     * const transfers = await prisma.transfer.findMany()
     * 
     * // Get first 10 Transfers
     * const transfers = await prisma.transfer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transferWithIdOnly = await prisma.transfer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransferFindManyArgs>(args?: SelectSubset<T, TransferFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Transfer.
     * @param {TransferCreateArgs} args - Arguments to create a Transfer.
     * @example
     * // Create one Transfer
     * const Transfer = await prisma.transfer.create({
     *   data: {
     *     // ... data to create a Transfer
     *   }
     * })
     * 
     */
    create<T extends TransferCreateArgs>(args: SelectSubset<T, TransferCreateArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Transfers.
     * @param {TransferCreateManyArgs} args - Arguments to create many Transfers.
     * @example
     * // Create many Transfers
     * const transfer = await prisma.transfer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransferCreateManyArgs>(args?: SelectSubset<T, TransferCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transfers and returns the data saved in the database.
     * @param {TransferCreateManyAndReturnArgs} args - Arguments to create many Transfers.
     * @example
     * // Create many Transfers
     * const transfer = await prisma.transfer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transfers and only return the `id`
     * const transferWithIdOnly = await prisma.transfer.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransferCreateManyAndReturnArgs>(args?: SelectSubset<T, TransferCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Transfer.
     * @param {TransferDeleteArgs} args - Arguments to delete one Transfer.
     * @example
     * // Delete one Transfer
     * const Transfer = await prisma.transfer.delete({
     *   where: {
     *     // ... filter to delete one Transfer
     *   }
     * })
     * 
     */
    delete<T extends TransferDeleteArgs>(args: SelectSubset<T, TransferDeleteArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Transfer.
     * @param {TransferUpdateArgs} args - Arguments to update one Transfer.
     * @example
     * // Update one Transfer
     * const transfer = await prisma.transfer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransferUpdateArgs>(args: SelectSubset<T, TransferUpdateArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Transfers.
     * @param {TransferDeleteManyArgs} args - Arguments to filter Transfers to delete.
     * @example
     * // Delete a few Transfers
     * const { count } = await prisma.transfer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransferDeleteManyArgs>(args?: SelectSubset<T, TransferDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transfers
     * const transfer = await prisma.transfer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransferUpdateManyArgs>(args: SelectSubset<T, TransferUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Transfer.
     * @param {TransferUpsertArgs} args - Arguments to update or create a Transfer.
     * @example
     * // Update or create a Transfer
     * const transfer = await prisma.transfer.upsert({
     *   create: {
     *     // ... data to create a Transfer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transfer we want to update
     *   }
     * })
     */
    upsert<T extends TransferUpsertArgs>(args: SelectSubset<T, TransferUpsertArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Transfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferCountArgs} args - Arguments to filter Transfers to count.
     * @example
     * // Count the number of Transfers
     * const count = await prisma.transfer.count({
     *   where: {
     *     // ... the filter for the Transfers we want to count
     *   }
     * })
    **/
    count<T extends TransferCountArgs>(
      args?: Subset<T, TransferCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransferAggregateArgs>(args: Subset<T, TransferAggregateArgs>): Prisma.PrismaPromise<GetTransferAggregateType<T>>

    /**
     * Group by Transfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransferGroupByArgs['orderBy'] }
        : { orderBy?: TransferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransferGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transfer model
   */
  readonly fields: TransferFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transfer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransferClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fromAccount<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    toAccount<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transfer model
   */ 
  interface TransferFieldRefs {
    readonly id: FieldRef<"Transfer", 'String'>
    readonly workspaceId: FieldRef<"Transfer", 'String'>
    readonly fromAccountId: FieldRef<"Transfer", 'String'>
    readonly toAccountId: FieldRef<"Transfer", 'String'>
    readonly description: FieldRef<"Transfer", 'String'>
    readonly amount: FieldRef<"Transfer", 'Float'>
    readonly fee: FieldRef<"Transfer", 'Float'>
    readonly transferDate: FieldRef<"Transfer", 'DateTime'>
    readonly createdAt: FieldRef<"Transfer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transfer findUnique
   */
  export type TransferFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfer to fetch.
     */
    where: TransferWhereUniqueInput
  }

  /**
   * Transfer findUniqueOrThrow
   */
  export type TransferFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfer to fetch.
     */
    where: TransferWhereUniqueInput
  }

  /**
   * Transfer findFirst
   */
  export type TransferFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfer to fetch.
     */
    where?: TransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transfers to fetch.
     */
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transfers.
     */
    cursor?: TransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transfers.
     */
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Transfer findFirstOrThrow
   */
  export type TransferFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfer to fetch.
     */
    where?: TransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transfers to fetch.
     */
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transfers.
     */
    cursor?: TransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transfers.
     */
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Transfer findMany
   */
  export type TransferFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfers to fetch.
     */
    where?: TransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transfers to fetch.
     */
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transfers.
     */
    cursor?: TransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transfers.
     */
    skip?: number
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Transfer create
   */
  export type TransferCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * The data needed to create a Transfer.
     */
    data: XOR<TransferCreateInput, TransferUncheckedCreateInput>
  }

  /**
   * Transfer createMany
   */
  export type TransferCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transfers.
     */
    data: TransferCreateManyInput | TransferCreateManyInput[]
  }

  /**
   * Transfer createManyAndReturn
   */
  export type TransferCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Transfers.
     */
    data: TransferCreateManyInput | TransferCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transfer update
   */
  export type TransferUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * The data needed to update a Transfer.
     */
    data: XOR<TransferUpdateInput, TransferUncheckedUpdateInput>
    /**
     * Choose, which Transfer to update.
     */
    where: TransferWhereUniqueInput
  }

  /**
   * Transfer updateMany
   */
  export type TransferUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transfers.
     */
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyInput>
    /**
     * Filter which Transfers to update
     */
    where?: TransferWhereInput
  }

  /**
   * Transfer upsert
   */
  export type TransferUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * The filter to search for the Transfer to update in case it exists.
     */
    where: TransferWhereUniqueInput
    /**
     * In case the Transfer found by the `where` argument doesn't exist, create a new Transfer with this data.
     */
    create: XOR<TransferCreateInput, TransferUncheckedCreateInput>
    /**
     * In case the Transfer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransferUpdateInput, TransferUncheckedUpdateInput>
  }

  /**
   * Transfer delete
   */
  export type TransferDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter which Transfer to delete.
     */
    where: TransferWhereUniqueInput
  }

  /**
   * Transfer deleteMany
   */
  export type TransferDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transfers to delete
     */
    where?: TransferWhereInput
  }

  /**
   * Transfer without action
   */
  export type TransferDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
  }


  /**
   * Model Budget
   */

  export type AggregateBudget = {
    _count: BudgetCountAggregateOutputType | null
    _avg: BudgetAvgAggregateOutputType | null
    _sum: BudgetSumAggregateOutputType | null
    _min: BudgetMinAggregateOutputType | null
    _max: BudgetMaxAggregateOutputType | null
  }

  export type BudgetAvgAggregateOutputType = {
    totalBudgeted: number | null
    totalSpent: number | null
    alertThreshold: number | null
  }

  export type BudgetSumAggregateOutputType = {
    totalBudgeted: number | null
    totalSpent: number | null
    alertThreshold: number | null
  }

  export type BudgetMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    name: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    totalBudgeted: number | null
    totalSpent: number | null
    isActive: boolean | null
    alertThreshold: number | null
    alertSent: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BudgetMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    name: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    totalBudgeted: number | null
    totalSpent: number | null
    isActive: boolean | null
    alertThreshold: number | null
    alertSent: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BudgetCountAggregateOutputType = {
    id: number
    workspaceId: number
    name: number
    description: number
    startDate: number
    endDate: number
    totalBudgeted: number
    totalSpent: number
    isActive: number
    alertThreshold: number
    alertSent: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BudgetAvgAggregateInputType = {
    totalBudgeted?: true
    totalSpent?: true
    alertThreshold?: true
  }

  export type BudgetSumAggregateInputType = {
    totalBudgeted?: true
    totalSpent?: true
    alertThreshold?: true
  }

  export type BudgetMinAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    description?: true
    startDate?: true
    endDate?: true
    totalBudgeted?: true
    totalSpent?: true
    isActive?: true
    alertThreshold?: true
    alertSent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BudgetMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    description?: true
    startDate?: true
    endDate?: true
    totalBudgeted?: true
    totalSpent?: true
    isActive?: true
    alertThreshold?: true
    alertSent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BudgetCountAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    description?: true
    startDate?: true
    endDate?: true
    totalBudgeted?: true
    totalSpent?: true
    isActive?: true
    alertThreshold?: true
    alertSent?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BudgetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Budget to aggregate.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Budgets
    **/
    _count?: true | BudgetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BudgetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BudgetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BudgetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BudgetMaxAggregateInputType
  }

  export type GetBudgetAggregateType<T extends BudgetAggregateArgs> = {
        [P in keyof T & keyof AggregateBudget]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBudget[P]>
      : GetScalarType<T[P], AggregateBudget[P]>
  }




  export type BudgetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetWhereInput
    orderBy?: BudgetOrderByWithAggregationInput | BudgetOrderByWithAggregationInput[]
    by: BudgetScalarFieldEnum[] | BudgetScalarFieldEnum
    having?: BudgetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BudgetCountAggregateInputType | true
    _avg?: BudgetAvgAggregateInputType
    _sum?: BudgetSumAggregateInputType
    _min?: BudgetMinAggregateInputType
    _max?: BudgetMaxAggregateInputType
  }

  export type BudgetGroupByOutputType = {
    id: string
    workspaceId: string
    name: string
    description: string | null
    startDate: Date
    endDate: Date
    totalBudgeted: number
    totalSpent: number
    isActive: boolean
    alertThreshold: number
    alertSent: boolean
    createdAt: Date
    updatedAt: Date
    _count: BudgetCountAggregateOutputType | null
    _avg: BudgetAvgAggregateOutputType | null
    _sum: BudgetSumAggregateOutputType | null
    _min: BudgetMinAggregateOutputType | null
    _max: BudgetMaxAggregateOutputType | null
  }

  type GetBudgetGroupByPayload<T extends BudgetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BudgetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BudgetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BudgetGroupByOutputType[P]>
            : GetScalarType<T[P], BudgetGroupByOutputType[P]>
        }
      >
    >


  export type BudgetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    totalBudgeted?: boolean
    totalSpent?: boolean
    isActive?: boolean
    alertThreshold?: boolean
    alertSent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    categories?: boolean | Budget$categoriesArgs<ExtArgs>
    Workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    _count?: boolean | BudgetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budget"]>

  export type BudgetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    totalBudgeted?: boolean
    totalSpent?: boolean
    isActive?: boolean
    alertThreshold?: boolean
    alertSent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budget"]>

  export type BudgetSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    totalBudgeted?: boolean
    totalSpent?: boolean
    isActive?: boolean
    alertThreshold?: boolean
    alertSent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BudgetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | Budget$categoriesArgs<ExtArgs>
    Workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    _count?: boolean | BudgetCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BudgetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $BudgetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Budget"
    objects: {
      categories: Prisma.$BudgetCategoryPayload<ExtArgs>[]
      Workspace: Prisma.$WorkspacePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      name: string
      description: string | null
      startDate: Date
      endDate: Date
      totalBudgeted: number
      totalSpent: number
      isActive: boolean
      alertThreshold: number
      alertSent: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["budget"]>
    composites: {}
  }

  type BudgetGetPayload<S extends boolean | null | undefined | BudgetDefaultArgs> = $Result.GetResult<Prisma.$BudgetPayload, S>

  type BudgetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BudgetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BudgetCountAggregateInputType | true
    }

  export interface BudgetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Budget'], meta: { name: 'Budget' } }
    /**
     * Find zero or one Budget that matches the filter.
     * @param {BudgetFindUniqueArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BudgetFindUniqueArgs>(args: SelectSubset<T, BudgetFindUniqueArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Budget that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BudgetFindUniqueOrThrowArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BudgetFindUniqueOrThrowArgs>(args: SelectSubset<T, BudgetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Budget that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetFindFirstArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BudgetFindFirstArgs>(args?: SelectSubset<T, BudgetFindFirstArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Budget that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetFindFirstOrThrowArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BudgetFindFirstOrThrowArgs>(args?: SelectSubset<T, BudgetFindFirstOrThrowArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Budgets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Budgets
     * const budgets = await prisma.budget.findMany()
     * 
     * // Get first 10 Budgets
     * const budgets = await prisma.budget.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const budgetWithIdOnly = await prisma.budget.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BudgetFindManyArgs>(args?: SelectSubset<T, BudgetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Budget.
     * @param {BudgetCreateArgs} args - Arguments to create a Budget.
     * @example
     * // Create one Budget
     * const Budget = await prisma.budget.create({
     *   data: {
     *     // ... data to create a Budget
     *   }
     * })
     * 
     */
    create<T extends BudgetCreateArgs>(args: SelectSubset<T, BudgetCreateArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Budgets.
     * @param {BudgetCreateManyArgs} args - Arguments to create many Budgets.
     * @example
     * // Create many Budgets
     * const budget = await prisma.budget.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BudgetCreateManyArgs>(args?: SelectSubset<T, BudgetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Budgets and returns the data saved in the database.
     * @param {BudgetCreateManyAndReturnArgs} args - Arguments to create many Budgets.
     * @example
     * // Create many Budgets
     * const budget = await prisma.budget.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Budgets and only return the `id`
     * const budgetWithIdOnly = await prisma.budget.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BudgetCreateManyAndReturnArgs>(args?: SelectSubset<T, BudgetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Budget.
     * @param {BudgetDeleteArgs} args - Arguments to delete one Budget.
     * @example
     * // Delete one Budget
     * const Budget = await prisma.budget.delete({
     *   where: {
     *     // ... filter to delete one Budget
     *   }
     * })
     * 
     */
    delete<T extends BudgetDeleteArgs>(args: SelectSubset<T, BudgetDeleteArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Budget.
     * @param {BudgetUpdateArgs} args - Arguments to update one Budget.
     * @example
     * // Update one Budget
     * const budget = await prisma.budget.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BudgetUpdateArgs>(args: SelectSubset<T, BudgetUpdateArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Budgets.
     * @param {BudgetDeleteManyArgs} args - Arguments to filter Budgets to delete.
     * @example
     * // Delete a few Budgets
     * const { count } = await prisma.budget.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BudgetDeleteManyArgs>(args?: SelectSubset<T, BudgetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Budgets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Budgets
     * const budget = await prisma.budget.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BudgetUpdateManyArgs>(args: SelectSubset<T, BudgetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Budget.
     * @param {BudgetUpsertArgs} args - Arguments to update or create a Budget.
     * @example
     * // Update or create a Budget
     * const budget = await prisma.budget.upsert({
     *   create: {
     *     // ... data to create a Budget
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Budget we want to update
     *   }
     * })
     */
    upsert<T extends BudgetUpsertArgs>(args: SelectSubset<T, BudgetUpsertArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Budgets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetCountArgs} args - Arguments to filter Budgets to count.
     * @example
     * // Count the number of Budgets
     * const count = await prisma.budget.count({
     *   where: {
     *     // ... the filter for the Budgets we want to count
     *   }
     * })
    **/
    count<T extends BudgetCountArgs>(
      args?: Subset<T, BudgetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BudgetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Budget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BudgetAggregateArgs>(args: Subset<T, BudgetAggregateArgs>): Prisma.PrismaPromise<GetBudgetAggregateType<T>>

    /**
     * Group by Budget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BudgetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BudgetGroupByArgs['orderBy'] }
        : { orderBy?: BudgetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BudgetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBudgetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Budget model
   */
  readonly fields: BudgetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Budget.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BudgetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    categories<T extends Budget$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, Budget$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetCategoryPayload<ExtArgs>, T, "findMany"> | Null>
    Workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Budget model
   */ 
  interface BudgetFieldRefs {
    readonly id: FieldRef<"Budget", 'String'>
    readonly workspaceId: FieldRef<"Budget", 'String'>
    readonly name: FieldRef<"Budget", 'String'>
    readonly description: FieldRef<"Budget", 'String'>
    readonly startDate: FieldRef<"Budget", 'DateTime'>
    readonly endDate: FieldRef<"Budget", 'DateTime'>
    readonly totalBudgeted: FieldRef<"Budget", 'Float'>
    readonly totalSpent: FieldRef<"Budget", 'Float'>
    readonly isActive: FieldRef<"Budget", 'Boolean'>
    readonly alertThreshold: FieldRef<"Budget", 'Int'>
    readonly alertSent: FieldRef<"Budget", 'Boolean'>
    readonly createdAt: FieldRef<"Budget", 'DateTime'>
    readonly updatedAt: FieldRef<"Budget", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Budget findUnique
   */
  export type BudgetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget findUniqueOrThrow
   */
  export type BudgetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget findFirst
   */
  export type BudgetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Budgets.
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Budgets.
     */
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * Budget findFirstOrThrow
   */
  export type BudgetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Budgets.
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Budgets.
     */
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * Budget findMany
   */
  export type BudgetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budgets to fetch.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Budgets.
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * Budget create
   */
  export type BudgetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * The data needed to create a Budget.
     */
    data: XOR<BudgetCreateInput, BudgetUncheckedCreateInput>
  }

  /**
   * Budget createMany
   */
  export type BudgetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Budgets.
     */
    data: BudgetCreateManyInput | BudgetCreateManyInput[]
  }

  /**
   * Budget createManyAndReturn
   */
  export type BudgetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Budgets.
     */
    data: BudgetCreateManyInput | BudgetCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Budget update
   */
  export type BudgetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * The data needed to update a Budget.
     */
    data: XOR<BudgetUpdateInput, BudgetUncheckedUpdateInput>
    /**
     * Choose, which Budget to update.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget updateMany
   */
  export type BudgetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Budgets.
     */
    data: XOR<BudgetUpdateManyMutationInput, BudgetUncheckedUpdateManyInput>
    /**
     * Filter which Budgets to update
     */
    where?: BudgetWhereInput
  }

  /**
   * Budget upsert
   */
  export type BudgetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * The filter to search for the Budget to update in case it exists.
     */
    where: BudgetWhereUniqueInput
    /**
     * In case the Budget found by the `where` argument doesn't exist, create a new Budget with this data.
     */
    create: XOR<BudgetCreateInput, BudgetUncheckedCreateInput>
    /**
     * In case the Budget was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BudgetUpdateInput, BudgetUncheckedUpdateInput>
  }

  /**
   * Budget delete
   */
  export type BudgetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter which Budget to delete.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget deleteMany
   */
  export type BudgetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Budgets to delete
     */
    where?: BudgetWhereInput
  }

  /**
   * Budget.categories
   */
  export type Budget$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetCategory
     */
    select?: BudgetCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetCategoryInclude<ExtArgs> | null
    where?: BudgetCategoryWhereInput
    orderBy?: BudgetCategoryOrderByWithRelationInput | BudgetCategoryOrderByWithRelationInput[]
    cursor?: BudgetCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BudgetCategoryScalarFieldEnum | BudgetCategoryScalarFieldEnum[]
  }

  /**
   * Budget without action
   */
  export type BudgetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
  }


  /**
   * Model BudgetCategory
   */

  export type AggregateBudgetCategory = {
    _count: BudgetCategoryCountAggregateOutputType | null
    _avg: BudgetCategoryAvgAggregateOutputType | null
    _sum: BudgetCategorySumAggregateOutputType | null
    _min: BudgetCategoryMinAggregateOutputType | null
    _max: BudgetCategoryMaxAggregateOutputType | null
  }

  export type BudgetCategoryAvgAggregateOutputType = {
    budgeted: number | null
    spent: number | null
  }

  export type BudgetCategorySumAggregateOutputType = {
    budgeted: number | null
    spent: number | null
  }

  export type BudgetCategoryMinAggregateOutputType = {
    id: string | null
    budgetId: string | null
    categoryId: string | null
    budgeted: number | null
    spent: number | null
  }

  export type BudgetCategoryMaxAggregateOutputType = {
    id: string | null
    budgetId: string | null
    categoryId: string | null
    budgeted: number | null
    spent: number | null
  }

  export type BudgetCategoryCountAggregateOutputType = {
    id: number
    budgetId: number
    categoryId: number
    budgeted: number
    spent: number
    _all: number
  }


  export type BudgetCategoryAvgAggregateInputType = {
    budgeted?: true
    spent?: true
  }

  export type BudgetCategorySumAggregateInputType = {
    budgeted?: true
    spent?: true
  }

  export type BudgetCategoryMinAggregateInputType = {
    id?: true
    budgetId?: true
    categoryId?: true
    budgeted?: true
    spent?: true
  }

  export type BudgetCategoryMaxAggregateInputType = {
    id?: true
    budgetId?: true
    categoryId?: true
    budgeted?: true
    spent?: true
  }

  export type BudgetCategoryCountAggregateInputType = {
    id?: true
    budgetId?: true
    categoryId?: true
    budgeted?: true
    spent?: true
    _all?: true
  }

  export type BudgetCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BudgetCategory to aggregate.
     */
    where?: BudgetCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudgetCategories to fetch.
     */
    orderBy?: BudgetCategoryOrderByWithRelationInput | BudgetCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BudgetCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudgetCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudgetCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BudgetCategories
    **/
    _count?: true | BudgetCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BudgetCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BudgetCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BudgetCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BudgetCategoryMaxAggregateInputType
  }

  export type GetBudgetCategoryAggregateType<T extends BudgetCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateBudgetCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBudgetCategory[P]>
      : GetScalarType<T[P], AggregateBudgetCategory[P]>
  }




  export type BudgetCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetCategoryWhereInput
    orderBy?: BudgetCategoryOrderByWithAggregationInput | BudgetCategoryOrderByWithAggregationInput[]
    by: BudgetCategoryScalarFieldEnum[] | BudgetCategoryScalarFieldEnum
    having?: BudgetCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BudgetCategoryCountAggregateInputType | true
    _avg?: BudgetCategoryAvgAggregateInputType
    _sum?: BudgetCategorySumAggregateInputType
    _min?: BudgetCategoryMinAggregateInputType
    _max?: BudgetCategoryMaxAggregateInputType
  }

  export type BudgetCategoryGroupByOutputType = {
    id: string
    budgetId: string
    categoryId: string
    budgeted: number
    spent: number
    _count: BudgetCategoryCountAggregateOutputType | null
    _avg: BudgetCategoryAvgAggregateOutputType | null
    _sum: BudgetCategorySumAggregateOutputType | null
    _min: BudgetCategoryMinAggregateOutputType | null
    _max: BudgetCategoryMaxAggregateOutputType | null
  }

  type GetBudgetCategoryGroupByPayload<T extends BudgetCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BudgetCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BudgetCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BudgetCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], BudgetCategoryGroupByOutputType[P]>
        }
      >
    >


  export type BudgetCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    budgetId?: boolean
    categoryId?: boolean
    budgeted?: boolean
    spent?: boolean
    budget?: boolean | BudgetDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budgetCategory"]>

  export type BudgetCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    budgetId?: boolean
    categoryId?: boolean
    budgeted?: boolean
    spent?: boolean
    budget?: boolean | BudgetDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budgetCategory"]>

  export type BudgetCategorySelectScalar = {
    id?: boolean
    budgetId?: boolean
    categoryId?: boolean
    budgeted?: boolean
    spent?: boolean
  }

  export type BudgetCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    budget?: boolean | BudgetDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }
  export type BudgetCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    budget?: boolean | BudgetDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }

  export type $BudgetCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BudgetCategory"
    objects: {
      budget: Prisma.$BudgetPayload<ExtArgs>
      category: Prisma.$CategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      budgetId: string
      categoryId: string
      budgeted: number
      spent: number
    }, ExtArgs["result"]["budgetCategory"]>
    composites: {}
  }

  type BudgetCategoryGetPayload<S extends boolean | null | undefined | BudgetCategoryDefaultArgs> = $Result.GetResult<Prisma.$BudgetCategoryPayload, S>

  type BudgetCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BudgetCategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BudgetCategoryCountAggregateInputType | true
    }

  export interface BudgetCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BudgetCategory'], meta: { name: 'BudgetCategory' } }
    /**
     * Find zero or one BudgetCategory that matches the filter.
     * @param {BudgetCategoryFindUniqueArgs} args - Arguments to find a BudgetCategory
     * @example
     * // Get one BudgetCategory
     * const budgetCategory = await prisma.budgetCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BudgetCategoryFindUniqueArgs>(args: SelectSubset<T, BudgetCategoryFindUniqueArgs<ExtArgs>>): Prisma__BudgetCategoryClient<$Result.GetResult<Prisma.$BudgetCategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BudgetCategory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BudgetCategoryFindUniqueOrThrowArgs} args - Arguments to find a BudgetCategory
     * @example
     * // Get one BudgetCategory
     * const budgetCategory = await prisma.budgetCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BudgetCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, BudgetCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BudgetCategoryClient<$Result.GetResult<Prisma.$BudgetCategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BudgetCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetCategoryFindFirstArgs} args - Arguments to find a BudgetCategory
     * @example
     * // Get one BudgetCategory
     * const budgetCategory = await prisma.budgetCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BudgetCategoryFindFirstArgs>(args?: SelectSubset<T, BudgetCategoryFindFirstArgs<ExtArgs>>): Prisma__BudgetCategoryClient<$Result.GetResult<Prisma.$BudgetCategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BudgetCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetCategoryFindFirstOrThrowArgs} args - Arguments to find a BudgetCategory
     * @example
     * // Get one BudgetCategory
     * const budgetCategory = await prisma.budgetCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BudgetCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, BudgetCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__BudgetCategoryClient<$Result.GetResult<Prisma.$BudgetCategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BudgetCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BudgetCategories
     * const budgetCategories = await prisma.budgetCategory.findMany()
     * 
     * // Get first 10 BudgetCategories
     * const budgetCategories = await prisma.budgetCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const budgetCategoryWithIdOnly = await prisma.budgetCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BudgetCategoryFindManyArgs>(args?: SelectSubset<T, BudgetCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetCategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BudgetCategory.
     * @param {BudgetCategoryCreateArgs} args - Arguments to create a BudgetCategory.
     * @example
     * // Create one BudgetCategory
     * const BudgetCategory = await prisma.budgetCategory.create({
     *   data: {
     *     // ... data to create a BudgetCategory
     *   }
     * })
     * 
     */
    create<T extends BudgetCategoryCreateArgs>(args: SelectSubset<T, BudgetCategoryCreateArgs<ExtArgs>>): Prisma__BudgetCategoryClient<$Result.GetResult<Prisma.$BudgetCategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BudgetCategories.
     * @param {BudgetCategoryCreateManyArgs} args - Arguments to create many BudgetCategories.
     * @example
     * // Create many BudgetCategories
     * const budgetCategory = await prisma.budgetCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BudgetCategoryCreateManyArgs>(args?: SelectSubset<T, BudgetCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BudgetCategories and returns the data saved in the database.
     * @param {BudgetCategoryCreateManyAndReturnArgs} args - Arguments to create many BudgetCategories.
     * @example
     * // Create many BudgetCategories
     * const budgetCategory = await prisma.budgetCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BudgetCategories and only return the `id`
     * const budgetCategoryWithIdOnly = await prisma.budgetCategory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BudgetCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, BudgetCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetCategoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BudgetCategory.
     * @param {BudgetCategoryDeleteArgs} args - Arguments to delete one BudgetCategory.
     * @example
     * // Delete one BudgetCategory
     * const BudgetCategory = await prisma.budgetCategory.delete({
     *   where: {
     *     // ... filter to delete one BudgetCategory
     *   }
     * })
     * 
     */
    delete<T extends BudgetCategoryDeleteArgs>(args: SelectSubset<T, BudgetCategoryDeleteArgs<ExtArgs>>): Prisma__BudgetCategoryClient<$Result.GetResult<Prisma.$BudgetCategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BudgetCategory.
     * @param {BudgetCategoryUpdateArgs} args - Arguments to update one BudgetCategory.
     * @example
     * // Update one BudgetCategory
     * const budgetCategory = await prisma.budgetCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BudgetCategoryUpdateArgs>(args: SelectSubset<T, BudgetCategoryUpdateArgs<ExtArgs>>): Prisma__BudgetCategoryClient<$Result.GetResult<Prisma.$BudgetCategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BudgetCategories.
     * @param {BudgetCategoryDeleteManyArgs} args - Arguments to filter BudgetCategories to delete.
     * @example
     * // Delete a few BudgetCategories
     * const { count } = await prisma.budgetCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BudgetCategoryDeleteManyArgs>(args?: SelectSubset<T, BudgetCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BudgetCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BudgetCategories
     * const budgetCategory = await prisma.budgetCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BudgetCategoryUpdateManyArgs>(args: SelectSubset<T, BudgetCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BudgetCategory.
     * @param {BudgetCategoryUpsertArgs} args - Arguments to update or create a BudgetCategory.
     * @example
     * // Update or create a BudgetCategory
     * const budgetCategory = await prisma.budgetCategory.upsert({
     *   create: {
     *     // ... data to create a BudgetCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BudgetCategory we want to update
     *   }
     * })
     */
    upsert<T extends BudgetCategoryUpsertArgs>(args: SelectSubset<T, BudgetCategoryUpsertArgs<ExtArgs>>): Prisma__BudgetCategoryClient<$Result.GetResult<Prisma.$BudgetCategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BudgetCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetCategoryCountArgs} args - Arguments to filter BudgetCategories to count.
     * @example
     * // Count the number of BudgetCategories
     * const count = await prisma.budgetCategory.count({
     *   where: {
     *     // ... the filter for the BudgetCategories we want to count
     *   }
     * })
    **/
    count<T extends BudgetCategoryCountArgs>(
      args?: Subset<T, BudgetCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BudgetCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BudgetCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BudgetCategoryAggregateArgs>(args: Subset<T, BudgetCategoryAggregateArgs>): Prisma.PrismaPromise<GetBudgetCategoryAggregateType<T>>

    /**
     * Group by BudgetCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BudgetCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BudgetCategoryGroupByArgs['orderBy'] }
        : { orderBy?: BudgetCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BudgetCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBudgetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BudgetCategory model
   */
  readonly fields: BudgetCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BudgetCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BudgetCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    budget<T extends BudgetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BudgetDefaultArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BudgetCategory model
   */ 
  interface BudgetCategoryFieldRefs {
    readonly id: FieldRef<"BudgetCategory", 'String'>
    readonly budgetId: FieldRef<"BudgetCategory", 'String'>
    readonly categoryId: FieldRef<"BudgetCategory", 'String'>
    readonly budgeted: FieldRef<"BudgetCategory", 'Float'>
    readonly spent: FieldRef<"BudgetCategory", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * BudgetCategory findUnique
   */
  export type BudgetCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetCategory
     */
    select?: BudgetCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetCategoryInclude<ExtArgs> | null
    /**
     * Filter, which BudgetCategory to fetch.
     */
    where: BudgetCategoryWhereUniqueInput
  }

  /**
   * BudgetCategory findUniqueOrThrow
   */
  export type BudgetCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetCategory
     */
    select?: BudgetCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetCategoryInclude<ExtArgs> | null
    /**
     * Filter, which BudgetCategory to fetch.
     */
    where: BudgetCategoryWhereUniqueInput
  }

  /**
   * BudgetCategory findFirst
   */
  export type BudgetCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetCategory
     */
    select?: BudgetCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetCategoryInclude<ExtArgs> | null
    /**
     * Filter, which BudgetCategory to fetch.
     */
    where?: BudgetCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudgetCategories to fetch.
     */
    orderBy?: BudgetCategoryOrderByWithRelationInput | BudgetCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BudgetCategories.
     */
    cursor?: BudgetCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudgetCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudgetCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BudgetCategories.
     */
    distinct?: BudgetCategoryScalarFieldEnum | BudgetCategoryScalarFieldEnum[]
  }

  /**
   * BudgetCategory findFirstOrThrow
   */
  export type BudgetCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetCategory
     */
    select?: BudgetCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetCategoryInclude<ExtArgs> | null
    /**
     * Filter, which BudgetCategory to fetch.
     */
    where?: BudgetCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudgetCategories to fetch.
     */
    orderBy?: BudgetCategoryOrderByWithRelationInput | BudgetCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BudgetCategories.
     */
    cursor?: BudgetCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudgetCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudgetCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BudgetCategories.
     */
    distinct?: BudgetCategoryScalarFieldEnum | BudgetCategoryScalarFieldEnum[]
  }

  /**
   * BudgetCategory findMany
   */
  export type BudgetCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetCategory
     */
    select?: BudgetCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetCategoryInclude<ExtArgs> | null
    /**
     * Filter, which BudgetCategories to fetch.
     */
    where?: BudgetCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudgetCategories to fetch.
     */
    orderBy?: BudgetCategoryOrderByWithRelationInput | BudgetCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BudgetCategories.
     */
    cursor?: BudgetCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudgetCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudgetCategories.
     */
    skip?: number
    distinct?: BudgetCategoryScalarFieldEnum | BudgetCategoryScalarFieldEnum[]
  }

  /**
   * BudgetCategory create
   */
  export type BudgetCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetCategory
     */
    select?: BudgetCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a BudgetCategory.
     */
    data: XOR<BudgetCategoryCreateInput, BudgetCategoryUncheckedCreateInput>
  }

  /**
   * BudgetCategory createMany
   */
  export type BudgetCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BudgetCategories.
     */
    data: BudgetCategoryCreateManyInput | BudgetCategoryCreateManyInput[]
  }

  /**
   * BudgetCategory createManyAndReturn
   */
  export type BudgetCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetCategory
     */
    select?: BudgetCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BudgetCategories.
     */
    data: BudgetCategoryCreateManyInput | BudgetCategoryCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetCategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BudgetCategory update
   */
  export type BudgetCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetCategory
     */
    select?: BudgetCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a BudgetCategory.
     */
    data: XOR<BudgetCategoryUpdateInput, BudgetCategoryUncheckedUpdateInput>
    /**
     * Choose, which BudgetCategory to update.
     */
    where: BudgetCategoryWhereUniqueInput
  }

  /**
   * BudgetCategory updateMany
   */
  export type BudgetCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BudgetCategories.
     */
    data: XOR<BudgetCategoryUpdateManyMutationInput, BudgetCategoryUncheckedUpdateManyInput>
    /**
     * Filter which BudgetCategories to update
     */
    where?: BudgetCategoryWhereInput
  }

  /**
   * BudgetCategory upsert
   */
  export type BudgetCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetCategory
     */
    select?: BudgetCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the BudgetCategory to update in case it exists.
     */
    where: BudgetCategoryWhereUniqueInput
    /**
     * In case the BudgetCategory found by the `where` argument doesn't exist, create a new BudgetCategory with this data.
     */
    create: XOR<BudgetCategoryCreateInput, BudgetCategoryUncheckedCreateInput>
    /**
     * In case the BudgetCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BudgetCategoryUpdateInput, BudgetCategoryUncheckedUpdateInput>
  }

  /**
   * BudgetCategory delete
   */
  export type BudgetCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetCategory
     */
    select?: BudgetCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetCategoryInclude<ExtArgs> | null
    /**
     * Filter which BudgetCategory to delete.
     */
    where: BudgetCategoryWhereUniqueInput
  }

  /**
   * BudgetCategory deleteMany
   */
  export type BudgetCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BudgetCategories to delete
     */
    where?: BudgetCategoryWhereInput
  }

  /**
   * BudgetCategory without action
   */
  export type BudgetCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetCategory
     */
    select?: BudgetCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Goal
   */

  export type AggregateGoal = {
    _count: GoalCountAggregateOutputType | null
    _avg: GoalAvgAggregateOutputType | null
    _sum: GoalSumAggregateOutputType | null
    _min: GoalMinAggregateOutputType | null
    _max: GoalMaxAggregateOutputType | null
  }

  export type GoalAvgAggregateOutputType = {
    targetAmount: number | null
    currentAmount: number | null
    allocationPercentage: number | null
  }

  export type GoalSumAggregateOutputType = {
    targetAmount: number | null
    currentAmount: number | null
    allocationPercentage: number | null
  }

  export type GoalMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    name: string | null
    description: string | null
    type: string | null
    targetAmount: number | null
    currentAmount: number | null
    startDate: Date | null
    targetDate: Date | null
    completedAt: Date | null
    status: string | null
    icon: string | null
    color: string | null
    autoAllocate: boolean | null
    allocationPercentage: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GoalMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    name: string | null
    description: string | null
    type: string | null
    targetAmount: number | null
    currentAmount: number | null
    startDate: Date | null
    targetDate: Date | null
    completedAt: Date | null
    status: string | null
    icon: string | null
    color: string | null
    autoAllocate: boolean | null
    allocationPercentage: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GoalCountAggregateOutputType = {
    id: number
    workspaceId: number
    name: number
    description: number
    type: number
    targetAmount: number
    currentAmount: number
    startDate: number
    targetDate: number
    completedAt: number
    status: number
    icon: number
    color: number
    autoAllocate: number
    allocationPercentage: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GoalAvgAggregateInputType = {
    targetAmount?: true
    currentAmount?: true
    allocationPercentage?: true
  }

  export type GoalSumAggregateInputType = {
    targetAmount?: true
    currentAmount?: true
    allocationPercentage?: true
  }

  export type GoalMinAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    description?: true
    type?: true
    targetAmount?: true
    currentAmount?: true
    startDate?: true
    targetDate?: true
    completedAt?: true
    status?: true
    icon?: true
    color?: true
    autoAllocate?: true
    allocationPercentage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GoalMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    description?: true
    type?: true
    targetAmount?: true
    currentAmount?: true
    startDate?: true
    targetDate?: true
    completedAt?: true
    status?: true
    icon?: true
    color?: true
    autoAllocate?: true
    allocationPercentage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GoalCountAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    description?: true
    type?: true
    targetAmount?: true
    currentAmount?: true
    startDate?: true
    targetDate?: true
    completedAt?: true
    status?: true
    icon?: true
    color?: true
    autoAllocate?: true
    allocationPercentage?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GoalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Goal to aggregate.
     */
    where?: GoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Goals to fetch.
     */
    orderBy?: GoalOrderByWithRelationInput | GoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Goals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Goals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Goals
    **/
    _count?: true | GoalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GoalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GoalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GoalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GoalMaxAggregateInputType
  }

  export type GetGoalAggregateType<T extends GoalAggregateArgs> = {
        [P in keyof T & keyof AggregateGoal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGoal[P]>
      : GetScalarType<T[P], AggregateGoal[P]>
  }




  export type GoalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GoalWhereInput
    orderBy?: GoalOrderByWithAggregationInput | GoalOrderByWithAggregationInput[]
    by: GoalScalarFieldEnum[] | GoalScalarFieldEnum
    having?: GoalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GoalCountAggregateInputType | true
    _avg?: GoalAvgAggregateInputType
    _sum?: GoalSumAggregateInputType
    _min?: GoalMinAggregateInputType
    _max?: GoalMaxAggregateInputType
  }

  export type GoalGroupByOutputType = {
    id: string
    workspaceId: string
    name: string
    description: string | null
    type: string
    targetAmount: number
    currentAmount: number
    startDate: Date
    targetDate: Date | null
    completedAt: Date | null
    status: string
    icon: string
    color: string
    autoAllocate: boolean
    allocationPercentage: number | null
    createdAt: Date
    updatedAt: Date
    _count: GoalCountAggregateOutputType | null
    _avg: GoalAvgAggregateOutputType | null
    _sum: GoalSumAggregateOutputType | null
    _min: GoalMinAggregateOutputType | null
    _max: GoalMaxAggregateOutputType | null
  }

  type GetGoalGroupByPayload<T extends GoalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GoalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GoalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GoalGroupByOutputType[P]>
            : GetScalarType<T[P], GoalGroupByOutputType[P]>
        }
      >
    >


  export type GoalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    targetAmount?: boolean
    currentAmount?: boolean
    startDate?: boolean
    targetDate?: boolean
    completedAt?: boolean
    status?: boolean
    icon?: boolean
    color?: boolean
    autoAllocate?: boolean
    allocationPercentage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contributions?: boolean | Goal$contributionsArgs<ExtArgs>
    Workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    _count?: boolean | GoalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["goal"]>

  export type GoalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    targetAmount?: boolean
    currentAmount?: boolean
    startDate?: boolean
    targetDate?: boolean
    completedAt?: boolean
    status?: boolean
    icon?: boolean
    color?: boolean
    autoAllocate?: boolean
    allocationPercentage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["goal"]>

  export type GoalSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    targetAmount?: boolean
    currentAmount?: boolean
    startDate?: boolean
    targetDate?: boolean
    completedAt?: boolean
    status?: boolean
    icon?: boolean
    color?: boolean
    autoAllocate?: boolean
    allocationPercentage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GoalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contributions?: boolean | Goal$contributionsArgs<ExtArgs>
    Workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    _count?: boolean | GoalCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GoalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $GoalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Goal"
    objects: {
      contributions: Prisma.$GoalContributionPayload<ExtArgs>[]
      Workspace: Prisma.$WorkspacePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      name: string
      description: string | null
      type: string
      targetAmount: number
      currentAmount: number
      startDate: Date
      targetDate: Date | null
      completedAt: Date | null
      status: string
      icon: string
      color: string
      autoAllocate: boolean
      allocationPercentage: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["goal"]>
    composites: {}
  }

  type GoalGetPayload<S extends boolean | null | undefined | GoalDefaultArgs> = $Result.GetResult<Prisma.$GoalPayload, S>

  type GoalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GoalFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GoalCountAggregateInputType | true
    }

  export interface GoalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Goal'], meta: { name: 'Goal' } }
    /**
     * Find zero or one Goal that matches the filter.
     * @param {GoalFindUniqueArgs} args - Arguments to find a Goal
     * @example
     * // Get one Goal
     * const goal = await prisma.goal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GoalFindUniqueArgs>(args: SelectSubset<T, GoalFindUniqueArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Goal that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GoalFindUniqueOrThrowArgs} args - Arguments to find a Goal
     * @example
     * // Get one Goal
     * const goal = await prisma.goal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GoalFindUniqueOrThrowArgs>(args: SelectSubset<T, GoalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Goal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalFindFirstArgs} args - Arguments to find a Goal
     * @example
     * // Get one Goal
     * const goal = await prisma.goal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GoalFindFirstArgs>(args?: SelectSubset<T, GoalFindFirstArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Goal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalFindFirstOrThrowArgs} args - Arguments to find a Goal
     * @example
     * // Get one Goal
     * const goal = await prisma.goal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GoalFindFirstOrThrowArgs>(args?: SelectSubset<T, GoalFindFirstOrThrowArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Goals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Goals
     * const goals = await prisma.goal.findMany()
     * 
     * // Get first 10 Goals
     * const goals = await prisma.goal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const goalWithIdOnly = await prisma.goal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GoalFindManyArgs>(args?: SelectSubset<T, GoalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Goal.
     * @param {GoalCreateArgs} args - Arguments to create a Goal.
     * @example
     * // Create one Goal
     * const Goal = await prisma.goal.create({
     *   data: {
     *     // ... data to create a Goal
     *   }
     * })
     * 
     */
    create<T extends GoalCreateArgs>(args: SelectSubset<T, GoalCreateArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Goals.
     * @param {GoalCreateManyArgs} args - Arguments to create many Goals.
     * @example
     * // Create many Goals
     * const goal = await prisma.goal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GoalCreateManyArgs>(args?: SelectSubset<T, GoalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Goals and returns the data saved in the database.
     * @param {GoalCreateManyAndReturnArgs} args - Arguments to create many Goals.
     * @example
     * // Create many Goals
     * const goal = await prisma.goal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Goals and only return the `id`
     * const goalWithIdOnly = await prisma.goal.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GoalCreateManyAndReturnArgs>(args?: SelectSubset<T, GoalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Goal.
     * @param {GoalDeleteArgs} args - Arguments to delete one Goal.
     * @example
     * // Delete one Goal
     * const Goal = await prisma.goal.delete({
     *   where: {
     *     // ... filter to delete one Goal
     *   }
     * })
     * 
     */
    delete<T extends GoalDeleteArgs>(args: SelectSubset<T, GoalDeleteArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Goal.
     * @param {GoalUpdateArgs} args - Arguments to update one Goal.
     * @example
     * // Update one Goal
     * const goal = await prisma.goal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GoalUpdateArgs>(args: SelectSubset<T, GoalUpdateArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Goals.
     * @param {GoalDeleteManyArgs} args - Arguments to filter Goals to delete.
     * @example
     * // Delete a few Goals
     * const { count } = await prisma.goal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GoalDeleteManyArgs>(args?: SelectSubset<T, GoalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Goals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Goals
     * const goal = await prisma.goal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GoalUpdateManyArgs>(args: SelectSubset<T, GoalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Goal.
     * @param {GoalUpsertArgs} args - Arguments to update or create a Goal.
     * @example
     * // Update or create a Goal
     * const goal = await prisma.goal.upsert({
     *   create: {
     *     // ... data to create a Goal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Goal we want to update
     *   }
     * })
     */
    upsert<T extends GoalUpsertArgs>(args: SelectSubset<T, GoalUpsertArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Goals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalCountArgs} args - Arguments to filter Goals to count.
     * @example
     * // Count the number of Goals
     * const count = await prisma.goal.count({
     *   where: {
     *     // ... the filter for the Goals we want to count
     *   }
     * })
    **/
    count<T extends GoalCountArgs>(
      args?: Subset<T, GoalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GoalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Goal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GoalAggregateArgs>(args: Subset<T, GoalAggregateArgs>): Prisma.PrismaPromise<GetGoalAggregateType<T>>

    /**
     * Group by Goal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GoalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GoalGroupByArgs['orderBy'] }
        : { orderBy?: GoalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GoalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGoalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Goal model
   */
  readonly fields: GoalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Goal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GoalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contributions<T extends Goal$contributionsArgs<ExtArgs> = {}>(args?: Subset<T, Goal$contributionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoalContributionPayload<ExtArgs>, T, "findMany"> | Null>
    Workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Goal model
   */ 
  interface GoalFieldRefs {
    readonly id: FieldRef<"Goal", 'String'>
    readonly workspaceId: FieldRef<"Goal", 'String'>
    readonly name: FieldRef<"Goal", 'String'>
    readonly description: FieldRef<"Goal", 'String'>
    readonly type: FieldRef<"Goal", 'String'>
    readonly targetAmount: FieldRef<"Goal", 'Float'>
    readonly currentAmount: FieldRef<"Goal", 'Float'>
    readonly startDate: FieldRef<"Goal", 'DateTime'>
    readonly targetDate: FieldRef<"Goal", 'DateTime'>
    readonly completedAt: FieldRef<"Goal", 'DateTime'>
    readonly status: FieldRef<"Goal", 'String'>
    readonly icon: FieldRef<"Goal", 'String'>
    readonly color: FieldRef<"Goal", 'String'>
    readonly autoAllocate: FieldRef<"Goal", 'Boolean'>
    readonly allocationPercentage: FieldRef<"Goal", 'Float'>
    readonly createdAt: FieldRef<"Goal", 'DateTime'>
    readonly updatedAt: FieldRef<"Goal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Goal findUnique
   */
  export type GoalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * Filter, which Goal to fetch.
     */
    where: GoalWhereUniqueInput
  }

  /**
   * Goal findUniqueOrThrow
   */
  export type GoalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * Filter, which Goal to fetch.
     */
    where: GoalWhereUniqueInput
  }

  /**
   * Goal findFirst
   */
  export type GoalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * Filter, which Goal to fetch.
     */
    where?: GoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Goals to fetch.
     */
    orderBy?: GoalOrderByWithRelationInput | GoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Goals.
     */
    cursor?: GoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Goals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Goals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Goals.
     */
    distinct?: GoalScalarFieldEnum | GoalScalarFieldEnum[]
  }

  /**
   * Goal findFirstOrThrow
   */
  export type GoalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * Filter, which Goal to fetch.
     */
    where?: GoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Goals to fetch.
     */
    orderBy?: GoalOrderByWithRelationInput | GoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Goals.
     */
    cursor?: GoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Goals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Goals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Goals.
     */
    distinct?: GoalScalarFieldEnum | GoalScalarFieldEnum[]
  }

  /**
   * Goal findMany
   */
  export type GoalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * Filter, which Goals to fetch.
     */
    where?: GoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Goals to fetch.
     */
    orderBy?: GoalOrderByWithRelationInput | GoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Goals.
     */
    cursor?: GoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Goals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Goals.
     */
    skip?: number
    distinct?: GoalScalarFieldEnum | GoalScalarFieldEnum[]
  }

  /**
   * Goal create
   */
  export type GoalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * The data needed to create a Goal.
     */
    data: XOR<GoalCreateInput, GoalUncheckedCreateInput>
  }

  /**
   * Goal createMany
   */
  export type GoalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Goals.
     */
    data: GoalCreateManyInput | GoalCreateManyInput[]
  }

  /**
   * Goal createManyAndReturn
   */
  export type GoalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Goals.
     */
    data: GoalCreateManyInput | GoalCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Goal update
   */
  export type GoalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * The data needed to update a Goal.
     */
    data: XOR<GoalUpdateInput, GoalUncheckedUpdateInput>
    /**
     * Choose, which Goal to update.
     */
    where: GoalWhereUniqueInput
  }

  /**
   * Goal updateMany
   */
  export type GoalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Goals.
     */
    data: XOR<GoalUpdateManyMutationInput, GoalUncheckedUpdateManyInput>
    /**
     * Filter which Goals to update
     */
    where?: GoalWhereInput
  }

  /**
   * Goal upsert
   */
  export type GoalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * The filter to search for the Goal to update in case it exists.
     */
    where: GoalWhereUniqueInput
    /**
     * In case the Goal found by the `where` argument doesn't exist, create a new Goal with this data.
     */
    create: XOR<GoalCreateInput, GoalUncheckedCreateInput>
    /**
     * In case the Goal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GoalUpdateInput, GoalUncheckedUpdateInput>
  }

  /**
   * Goal delete
   */
  export type GoalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * Filter which Goal to delete.
     */
    where: GoalWhereUniqueInput
  }

  /**
   * Goal deleteMany
   */
  export type GoalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Goals to delete
     */
    where?: GoalWhereInput
  }

  /**
   * Goal.contributions
   */
  export type Goal$contributionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalContribution
     */
    select?: GoalContributionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalContributionInclude<ExtArgs> | null
    where?: GoalContributionWhereInput
    orderBy?: GoalContributionOrderByWithRelationInput | GoalContributionOrderByWithRelationInput[]
    cursor?: GoalContributionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GoalContributionScalarFieldEnum | GoalContributionScalarFieldEnum[]
  }

  /**
   * Goal without action
   */
  export type GoalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
  }


  /**
   * Model GoalContribution
   */

  export type AggregateGoalContribution = {
    _count: GoalContributionCountAggregateOutputType | null
    _avg: GoalContributionAvgAggregateOutputType | null
    _sum: GoalContributionSumAggregateOutputType | null
    _min: GoalContributionMinAggregateOutputType | null
    _max: GoalContributionMaxAggregateOutputType | null
  }

  export type GoalContributionAvgAggregateOutputType = {
    amount: number | null
  }

  export type GoalContributionSumAggregateOutputType = {
    amount: number | null
  }

  export type GoalContributionMinAggregateOutputType = {
    id: string | null
    goalId: string | null
    amount: number | null
    description: string | null
    contributedAt: Date | null
  }

  export type GoalContributionMaxAggregateOutputType = {
    id: string | null
    goalId: string | null
    amount: number | null
    description: string | null
    contributedAt: Date | null
  }

  export type GoalContributionCountAggregateOutputType = {
    id: number
    goalId: number
    amount: number
    description: number
    contributedAt: number
    _all: number
  }


  export type GoalContributionAvgAggregateInputType = {
    amount?: true
  }

  export type GoalContributionSumAggregateInputType = {
    amount?: true
  }

  export type GoalContributionMinAggregateInputType = {
    id?: true
    goalId?: true
    amount?: true
    description?: true
    contributedAt?: true
  }

  export type GoalContributionMaxAggregateInputType = {
    id?: true
    goalId?: true
    amount?: true
    description?: true
    contributedAt?: true
  }

  export type GoalContributionCountAggregateInputType = {
    id?: true
    goalId?: true
    amount?: true
    description?: true
    contributedAt?: true
    _all?: true
  }

  export type GoalContributionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GoalContribution to aggregate.
     */
    where?: GoalContributionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoalContributions to fetch.
     */
    orderBy?: GoalContributionOrderByWithRelationInput | GoalContributionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GoalContributionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GoalContributions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoalContributions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GoalContributions
    **/
    _count?: true | GoalContributionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GoalContributionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GoalContributionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GoalContributionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GoalContributionMaxAggregateInputType
  }

  export type GetGoalContributionAggregateType<T extends GoalContributionAggregateArgs> = {
        [P in keyof T & keyof AggregateGoalContribution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGoalContribution[P]>
      : GetScalarType<T[P], AggregateGoalContribution[P]>
  }




  export type GoalContributionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GoalContributionWhereInput
    orderBy?: GoalContributionOrderByWithAggregationInput | GoalContributionOrderByWithAggregationInput[]
    by: GoalContributionScalarFieldEnum[] | GoalContributionScalarFieldEnum
    having?: GoalContributionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GoalContributionCountAggregateInputType | true
    _avg?: GoalContributionAvgAggregateInputType
    _sum?: GoalContributionSumAggregateInputType
    _min?: GoalContributionMinAggregateInputType
    _max?: GoalContributionMaxAggregateInputType
  }

  export type GoalContributionGroupByOutputType = {
    id: string
    goalId: string
    amount: number
    description: string | null
    contributedAt: Date
    _count: GoalContributionCountAggregateOutputType | null
    _avg: GoalContributionAvgAggregateOutputType | null
    _sum: GoalContributionSumAggregateOutputType | null
    _min: GoalContributionMinAggregateOutputType | null
    _max: GoalContributionMaxAggregateOutputType | null
  }

  type GetGoalContributionGroupByPayload<T extends GoalContributionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GoalContributionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GoalContributionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GoalContributionGroupByOutputType[P]>
            : GetScalarType<T[P], GoalContributionGroupByOutputType[P]>
        }
      >
    >


  export type GoalContributionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    goalId?: boolean
    amount?: boolean
    description?: boolean
    contributedAt?: boolean
    goal?: boolean | GoalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["goalContribution"]>

  export type GoalContributionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    goalId?: boolean
    amount?: boolean
    description?: boolean
    contributedAt?: boolean
    goal?: boolean | GoalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["goalContribution"]>

  export type GoalContributionSelectScalar = {
    id?: boolean
    goalId?: boolean
    amount?: boolean
    description?: boolean
    contributedAt?: boolean
  }

  export type GoalContributionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    goal?: boolean | GoalDefaultArgs<ExtArgs>
  }
  export type GoalContributionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    goal?: boolean | GoalDefaultArgs<ExtArgs>
  }

  export type $GoalContributionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GoalContribution"
    objects: {
      goal: Prisma.$GoalPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      goalId: string
      amount: number
      description: string | null
      contributedAt: Date
    }, ExtArgs["result"]["goalContribution"]>
    composites: {}
  }

  type GoalContributionGetPayload<S extends boolean | null | undefined | GoalContributionDefaultArgs> = $Result.GetResult<Prisma.$GoalContributionPayload, S>

  type GoalContributionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GoalContributionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GoalContributionCountAggregateInputType | true
    }

  export interface GoalContributionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GoalContribution'], meta: { name: 'GoalContribution' } }
    /**
     * Find zero or one GoalContribution that matches the filter.
     * @param {GoalContributionFindUniqueArgs} args - Arguments to find a GoalContribution
     * @example
     * // Get one GoalContribution
     * const goalContribution = await prisma.goalContribution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GoalContributionFindUniqueArgs>(args: SelectSubset<T, GoalContributionFindUniqueArgs<ExtArgs>>): Prisma__GoalContributionClient<$Result.GetResult<Prisma.$GoalContributionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one GoalContribution that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GoalContributionFindUniqueOrThrowArgs} args - Arguments to find a GoalContribution
     * @example
     * // Get one GoalContribution
     * const goalContribution = await prisma.goalContribution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GoalContributionFindUniqueOrThrowArgs>(args: SelectSubset<T, GoalContributionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GoalContributionClient<$Result.GetResult<Prisma.$GoalContributionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first GoalContribution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalContributionFindFirstArgs} args - Arguments to find a GoalContribution
     * @example
     * // Get one GoalContribution
     * const goalContribution = await prisma.goalContribution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GoalContributionFindFirstArgs>(args?: SelectSubset<T, GoalContributionFindFirstArgs<ExtArgs>>): Prisma__GoalContributionClient<$Result.GetResult<Prisma.$GoalContributionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first GoalContribution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalContributionFindFirstOrThrowArgs} args - Arguments to find a GoalContribution
     * @example
     * // Get one GoalContribution
     * const goalContribution = await prisma.goalContribution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GoalContributionFindFirstOrThrowArgs>(args?: SelectSubset<T, GoalContributionFindFirstOrThrowArgs<ExtArgs>>): Prisma__GoalContributionClient<$Result.GetResult<Prisma.$GoalContributionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more GoalContributions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalContributionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GoalContributions
     * const goalContributions = await prisma.goalContribution.findMany()
     * 
     * // Get first 10 GoalContributions
     * const goalContributions = await prisma.goalContribution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const goalContributionWithIdOnly = await prisma.goalContribution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GoalContributionFindManyArgs>(args?: SelectSubset<T, GoalContributionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoalContributionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a GoalContribution.
     * @param {GoalContributionCreateArgs} args - Arguments to create a GoalContribution.
     * @example
     * // Create one GoalContribution
     * const GoalContribution = await prisma.goalContribution.create({
     *   data: {
     *     // ... data to create a GoalContribution
     *   }
     * })
     * 
     */
    create<T extends GoalContributionCreateArgs>(args: SelectSubset<T, GoalContributionCreateArgs<ExtArgs>>): Prisma__GoalContributionClient<$Result.GetResult<Prisma.$GoalContributionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many GoalContributions.
     * @param {GoalContributionCreateManyArgs} args - Arguments to create many GoalContributions.
     * @example
     * // Create many GoalContributions
     * const goalContribution = await prisma.goalContribution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GoalContributionCreateManyArgs>(args?: SelectSubset<T, GoalContributionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GoalContributions and returns the data saved in the database.
     * @param {GoalContributionCreateManyAndReturnArgs} args - Arguments to create many GoalContributions.
     * @example
     * // Create many GoalContributions
     * const goalContribution = await prisma.goalContribution.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GoalContributions and only return the `id`
     * const goalContributionWithIdOnly = await prisma.goalContribution.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GoalContributionCreateManyAndReturnArgs>(args?: SelectSubset<T, GoalContributionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoalContributionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a GoalContribution.
     * @param {GoalContributionDeleteArgs} args - Arguments to delete one GoalContribution.
     * @example
     * // Delete one GoalContribution
     * const GoalContribution = await prisma.goalContribution.delete({
     *   where: {
     *     // ... filter to delete one GoalContribution
     *   }
     * })
     * 
     */
    delete<T extends GoalContributionDeleteArgs>(args: SelectSubset<T, GoalContributionDeleteArgs<ExtArgs>>): Prisma__GoalContributionClient<$Result.GetResult<Prisma.$GoalContributionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one GoalContribution.
     * @param {GoalContributionUpdateArgs} args - Arguments to update one GoalContribution.
     * @example
     * // Update one GoalContribution
     * const goalContribution = await prisma.goalContribution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GoalContributionUpdateArgs>(args: SelectSubset<T, GoalContributionUpdateArgs<ExtArgs>>): Prisma__GoalContributionClient<$Result.GetResult<Prisma.$GoalContributionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more GoalContributions.
     * @param {GoalContributionDeleteManyArgs} args - Arguments to filter GoalContributions to delete.
     * @example
     * // Delete a few GoalContributions
     * const { count } = await prisma.goalContribution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GoalContributionDeleteManyArgs>(args?: SelectSubset<T, GoalContributionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GoalContributions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalContributionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GoalContributions
     * const goalContribution = await prisma.goalContribution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GoalContributionUpdateManyArgs>(args: SelectSubset<T, GoalContributionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GoalContribution.
     * @param {GoalContributionUpsertArgs} args - Arguments to update or create a GoalContribution.
     * @example
     * // Update or create a GoalContribution
     * const goalContribution = await prisma.goalContribution.upsert({
     *   create: {
     *     // ... data to create a GoalContribution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GoalContribution we want to update
     *   }
     * })
     */
    upsert<T extends GoalContributionUpsertArgs>(args: SelectSubset<T, GoalContributionUpsertArgs<ExtArgs>>): Prisma__GoalContributionClient<$Result.GetResult<Prisma.$GoalContributionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of GoalContributions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalContributionCountArgs} args - Arguments to filter GoalContributions to count.
     * @example
     * // Count the number of GoalContributions
     * const count = await prisma.goalContribution.count({
     *   where: {
     *     // ... the filter for the GoalContributions we want to count
     *   }
     * })
    **/
    count<T extends GoalContributionCountArgs>(
      args?: Subset<T, GoalContributionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GoalContributionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GoalContribution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalContributionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GoalContributionAggregateArgs>(args: Subset<T, GoalContributionAggregateArgs>): Prisma.PrismaPromise<GetGoalContributionAggregateType<T>>

    /**
     * Group by GoalContribution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalContributionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GoalContributionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GoalContributionGroupByArgs['orderBy'] }
        : { orderBy?: GoalContributionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GoalContributionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGoalContributionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GoalContribution model
   */
  readonly fields: GoalContributionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GoalContribution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GoalContributionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    goal<T extends GoalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GoalDefaultArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GoalContribution model
   */ 
  interface GoalContributionFieldRefs {
    readonly id: FieldRef<"GoalContribution", 'String'>
    readonly goalId: FieldRef<"GoalContribution", 'String'>
    readonly amount: FieldRef<"GoalContribution", 'Float'>
    readonly description: FieldRef<"GoalContribution", 'String'>
    readonly contributedAt: FieldRef<"GoalContribution", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GoalContribution findUnique
   */
  export type GoalContributionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalContribution
     */
    select?: GoalContributionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalContributionInclude<ExtArgs> | null
    /**
     * Filter, which GoalContribution to fetch.
     */
    where: GoalContributionWhereUniqueInput
  }

  /**
   * GoalContribution findUniqueOrThrow
   */
  export type GoalContributionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalContribution
     */
    select?: GoalContributionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalContributionInclude<ExtArgs> | null
    /**
     * Filter, which GoalContribution to fetch.
     */
    where: GoalContributionWhereUniqueInput
  }

  /**
   * GoalContribution findFirst
   */
  export type GoalContributionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalContribution
     */
    select?: GoalContributionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalContributionInclude<ExtArgs> | null
    /**
     * Filter, which GoalContribution to fetch.
     */
    where?: GoalContributionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoalContributions to fetch.
     */
    orderBy?: GoalContributionOrderByWithRelationInput | GoalContributionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GoalContributions.
     */
    cursor?: GoalContributionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GoalContributions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoalContributions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GoalContributions.
     */
    distinct?: GoalContributionScalarFieldEnum | GoalContributionScalarFieldEnum[]
  }

  /**
   * GoalContribution findFirstOrThrow
   */
  export type GoalContributionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalContribution
     */
    select?: GoalContributionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalContributionInclude<ExtArgs> | null
    /**
     * Filter, which GoalContribution to fetch.
     */
    where?: GoalContributionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoalContributions to fetch.
     */
    orderBy?: GoalContributionOrderByWithRelationInput | GoalContributionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GoalContributions.
     */
    cursor?: GoalContributionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GoalContributions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoalContributions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GoalContributions.
     */
    distinct?: GoalContributionScalarFieldEnum | GoalContributionScalarFieldEnum[]
  }

  /**
   * GoalContribution findMany
   */
  export type GoalContributionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalContribution
     */
    select?: GoalContributionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalContributionInclude<ExtArgs> | null
    /**
     * Filter, which GoalContributions to fetch.
     */
    where?: GoalContributionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoalContributions to fetch.
     */
    orderBy?: GoalContributionOrderByWithRelationInput | GoalContributionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GoalContributions.
     */
    cursor?: GoalContributionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GoalContributions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoalContributions.
     */
    skip?: number
    distinct?: GoalContributionScalarFieldEnum | GoalContributionScalarFieldEnum[]
  }

  /**
   * GoalContribution create
   */
  export type GoalContributionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalContribution
     */
    select?: GoalContributionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalContributionInclude<ExtArgs> | null
    /**
     * The data needed to create a GoalContribution.
     */
    data: XOR<GoalContributionCreateInput, GoalContributionUncheckedCreateInput>
  }

  /**
   * GoalContribution createMany
   */
  export type GoalContributionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GoalContributions.
     */
    data: GoalContributionCreateManyInput | GoalContributionCreateManyInput[]
  }

  /**
   * GoalContribution createManyAndReturn
   */
  export type GoalContributionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalContribution
     */
    select?: GoalContributionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many GoalContributions.
     */
    data: GoalContributionCreateManyInput | GoalContributionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalContributionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GoalContribution update
   */
  export type GoalContributionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalContribution
     */
    select?: GoalContributionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalContributionInclude<ExtArgs> | null
    /**
     * The data needed to update a GoalContribution.
     */
    data: XOR<GoalContributionUpdateInput, GoalContributionUncheckedUpdateInput>
    /**
     * Choose, which GoalContribution to update.
     */
    where: GoalContributionWhereUniqueInput
  }

  /**
   * GoalContribution updateMany
   */
  export type GoalContributionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GoalContributions.
     */
    data: XOR<GoalContributionUpdateManyMutationInput, GoalContributionUncheckedUpdateManyInput>
    /**
     * Filter which GoalContributions to update
     */
    where?: GoalContributionWhereInput
  }

  /**
   * GoalContribution upsert
   */
  export type GoalContributionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalContribution
     */
    select?: GoalContributionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalContributionInclude<ExtArgs> | null
    /**
     * The filter to search for the GoalContribution to update in case it exists.
     */
    where: GoalContributionWhereUniqueInput
    /**
     * In case the GoalContribution found by the `where` argument doesn't exist, create a new GoalContribution with this data.
     */
    create: XOR<GoalContributionCreateInput, GoalContributionUncheckedCreateInput>
    /**
     * In case the GoalContribution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GoalContributionUpdateInput, GoalContributionUncheckedUpdateInput>
  }

  /**
   * GoalContribution delete
   */
  export type GoalContributionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalContribution
     */
    select?: GoalContributionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalContributionInclude<ExtArgs> | null
    /**
     * Filter which GoalContribution to delete.
     */
    where: GoalContributionWhereUniqueInput
  }

  /**
   * GoalContribution deleteMany
   */
  export type GoalContributionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GoalContributions to delete
     */
    where?: GoalContributionWhereInput
  }

  /**
   * GoalContribution without action
   */
  export type GoalContributionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalContribution
     */
    select?: GoalContributionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalContributionInclude<ExtArgs> | null
  }


  /**
   * Model ImportJob
   */

  export type AggregateImportJob = {
    _count: ImportJobCountAggregateOutputType | null
    _avg: ImportJobAvgAggregateOutputType | null
    _sum: ImportJobSumAggregateOutputType | null
    _min: ImportJobMinAggregateOutputType | null
    _max: ImportJobMaxAggregateOutputType | null
  }

  export type ImportJobAvgAggregateOutputType = {
    fileSize: number | null
    progress: number | null
    totalRows: number | null
    processedRows: number | null
    importedRows: number | null
  }

  export type ImportJobSumAggregateOutputType = {
    fileSize: number | null
    progress: number | null
    totalRows: number | null
    processedRows: number | null
    importedRows: number | null
  }

  export type ImportJobMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    accountId: string | null
    format: string | null
    fileName: string | null
    fileSize: number | null
    fileUrl: string | null
    status: string | null
    progress: number | null
    totalRows: number | null
    processedRows: number | null
    importedRows: number | null
    errorLog: string | null
    mappingConfig: string | null
    startedAt: Date | null
    completedAt: Date | null
    createdAt: Date | null
  }

  export type ImportJobMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    accountId: string | null
    format: string | null
    fileName: string | null
    fileSize: number | null
    fileUrl: string | null
    status: string | null
    progress: number | null
    totalRows: number | null
    processedRows: number | null
    importedRows: number | null
    errorLog: string | null
    mappingConfig: string | null
    startedAt: Date | null
    completedAt: Date | null
    createdAt: Date | null
  }

  export type ImportJobCountAggregateOutputType = {
    id: number
    workspaceId: number
    accountId: number
    format: number
    fileName: number
    fileSize: number
    fileUrl: number
    status: number
    progress: number
    totalRows: number
    processedRows: number
    importedRows: number
    errorLog: number
    mappingConfig: number
    startedAt: number
    completedAt: number
    createdAt: number
    _all: number
  }


  export type ImportJobAvgAggregateInputType = {
    fileSize?: true
    progress?: true
    totalRows?: true
    processedRows?: true
    importedRows?: true
  }

  export type ImportJobSumAggregateInputType = {
    fileSize?: true
    progress?: true
    totalRows?: true
    processedRows?: true
    importedRows?: true
  }

  export type ImportJobMinAggregateInputType = {
    id?: true
    workspaceId?: true
    accountId?: true
    format?: true
    fileName?: true
    fileSize?: true
    fileUrl?: true
    status?: true
    progress?: true
    totalRows?: true
    processedRows?: true
    importedRows?: true
    errorLog?: true
    mappingConfig?: true
    startedAt?: true
    completedAt?: true
    createdAt?: true
  }

  export type ImportJobMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    accountId?: true
    format?: true
    fileName?: true
    fileSize?: true
    fileUrl?: true
    status?: true
    progress?: true
    totalRows?: true
    processedRows?: true
    importedRows?: true
    errorLog?: true
    mappingConfig?: true
    startedAt?: true
    completedAt?: true
    createdAt?: true
  }

  export type ImportJobCountAggregateInputType = {
    id?: true
    workspaceId?: true
    accountId?: true
    format?: true
    fileName?: true
    fileSize?: true
    fileUrl?: true
    status?: true
    progress?: true
    totalRows?: true
    processedRows?: true
    importedRows?: true
    errorLog?: true
    mappingConfig?: true
    startedAt?: true
    completedAt?: true
    createdAt?: true
    _all?: true
  }

  export type ImportJobAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImportJob to aggregate.
     */
    where?: ImportJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportJobs to fetch.
     */
    orderBy?: ImportJobOrderByWithRelationInput | ImportJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImportJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ImportJobs
    **/
    _count?: true | ImportJobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ImportJobAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ImportJobSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImportJobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImportJobMaxAggregateInputType
  }

  export type GetImportJobAggregateType<T extends ImportJobAggregateArgs> = {
        [P in keyof T & keyof AggregateImportJob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImportJob[P]>
      : GetScalarType<T[P], AggregateImportJob[P]>
  }




  export type ImportJobGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImportJobWhereInput
    orderBy?: ImportJobOrderByWithAggregationInput | ImportJobOrderByWithAggregationInput[]
    by: ImportJobScalarFieldEnum[] | ImportJobScalarFieldEnum
    having?: ImportJobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImportJobCountAggregateInputType | true
    _avg?: ImportJobAvgAggregateInputType
    _sum?: ImportJobSumAggregateInputType
    _min?: ImportJobMinAggregateInputType
    _max?: ImportJobMaxAggregateInputType
  }

  export type ImportJobGroupByOutputType = {
    id: string
    workspaceId: string
    accountId: string
    format: string
    fileName: string
    fileSize: number
    fileUrl: string | null
    status: string
    progress: number
    totalRows: number
    processedRows: number
    importedRows: number
    errorLog: string | null
    mappingConfig: string | null
    startedAt: Date | null
    completedAt: Date | null
    createdAt: Date
    _count: ImportJobCountAggregateOutputType | null
    _avg: ImportJobAvgAggregateOutputType | null
    _sum: ImportJobSumAggregateOutputType | null
    _min: ImportJobMinAggregateOutputType | null
    _max: ImportJobMaxAggregateOutputType | null
  }

  type GetImportJobGroupByPayload<T extends ImportJobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImportJobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImportJobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImportJobGroupByOutputType[P]>
            : GetScalarType<T[P], ImportJobGroupByOutputType[P]>
        }
      >
    >


  export type ImportJobSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    accountId?: boolean
    format?: boolean
    fileName?: boolean
    fileSize?: boolean
    fileUrl?: boolean
    status?: boolean
    progress?: boolean
    totalRows?: boolean
    processedRows?: boolean
    importedRows?: boolean
    errorLog?: boolean
    mappingConfig?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    Workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["importJob"]>

  export type ImportJobSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    accountId?: boolean
    format?: boolean
    fileName?: boolean
    fileSize?: boolean
    fileUrl?: boolean
    status?: boolean
    progress?: boolean
    totalRows?: boolean
    processedRows?: boolean
    importedRows?: boolean
    errorLog?: boolean
    mappingConfig?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    Workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["importJob"]>

  export type ImportJobSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    accountId?: boolean
    format?: boolean
    fileName?: boolean
    fileSize?: boolean
    fileUrl?: boolean
    status?: boolean
    progress?: boolean
    totalRows?: boolean
    processedRows?: boolean
    importedRows?: boolean
    errorLog?: boolean
    mappingConfig?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
  }

  export type ImportJobInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type ImportJobIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $ImportJobPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ImportJob"
    objects: {
      Workspace: Prisma.$WorkspacePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      accountId: string
      format: string
      fileName: string
      fileSize: number
      fileUrl: string | null
      status: string
      progress: number
      totalRows: number
      processedRows: number
      importedRows: number
      errorLog: string | null
      mappingConfig: string | null
      startedAt: Date | null
      completedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["importJob"]>
    composites: {}
  }

  type ImportJobGetPayload<S extends boolean | null | undefined | ImportJobDefaultArgs> = $Result.GetResult<Prisma.$ImportJobPayload, S>

  type ImportJobCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ImportJobFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ImportJobCountAggregateInputType | true
    }

  export interface ImportJobDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ImportJob'], meta: { name: 'ImportJob' } }
    /**
     * Find zero or one ImportJob that matches the filter.
     * @param {ImportJobFindUniqueArgs} args - Arguments to find a ImportJob
     * @example
     * // Get one ImportJob
     * const importJob = await prisma.importJob.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ImportJobFindUniqueArgs>(args: SelectSubset<T, ImportJobFindUniqueArgs<ExtArgs>>): Prisma__ImportJobClient<$Result.GetResult<Prisma.$ImportJobPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ImportJob that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ImportJobFindUniqueOrThrowArgs} args - Arguments to find a ImportJob
     * @example
     * // Get one ImportJob
     * const importJob = await prisma.importJob.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ImportJobFindUniqueOrThrowArgs>(args: SelectSubset<T, ImportJobFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ImportJobClient<$Result.GetResult<Prisma.$ImportJobPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ImportJob that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportJobFindFirstArgs} args - Arguments to find a ImportJob
     * @example
     * // Get one ImportJob
     * const importJob = await prisma.importJob.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ImportJobFindFirstArgs>(args?: SelectSubset<T, ImportJobFindFirstArgs<ExtArgs>>): Prisma__ImportJobClient<$Result.GetResult<Prisma.$ImportJobPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ImportJob that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportJobFindFirstOrThrowArgs} args - Arguments to find a ImportJob
     * @example
     * // Get one ImportJob
     * const importJob = await prisma.importJob.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ImportJobFindFirstOrThrowArgs>(args?: SelectSubset<T, ImportJobFindFirstOrThrowArgs<ExtArgs>>): Prisma__ImportJobClient<$Result.GetResult<Prisma.$ImportJobPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ImportJobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportJobFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ImportJobs
     * const importJobs = await prisma.importJob.findMany()
     * 
     * // Get first 10 ImportJobs
     * const importJobs = await prisma.importJob.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const importJobWithIdOnly = await prisma.importJob.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ImportJobFindManyArgs>(args?: SelectSubset<T, ImportJobFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImportJobPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ImportJob.
     * @param {ImportJobCreateArgs} args - Arguments to create a ImportJob.
     * @example
     * // Create one ImportJob
     * const ImportJob = await prisma.importJob.create({
     *   data: {
     *     // ... data to create a ImportJob
     *   }
     * })
     * 
     */
    create<T extends ImportJobCreateArgs>(args: SelectSubset<T, ImportJobCreateArgs<ExtArgs>>): Prisma__ImportJobClient<$Result.GetResult<Prisma.$ImportJobPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ImportJobs.
     * @param {ImportJobCreateManyArgs} args - Arguments to create many ImportJobs.
     * @example
     * // Create many ImportJobs
     * const importJob = await prisma.importJob.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ImportJobCreateManyArgs>(args?: SelectSubset<T, ImportJobCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ImportJobs and returns the data saved in the database.
     * @param {ImportJobCreateManyAndReturnArgs} args - Arguments to create many ImportJobs.
     * @example
     * // Create many ImportJobs
     * const importJob = await prisma.importJob.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ImportJobs and only return the `id`
     * const importJobWithIdOnly = await prisma.importJob.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ImportJobCreateManyAndReturnArgs>(args?: SelectSubset<T, ImportJobCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImportJobPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ImportJob.
     * @param {ImportJobDeleteArgs} args - Arguments to delete one ImportJob.
     * @example
     * // Delete one ImportJob
     * const ImportJob = await prisma.importJob.delete({
     *   where: {
     *     // ... filter to delete one ImportJob
     *   }
     * })
     * 
     */
    delete<T extends ImportJobDeleteArgs>(args: SelectSubset<T, ImportJobDeleteArgs<ExtArgs>>): Prisma__ImportJobClient<$Result.GetResult<Prisma.$ImportJobPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ImportJob.
     * @param {ImportJobUpdateArgs} args - Arguments to update one ImportJob.
     * @example
     * // Update one ImportJob
     * const importJob = await prisma.importJob.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ImportJobUpdateArgs>(args: SelectSubset<T, ImportJobUpdateArgs<ExtArgs>>): Prisma__ImportJobClient<$Result.GetResult<Prisma.$ImportJobPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ImportJobs.
     * @param {ImportJobDeleteManyArgs} args - Arguments to filter ImportJobs to delete.
     * @example
     * // Delete a few ImportJobs
     * const { count } = await prisma.importJob.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ImportJobDeleteManyArgs>(args?: SelectSubset<T, ImportJobDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ImportJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportJobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ImportJobs
     * const importJob = await prisma.importJob.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ImportJobUpdateManyArgs>(args: SelectSubset<T, ImportJobUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ImportJob.
     * @param {ImportJobUpsertArgs} args - Arguments to update or create a ImportJob.
     * @example
     * // Update or create a ImportJob
     * const importJob = await prisma.importJob.upsert({
     *   create: {
     *     // ... data to create a ImportJob
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ImportJob we want to update
     *   }
     * })
     */
    upsert<T extends ImportJobUpsertArgs>(args: SelectSubset<T, ImportJobUpsertArgs<ExtArgs>>): Prisma__ImportJobClient<$Result.GetResult<Prisma.$ImportJobPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ImportJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportJobCountArgs} args - Arguments to filter ImportJobs to count.
     * @example
     * // Count the number of ImportJobs
     * const count = await prisma.importJob.count({
     *   where: {
     *     // ... the filter for the ImportJobs we want to count
     *   }
     * })
    **/
    count<T extends ImportJobCountArgs>(
      args?: Subset<T, ImportJobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImportJobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ImportJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportJobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImportJobAggregateArgs>(args: Subset<T, ImportJobAggregateArgs>): Prisma.PrismaPromise<GetImportJobAggregateType<T>>

    /**
     * Group by ImportJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportJobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImportJobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImportJobGroupByArgs['orderBy'] }
        : { orderBy?: ImportJobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImportJobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImportJobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ImportJob model
   */
  readonly fields: ImportJobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ImportJob.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ImportJobClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ImportJob model
   */ 
  interface ImportJobFieldRefs {
    readonly id: FieldRef<"ImportJob", 'String'>
    readonly workspaceId: FieldRef<"ImportJob", 'String'>
    readonly accountId: FieldRef<"ImportJob", 'String'>
    readonly format: FieldRef<"ImportJob", 'String'>
    readonly fileName: FieldRef<"ImportJob", 'String'>
    readonly fileSize: FieldRef<"ImportJob", 'Int'>
    readonly fileUrl: FieldRef<"ImportJob", 'String'>
    readonly status: FieldRef<"ImportJob", 'String'>
    readonly progress: FieldRef<"ImportJob", 'Int'>
    readonly totalRows: FieldRef<"ImportJob", 'Int'>
    readonly processedRows: FieldRef<"ImportJob", 'Int'>
    readonly importedRows: FieldRef<"ImportJob", 'Int'>
    readonly errorLog: FieldRef<"ImportJob", 'String'>
    readonly mappingConfig: FieldRef<"ImportJob", 'String'>
    readonly startedAt: FieldRef<"ImportJob", 'DateTime'>
    readonly completedAt: FieldRef<"ImportJob", 'DateTime'>
    readonly createdAt: FieldRef<"ImportJob", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ImportJob findUnique
   */
  export type ImportJobFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportJob
     */
    select?: ImportJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportJobInclude<ExtArgs> | null
    /**
     * Filter, which ImportJob to fetch.
     */
    where: ImportJobWhereUniqueInput
  }

  /**
   * ImportJob findUniqueOrThrow
   */
  export type ImportJobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportJob
     */
    select?: ImportJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportJobInclude<ExtArgs> | null
    /**
     * Filter, which ImportJob to fetch.
     */
    where: ImportJobWhereUniqueInput
  }

  /**
   * ImportJob findFirst
   */
  export type ImportJobFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportJob
     */
    select?: ImportJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportJobInclude<ExtArgs> | null
    /**
     * Filter, which ImportJob to fetch.
     */
    where?: ImportJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportJobs to fetch.
     */
    orderBy?: ImportJobOrderByWithRelationInput | ImportJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImportJobs.
     */
    cursor?: ImportJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImportJobs.
     */
    distinct?: ImportJobScalarFieldEnum | ImportJobScalarFieldEnum[]
  }

  /**
   * ImportJob findFirstOrThrow
   */
  export type ImportJobFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportJob
     */
    select?: ImportJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportJobInclude<ExtArgs> | null
    /**
     * Filter, which ImportJob to fetch.
     */
    where?: ImportJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportJobs to fetch.
     */
    orderBy?: ImportJobOrderByWithRelationInput | ImportJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImportJobs.
     */
    cursor?: ImportJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImportJobs.
     */
    distinct?: ImportJobScalarFieldEnum | ImportJobScalarFieldEnum[]
  }

  /**
   * ImportJob findMany
   */
  export type ImportJobFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportJob
     */
    select?: ImportJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportJobInclude<ExtArgs> | null
    /**
     * Filter, which ImportJobs to fetch.
     */
    where?: ImportJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportJobs to fetch.
     */
    orderBy?: ImportJobOrderByWithRelationInput | ImportJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ImportJobs.
     */
    cursor?: ImportJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportJobs.
     */
    skip?: number
    distinct?: ImportJobScalarFieldEnum | ImportJobScalarFieldEnum[]
  }

  /**
   * ImportJob create
   */
  export type ImportJobCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportJob
     */
    select?: ImportJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportJobInclude<ExtArgs> | null
    /**
     * The data needed to create a ImportJob.
     */
    data: XOR<ImportJobCreateInput, ImportJobUncheckedCreateInput>
  }

  /**
   * ImportJob createMany
   */
  export type ImportJobCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ImportJobs.
     */
    data: ImportJobCreateManyInput | ImportJobCreateManyInput[]
  }

  /**
   * ImportJob createManyAndReturn
   */
  export type ImportJobCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportJob
     */
    select?: ImportJobSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ImportJobs.
     */
    data: ImportJobCreateManyInput | ImportJobCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportJobIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ImportJob update
   */
  export type ImportJobUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportJob
     */
    select?: ImportJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportJobInclude<ExtArgs> | null
    /**
     * The data needed to update a ImportJob.
     */
    data: XOR<ImportJobUpdateInput, ImportJobUncheckedUpdateInput>
    /**
     * Choose, which ImportJob to update.
     */
    where: ImportJobWhereUniqueInput
  }

  /**
   * ImportJob updateMany
   */
  export type ImportJobUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ImportJobs.
     */
    data: XOR<ImportJobUpdateManyMutationInput, ImportJobUncheckedUpdateManyInput>
    /**
     * Filter which ImportJobs to update
     */
    where?: ImportJobWhereInput
  }

  /**
   * ImportJob upsert
   */
  export type ImportJobUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportJob
     */
    select?: ImportJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportJobInclude<ExtArgs> | null
    /**
     * The filter to search for the ImportJob to update in case it exists.
     */
    where: ImportJobWhereUniqueInput
    /**
     * In case the ImportJob found by the `where` argument doesn't exist, create a new ImportJob with this data.
     */
    create: XOR<ImportJobCreateInput, ImportJobUncheckedCreateInput>
    /**
     * In case the ImportJob was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImportJobUpdateInput, ImportJobUncheckedUpdateInput>
  }

  /**
   * ImportJob delete
   */
  export type ImportJobDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportJob
     */
    select?: ImportJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportJobInclude<ExtArgs> | null
    /**
     * Filter which ImportJob to delete.
     */
    where: ImportJobWhereUniqueInput
  }

  /**
   * ImportJob deleteMany
   */
  export type ImportJobDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImportJobs to delete
     */
    where?: ImportJobWhereInput
  }

  /**
   * ImportJob without action
   */
  export type ImportJobDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportJob
     */
    select?: ImportJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportJobInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    workspaceId: string | null
    type: string | null
    title: string | null
    message: string | null
    data: string | null
    readAt: Date | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    workspaceId: string | null
    type: string | null
    title: string | null
    message: string | null
    data: string | null
    readAt: Date | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    workspaceId: number
    type: number
    title: number
    message: number
    data: number
    readAt: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    type?: true
    title?: true
    message?: true
    data?: true
    readAt?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    type?: true
    title?: true
    message?: true
    data?: true
    readAt?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    type?: true
    title?: true
    message?: true
    data?: true
    readAt?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    workspaceId: string | null
    type: string
    title: string
    message: string
    data: string | null
    readAt: Date | null
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    data?: boolean
    readAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    data?: boolean
    readAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    data?: boolean
    readAt?: boolean
    createdAt?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      workspaceId: string | null
      type: string
      title: string
      message: string
      data: string | null
      readAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly workspaceId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly data: FieldRef<"Notification", 'String'>
    readonly readAt: FieldRef<"Notification", 'DateTime'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    workspaceId: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    oldData: string | null
    newData: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    workspaceId: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    oldData: string | null
    newData: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    workspaceId: number
    action: number
    entityType: number
    entityId: number
    oldData: number
    newData: number
    ipAddress: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    action?: true
    entityType?: true
    entityId?: true
    oldData?: true
    newData?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    action?: true
    entityType?: true
    entityId?: true
    oldData?: true
    newData?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    action?: true
    entityType?: true
    entityId?: true
    oldData?: true
    newData?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string | null
    workspaceId: string | null
    action: string
    entityType: string
    entityId: string | null
    oldData: string | null
    newData: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    oldData?: boolean
    newData?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
    Workspace?: boolean | AuditLog$WorkspaceArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    oldData?: boolean
    newData?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
    Workspace?: boolean | AuditLog$WorkspaceArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    oldData?: boolean
    newData?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
    Workspace?: boolean | AuditLog$WorkspaceArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
    Workspace?: boolean | AuditLog$WorkspaceArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      Workspace: Prisma.$WorkspacePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      workspaceId: string | null
      action: string
      entityType: string
      entityId: string | null
      oldData: string | null
      newData: string | null
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends AuditLog$userArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    Workspace<T extends AuditLog$WorkspaceArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$WorkspaceArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly workspaceId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly entityType: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly oldData: FieldRef<"AuditLog", 'String'>
    readonly newData: FieldRef<"AuditLog", 'String'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog.user
   */
  export type AuditLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLog.Workspace
   */
  export type AuditLog$WorkspaceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    where?: WorkspaceWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model UserGamification
   */

  export type AggregateUserGamification = {
    _count: UserGamificationCountAggregateOutputType | null
    _avg: UserGamificationAvgAggregateOutputType | null
    _sum: UserGamificationSumAggregateOutputType | null
    _min: UserGamificationMinAggregateOutputType | null
    _max: UserGamificationMaxAggregateOutputType | null
  }

  export type UserGamificationAvgAggregateOutputType = {
    totalXP: number | null
    currentLevel: number | null
    xpToNextLevel: number | null
    loginStreak: number | null
    longestLoginStreak: number | null
    transactionStreak: number | null
    transactionsLogged: number | null
    budgetsMet: number | null
    goalsAchieved: number | null
  }

  export type UserGamificationSumAggregateOutputType = {
    totalXP: number | null
    currentLevel: number | null
    xpToNextLevel: number | null
    loginStreak: number | null
    longestLoginStreak: number | null
    transactionStreak: number | null
    transactionsLogged: number | null
    budgetsMet: number | null
    goalsAchieved: number | null
  }

  export type UserGamificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    tier: string | null
    totalXP: number | null
    currentLevel: number | null
    xpToNextLevel: number | null
    loginStreak: number | null
    longestLoginStreak: number | null
    transactionStreak: number | null
    transactionsLogged: number | null
    budgetsMet: number | null
    goalsAchieved: number | null
    lastLoginDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserGamificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    tier: string | null
    totalXP: number | null
    currentLevel: number | null
    xpToNextLevel: number | null
    loginStreak: number | null
    longestLoginStreak: number | null
    transactionStreak: number | null
    transactionsLogged: number | null
    budgetsMet: number | null
    goalsAchieved: number | null
    lastLoginDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserGamificationCountAggregateOutputType = {
    id: number
    userId: number
    tier: number
    totalXP: number
    currentLevel: number
    xpToNextLevel: number
    loginStreak: number
    longestLoginStreak: number
    transactionStreak: number
    transactionsLogged: number
    budgetsMet: number
    goalsAchieved: number
    lastLoginDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserGamificationAvgAggregateInputType = {
    totalXP?: true
    currentLevel?: true
    xpToNextLevel?: true
    loginStreak?: true
    longestLoginStreak?: true
    transactionStreak?: true
    transactionsLogged?: true
    budgetsMet?: true
    goalsAchieved?: true
  }

  export type UserGamificationSumAggregateInputType = {
    totalXP?: true
    currentLevel?: true
    xpToNextLevel?: true
    loginStreak?: true
    longestLoginStreak?: true
    transactionStreak?: true
    transactionsLogged?: true
    budgetsMet?: true
    goalsAchieved?: true
  }

  export type UserGamificationMinAggregateInputType = {
    id?: true
    userId?: true
    tier?: true
    totalXP?: true
    currentLevel?: true
    xpToNextLevel?: true
    loginStreak?: true
    longestLoginStreak?: true
    transactionStreak?: true
    transactionsLogged?: true
    budgetsMet?: true
    goalsAchieved?: true
    lastLoginDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserGamificationMaxAggregateInputType = {
    id?: true
    userId?: true
    tier?: true
    totalXP?: true
    currentLevel?: true
    xpToNextLevel?: true
    loginStreak?: true
    longestLoginStreak?: true
    transactionStreak?: true
    transactionsLogged?: true
    budgetsMet?: true
    goalsAchieved?: true
    lastLoginDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserGamificationCountAggregateInputType = {
    id?: true
    userId?: true
    tier?: true
    totalXP?: true
    currentLevel?: true
    xpToNextLevel?: true
    loginStreak?: true
    longestLoginStreak?: true
    transactionStreak?: true
    transactionsLogged?: true
    budgetsMet?: true
    goalsAchieved?: true
    lastLoginDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserGamificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserGamification to aggregate.
     */
    where?: UserGamificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserGamifications to fetch.
     */
    orderBy?: UserGamificationOrderByWithRelationInput | UserGamificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserGamificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserGamifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserGamifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserGamifications
    **/
    _count?: true | UserGamificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserGamificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserGamificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserGamificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserGamificationMaxAggregateInputType
  }

  export type GetUserGamificationAggregateType<T extends UserGamificationAggregateArgs> = {
        [P in keyof T & keyof AggregateUserGamification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserGamification[P]>
      : GetScalarType<T[P], AggregateUserGamification[P]>
  }




  export type UserGamificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserGamificationWhereInput
    orderBy?: UserGamificationOrderByWithAggregationInput | UserGamificationOrderByWithAggregationInput[]
    by: UserGamificationScalarFieldEnum[] | UserGamificationScalarFieldEnum
    having?: UserGamificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserGamificationCountAggregateInputType | true
    _avg?: UserGamificationAvgAggregateInputType
    _sum?: UserGamificationSumAggregateInputType
    _min?: UserGamificationMinAggregateInputType
    _max?: UserGamificationMaxAggregateInputType
  }

  export type UserGamificationGroupByOutputType = {
    id: string
    userId: string
    tier: string
    totalXP: number
    currentLevel: number
    xpToNextLevel: number
    loginStreak: number
    longestLoginStreak: number
    transactionStreak: number
    transactionsLogged: number
    budgetsMet: number
    goalsAchieved: number
    lastLoginDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserGamificationCountAggregateOutputType | null
    _avg: UserGamificationAvgAggregateOutputType | null
    _sum: UserGamificationSumAggregateOutputType | null
    _min: UserGamificationMinAggregateOutputType | null
    _max: UserGamificationMaxAggregateOutputType | null
  }

  type GetUserGamificationGroupByPayload<T extends UserGamificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGamificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGamificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGamificationGroupByOutputType[P]>
            : GetScalarType<T[P], UserGamificationGroupByOutputType[P]>
        }
      >
    >


  export type UserGamificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tier?: boolean
    totalXP?: boolean
    currentLevel?: boolean
    xpToNextLevel?: boolean
    loginStreak?: boolean
    longestLoginStreak?: boolean
    transactionStreak?: boolean
    transactionsLogged?: boolean
    budgetsMet?: boolean
    goalsAchieved?: boolean
    lastLoginDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    achievements?: boolean | UserGamification$achievementsArgs<ExtArgs>
    _count?: boolean | UserGamificationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userGamification"]>

  export type UserGamificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tier?: boolean
    totalXP?: boolean
    currentLevel?: boolean
    xpToNextLevel?: boolean
    loginStreak?: boolean
    longestLoginStreak?: boolean
    transactionStreak?: boolean
    transactionsLogged?: boolean
    budgetsMet?: boolean
    goalsAchieved?: boolean
    lastLoginDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userGamification"]>

  export type UserGamificationSelectScalar = {
    id?: boolean
    userId?: boolean
    tier?: boolean
    totalXP?: boolean
    currentLevel?: boolean
    xpToNextLevel?: boolean
    loginStreak?: boolean
    longestLoginStreak?: boolean
    transactionStreak?: boolean
    transactionsLogged?: boolean
    budgetsMet?: boolean
    goalsAchieved?: boolean
    lastLoginDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserGamificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    achievements?: boolean | UserGamification$achievementsArgs<ExtArgs>
    _count?: boolean | UserGamificationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserGamificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserGamificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserGamification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      achievements: Prisma.$UserAchievementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      tier: string
      totalXP: number
      currentLevel: number
      xpToNextLevel: number
      loginStreak: number
      longestLoginStreak: number
      transactionStreak: number
      transactionsLogged: number
      budgetsMet: number
      goalsAchieved: number
      lastLoginDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userGamification"]>
    composites: {}
  }

  type UserGamificationGetPayload<S extends boolean | null | undefined | UserGamificationDefaultArgs> = $Result.GetResult<Prisma.$UserGamificationPayload, S>

  type UserGamificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserGamificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserGamificationCountAggregateInputType | true
    }

  export interface UserGamificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserGamification'], meta: { name: 'UserGamification' } }
    /**
     * Find zero or one UserGamification that matches the filter.
     * @param {UserGamificationFindUniqueArgs} args - Arguments to find a UserGamification
     * @example
     * // Get one UserGamification
     * const userGamification = await prisma.userGamification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserGamificationFindUniqueArgs>(args: SelectSubset<T, UserGamificationFindUniqueArgs<ExtArgs>>): Prisma__UserGamificationClient<$Result.GetResult<Prisma.$UserGamificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserGamification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserGamificationFindUniqueOrThrowArgs} args - Arguments to find a UserGamification
     * @example
     * // Get one UserGamification
     * const userGamification = await prisma.userGamification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserGamificationFindUniqueOrThrowArgs>(args: SelectSubset<T, UserGamificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserGamificationClient<$Result.GetResult<Prisma.$UserGamificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserGamification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGamificationFindFirstArgs} args - Arguments to find a UserGamification
     * @example
     * // Get one UserGamification
     * const userGamification = await prisma.userGamification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserGamificationFindFirstArgs>(args?: SelectSubset<T, UserGamificationFindFirstArgs<ExtArgs>>): Prisma__UserGamificationClient<$Result.GetResult<Prisma.$UserGamificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserGamification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGamificationFindFirstOrThrowArgs} args - Arguments to find a UserGamification
     * @example
     * // Get one UserGamification
     * const userGamification = await prisma.userGamification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserGamificationFindFirstOrThrowArgs>(args?: SelectSubset<T, UserGamificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserGamificationClient<$Result.GetResult<Prisma.$UserGamificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserGamifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGamificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserGamifications
     * const userGamifications = await prisma.userGamification.findMany()
     * 
     * // Get first 10 UserGamifications
     * const userGamifications = await prisma.userGamification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userGamificationWithIdOnly = await prisma.userGamification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserGamificationFindManyArgs>(args?: SelectSubset<T, UserGamificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserGamificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserGamification.
     * @param {UserGamificationCreateArgs} args - Arguments to create a UserGamification.
     * @example
     * // Create one UserGamification
     * const UserGamification = await prisma.userGamification.create({
     *   data: {
     *     // ... data to create a UserGamification
     *   }
     * })
     * 
     */
    create<T extends UserGamificationCreateArgs>(args: SelectSubset<T, UserGamificationCreateArgs<ExtArgs>>): Prisma__UserGamificationClient<$Result.GetResult<Prisma.$UserGamificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserGamifications.
     * @param {UserGamificationCreateManyArgs} args - Arguments to create many UserGamifications.
     * @example
     * // Create many UserGamifications
     * const userGamification = await prisma.userGamification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserGamificationCreateManyArgs>(args?: SelectSubset<T, UserGamificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserGamifications and returns the data saved in the database.
     * @param {UserGamificationCreateManyAndReturnArgs} args - Arguments to create many UserGamifications.
     * @example
     * // Create many UserGamifications
     * const userGamification = await prisma.userGamification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserGamifications and only return the `id`
     * const userGamificationWithIdOnly = await prisma.userGamification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserGamificationCreateManyAndReturnArgs>(args?: SelectSubset<T, UserGamificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserGamificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserGamification.
     * @param {UserGamificationDeleteArgs} args - Arguments to delete one UserGamification.
     * @example
     * // Delete one UserGamification
     * const UserGamification = await prisma.userGamification.delete({
     *   where: {
     *     // ... filter to delete one UserGamification
     *   }
     * })
     * 
     */
    delete<T extends UserGamificationDeleteArgs>(args: SelectSubset<T, UserGamificationDeleteArgs<ExtArgs>>): Prisma__UserGamificationClient<$Result.GetResult<Prisma.$UserGamificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserGamification.
     * @param {UserGamificationUpdateArgs} args - Arguments to update one UserGamification.
     * @example
     * // Update one UserGamification
     * const userGamification = await prisma.userGamification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserGamificationUpdateArgs>(args: SelectSubset<T, UserGamificationUpdateArgs<ExtArgs>>): Prisma__UserGamificationClient<$Result.GetResult<Prisma.$UserGamificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserGamifications.
     * @param {UserGamificationDeleteManyArgs} args - Arguments to filter UserGamifications to delete.
     * @example
     * // Delete a few UserGamifications
     * const { count } = await prisma.userGamification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserGamificationDeleteManyArgs>(args?: SelectSubset<T, UserGamificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserGamifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGamificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserGamifications
     * const userGamification = await prisma.userGamification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserGamificationUpdateManyArgs>(args: SelectSubset<T, UserGamificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserGamification.
     * @param {UserGamificationUpsertArgs} args - Arguments to update or create a UserGamification.
     * @example
     * // Update or create a UserGamification
     * const userGamification = await prisma.userGamification.upsert({
     *   create: {
     *     // ... data to create a UserGamification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserGamification we want to update
     *   }
     * })
     */
    upsert<T extends UserGamificationUpsertArgs>(args: SelectSubset<T, UserGamificationUpsertArgs<ExtArgs>>): Prisma__UserGamificationClient<$Result.GetResult<Prisma.$UserGamificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserGamifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGamificationCountArgs} args - Arguments to filter UserGamifications to count.
     * @example
     * // Count the number of UserGamifications
     * const count = await prisma.userGamification.count({
     *   where: {
     *     // ... the filter for the UserGamifications we want to count
     *   }
     * })
    **/
    count<T extends UserGamificationCountArgs>(
      args?: Subset<T, UserGamificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserGamificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserGamification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGamificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserGamificationAggregateArgs>(args: Subset<T, UserGamificationAggregateArgs>): Prisma.PrismaPromise<GetUserGamificationAggregateType<T>>

    /**
     * Group by UserGamification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGamificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGamificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGamificationGroupByArgs['orderBy'] }
        : { orderBy?: UserGamificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGamificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGamificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserGamification model
   */
  readonly fields: UserGamificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserGamification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserGamificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    achievements<T extends UserGamification$achievementsArgs<ExtArgs> = {}>(args?: Subset<T, UserGamification$achievementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserGamification model
   */ 
  interface UserGamificationFieldRefs {
    readonly id: FieldRef<"UserGamification", 'String'>
    readonly userId: FieldRef<"UserGamification", 'String'>
    readonly tier: FieldRef<"UserGamification", 'String'>
    readonly totalXP: FieldRef<"UserGamification", 'Int'>
    readonly currentLevel: FieldRef<"UserGamification", 'Int'>
    readonly xpToNextLevel: FieldRef<"UserGamification", 'Int'>
    readonly loginStreak: FieldRef<"UserGamification", 'Int'>
    readonly longestLoginStreak: FieldRef<"UserGamification", 'Int'>
    readonly transactionStreak: FieldRef<"UserGamification", 'Int'>
    readonly transactionsLogged: FieldRef<"UserGamification", 'Int'>
    readonly budgetsMet: FieldRef<"UserGamification", 'Int'>
    readonly goalsAchieved: FieldRef<"UserGamification", 'Int'>
    readonly lastLoginDate: FieldRef<"UserGamification", 'DateTime'>
    readonly createdAt: FieldRef<"UserGamification", 'DateTime'>
    readonly updatedAt: FieldRef<"UserGamification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserGamification findUnique
   */
  export type UserGamificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGamification
     */
    select?: UserGamificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGamificationInclude<ExtArgs> | null
    /**
     * Filter, which UserGamification to fetch.
     */
    where: UserGamificationWhereUniqueInput
  }

  /**
   * UserGamification findUniqueOrThrow
   */
  export type UserGamificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGamification
     */
    select?: UserGamificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGamificationInclude<ExtArgs> | null
    /**
     * Filter, which UserGamification to fetch.
     */
    where: UserGamificationWhereUniqueInput
  }

  /**
   * UserGamification findFirst
   */
  export type UserGamificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGamification
     */
    select?: UserGamificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGamificationInclude<ExtArgs> | null
    /**
     * Filter, which UserGamification to fetch.
     */
    where?: UserGamificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserGamifications to fetch.
     */
    orderBy?: UserGamificationOrderByWithRelationInput | UserGamificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserGamifications.
     */
    cursor?: UserGamificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserGamifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserGamifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserGamifications.
     */
    distinct?: UserGamificationScalarFieldEnum | UserGamificationScalarFieldEnum[]
  }

  /**
   * UserGamification findFirstOrThrow
   */
  export type UserGamificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGamification
     */
    select?: UserGamificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGamificationInclude<ExtArgs> | null
    /**
     * Filter, which UserGamification to fetch.
     */
    where?: UserGamificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserGamifications to fetch.
     */
    orderBy?: UserGamificationOrderByWithRelationInput | UserGamificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserGamifications.
     */
    cursor?: UserGamificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserGamifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserGamifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserGamifications.
     */
    distinct?: UserGamificationScalarFieldEnum | UserGamificationScalarFieldEnum[]
  }

  /**
   * UserGamification findMany
   */
  export type UserGamificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGamification
     */
    select?: UserGamificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGamificationInclude<ExtArgs> | null
    /**
     * Filter, which UserGamifications to fetch.
     */
    where?: UserGamificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserGamifications to fetch.
     */
    orderBy?: UserGamificationOrderByWithRelationInput | UserGamificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserGamifications.
     */
    cursor?: UserGamificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserGamifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserGamifications.
     */
    skip?: number
    distinct?: UserGamificationScalarFieldEnum | UserGamificationScalarFieldEnum[]
  }

  /**
   * UserGamification create
   */
  export type UserGamificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGamification
     */
    select?: UserGamificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGamificationInclude<ExtArgs> | null
    /**
     * The data needed to create a UserGamification.
     */
    data: XOR<UserGamificationCreateInput, UserGamificationUncheckedCreateInput>
  }

  /**
   * UserGamification createMany
   */
  export type UserGamificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserGamifications.
     */
    data: UserGamificationCreateManyInput | UserGamificationCreateManyInput[]
  }

  /**
   * UserGamification createManyAndReturn
   */
  export type UserGamificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGamification
     */
    select?: UserGamificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserGamifications.
     */
    data: UserGamificationCreateManyInput | UserGamificationCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGamificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserGamification update
   */
  export type UserGamificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGamification
     */
    select?: UserGamificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGamificationInclude<ExtArgs> | null
    /**
     * The data needed to update a UserGamification.
     */
    data: XOR<UserGamificationUpdateInput, UserGamificationUncheckedUpdateInput>
    /**
     * Choose, which UserGamification to update.
     */
    where: UserGamificationWhereUniqueInput
  }

  /**
   * UserGamification updateMany
   */
  export type UserGamificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserGamifications.
     */
    data: XOR<UserGamificationUpdateManyMutationInput, UserGamificationUncheckedUpdateManyInput>
    /**
     * Filter which UserGamifications to update
     */
    where?: UserGamificationWhereInput
  }

  /**
   * UserGamification upsert
   */
  export type UserGamificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGamification
     */
    select?: UserGamificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGamificationInclude<ExtArgs> | null
    /**
     * The filter to search for the UserGamification to update in case it exists.
     */
    where: UserGamificationWhereUniqueInput
    /**
     * In case the UserGamification found by the `where` argument doesn't exist, create a new UserGamification with this data.
     */
    create: XOR<UserGamificationCreateInput, UserGamificationUncheckedCreateInput>
    /**
     * In case the UserGamification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserGamificationUpdateInput, UserGamificationUncheckedUpdateInput>
  }

  /**
   * UserGamification delete
   */
  export type UserGamificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGamification
     */
    select?: UserGamificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGamificationInclude<ExtArgs> | null
    /**
     * Filter which UserGamification to delete.
     */
    where: UserGamificationWhereUniqueInput
  }

  /**
   * UserGamification deleteMany
   */
  export type UserGamificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserGamifications to delete
     */
    where?: UserGamificationWhereInput
  }

  /**
   * UserGamification.achievements
   */
  export type UserGamification$achievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    where?: UserAchievementWhereInput
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    cursor?: UserAchievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * UserGamification without action
   */
  export type UserGamificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGamification
     */
    select?: UserGamificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGamificationInclude<ExtArgs> | null
  }


  /**
   * Model Achievement
   */

  export type AggregateAchievement = {
    _count: AchievementCountAggregateOutputType | null
    _avg: AchievementAvgAggregateOutputType | null
    _sum: AchievementSumAggregateOutputType | null
    _min: AchievementMinAggregateOutputType | null
    _max: AchievementMaxAggregateOutputType | null
  }

  export type AchievementAvgAggregateOutputType = {
    xpReward: number | null
    requirementValue: number | null
  }

  export type AchievementSumAggregateOutputType = {
    xpReward: number | null
    requirementValue: number | null
  }

  export type AchievementMinAggregateOutputType = {
    id: string | null
    type: string | null
    name: string | null
    description: string | null
    icon: string | null
    color: string | null
    xpReward: number | null
    requirementType: string | null
    requirementValue: number | null
    createdAt: Date | null
  }

  export type AchievementMaxAggregateOutputType = {
    id: string | null
    type: string | null
    name: string | null
    description: string | null
    icon: string | null
    color: string | null
    xpReward: number | null
    requirementType: string | null
    requirementValue: number | null
    createdAt: Date | null
  }

  export type AchievementCountAggregateOutputType = {
    id: number
    type: number
    name: number
    description: number
    icon: number
    color: number
    xpReward: number
    requirementType: number
    requirementValue: number
    createdAt: number
    _all: number
  }


  export type AchievementAvgAggregateInputType = {
    xpReward?: true
    requirementValue?: true
  }

  export type AchievementSumAggregateInputType = {
    xpReward?: true
    requirementValue?: true
  }

  export type AchievementMinAggregateInputType = {
    id?: true
    type?: true
    name?: true
    description?: true
    icon?: true
    color?: true
    xpReward?: true
    requirementType?: true
    requirementValue?: true
    createdAt?: true
  }

  export type AchievementMaxAggregateInputType = {
    id?: true
    type?: true
    name?: true
    description?: true
    icon?: true
    color?: true
    xpReward?: true
    requirementType?: true
    requirementValue?: true
    createdAt?: true
  }

  export type AchievementCountAggregateInputType = {
    id?: true
    type?: true
    name?: true
    description?: true
    icon?: true
    color?: true
    xpReward?: true
    requirementType?: true
    requirementValue?: true
    createdAt?: true
    _all?: true
  }

  export type AchievementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Achievement to aggregate.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Achievements
    **/
    _count?: true | AchievementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AchievementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AchievementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AchievementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AchievementMaxAggregateInputType
  }

  export type GetAchievementAggregateType<T extends AchievementAggregateArgs> = {
        [P in keyof T & keyof AggregateAchievement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAchievement[P]>
      : GetScalarType<T[P], AggregateAchievement[P]>
  }




  export type AchievementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchievementWhereInput
    orderBy?: AchievementOrderByWithAggregationInput | AchievementOrderByWithAggregationInput[]
    by: AchievementScalarFieldEnum[] | AchievementScalarFieldEnum
    having?: AchievementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AchievementCountAggregateInputType | true
    _avg?: AchievementAvgAggregateInputType
    _sum?: AchievementSumAggregateInputType
    _min?: AchievementMinAggregateInputType
    _max?: AchievementMaxAggregateInputType
  }

  export type AchievementGroupByOutputType = {
    id: string
    type: string
    name: string
    description: string
    icon: string
    color: string
    xpReward: number
    requirementType: string
    requirementValue: number
    createdAt: Date
    _count: AchievementCountAggregateOutputType | null
    _avg: AchievementAvgAggregateOutputType | null
    _sum: AchievementSumAggregateOutputType | null
    _min: AchievementMinAggregateOutputType | null
    _max: AchievementMaxAggregateOutputType | null
  }

  type GetAchievementGroupByPayload<T extends AchievementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AchievementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AchievementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AchievementGroupByOutputType[P]>
            : GetScalarType<T[P], AchievementGroupByOutputType[P]>
        }
      >
    >


  export type AchievementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    color?: boolean
    xpReward?: boolean
    requirementType?: boolean
    requirementValue?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    color?: boolean
    xpReward?: boolean
    requirementType?: boolean
    requirementValue?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectScalar = {
    id?: boolean
    type?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    color?: boolean
    xpReward?: boolean
    requirementType?: boolean
    requirementValue?: boolean
    createdAt?: boolean
  }


  export type $AchievementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Achievement"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      name: string
      description: string
      icon: string
      color: string
      xpReward: number
      requirementType: string
      requirementValue: number
      createdAt: Date
    }, ExtArgs["result"]["achievement"]>
    composites: {}
  }

  type AchievementGetPayload<S extends boolean | null | undefined | AchievementDefaultArgs> = $Result.GetResult<Prisma.$AchievementPayload, S>

  type AchievementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AchievementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AchievementCountAggregateInputType | true
    }

  export interface AchievementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Achievement'], meta: { name: 'Achievement' } }
    /**
     * Find zero or one Achievement that matches the filter.
     * @param {AchievementFindUniqueArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AchievementFindUniqueArgs>(args: SelectSubset<T, AchievementFindUniqueArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Achievement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AchievementFindUniqueOrThrowArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AchievementFindUniqueOrThrowArgs>(args: SelectSubset<T, AchievementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Achievement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindFirstArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AchievementFindFirstArgs>(args?: SelectSubset<T, AchievementFindFirstArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Achievement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindFirstOrThrowArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AchievementFindFirstOrThrowArgs>(args?: SelectSubset<T, AchievementFindFirstOrThrowArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Achievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Achievements
     * const achievements = await prisma.achievement.findMany()
     * 
     * // Get first 10 Achievements
     * const achievements = await prisma.achievement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const achievementWithIdOnly = await prisma.achievement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AchievementFindManyArgs>(args?: SelectSubset<T, AchievementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Achievement.
     * @param {AchievementCreateArgs} args - Arguments to create a Achievement.
     * @example
     * // Create one Achievement
     * const Achievement = await prisma.achievement.create({
     *   data: {
     *     // ... data to create a Achievement
     *   }
     * })
     * 
     */
    create<T extends AchievementCreateArgs>(args: SelectSubset<T, AchievementCreateArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Achievements.
     * @param {AchievementCreateManyArgs} args - Arguments to create many Achievements.
     * @example
     * // Create many Achievements
     * const achievement = await prisma.achievement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AchievementCreateManyArgs>(args?: SelectSubset<T, AchievementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Achievements and returns the data saved in the database.
     * @param {AchievementCreateManyAndReturnArgs} args - Arguments to create many Achievements.
     * @example
     * // Create many Achievements
     * const achievement = await prisma.achievement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Achievements and only return the `id`
     * const achievementWithIdOnly = await prisma.achievement.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AchievementCreateManyAndReturnArgs>(args?: SelectSubset<T, AchievementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Achievement.
     * @param {AchievementDeleteArgs} args - Arguments to delete one Achievement.
     * @example
     * // Delete one Achievement
     * const Achievement = await prisma.achievement.delete({
     *   where: {
     *     // ... filter to delete one Achievement
     *   }
     * })
     * 
     */
    delete<T extends AchievementDeleteArgs>(args: SelectSubset<T, AchievementDeleteArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Achievement.
     * @param {AchievementUpdateArgs} args - Arguments to update one Achievement.
     * @example
     * // Update one Achievement
     * const achievement = await prisma.achievement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AchievementUpdateArgs>(args: SelectSubset<T, AchievementUpdateArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Achievements.
     * @param {AchievementDeleteManyArgs} args - Arguments to filter Achievements to delete.
     * @example
     * // Delete a few Achievements
     * const { count } = await prisma.achievement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AchievementDeleteManyArgs>(args?: SelectSubset<T, AchievementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Achievements
     * const achievement = await prisma.achievement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AchievementUpdateManyArgs>(args: SelectSubset<T, AchievementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Achievement.
     * @param {AchievementUpsertArgs} args - Arguments to update or create a Achievement.
     * @example
     * // Update or create a Achievement
     * const achievement = await prisma.achievement.upsert({
     *   create: {
     *     // ... data to create a Achievement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Achievement we want to update
     *   }
     * })
     */
    upsert<T extends AchievementUpsertArgs>(args: SelectSubset<T, AchievementUpsertArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementCountArgs} args - Arguments to filter Achievements to count.
     * @example
     * // Count the number of Achievements
     * const count = await prisma.achievement.count({
     *   where: {
     *     // ... the filter for the Achievements we want to count
     *   }
     * })
    **/
    count<T extends AchievementCountArgs>(
      args?: Subset<T, AchievementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AchievementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Achievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AchievementAggregateArgs>(args: Subset<T, AchievementAggregateArgs>): Prisma.PrismaPromise<GetAchievementAggregateType<T>>

    /**
     * Group by Achievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AchievementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AchievementGroupByArgs['orderBy'] }
        : { orderBy?: AchievementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AchievementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAchievementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Achievement model
   */
  readonly fields: AchievementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Achievement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AchievementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Achievement model
   */ 
  interface AchievementFieldRefs {
    readonly id: FieldRef<"Achievement", 'String'>
    readonly type: FieldRef<"Achievement", 'String'>
    readonly name: FieldRef<"Achievement", 'String'>
    readonly description: FieldRef<"Achievement", 'String'>
    readonly icon: FieldRef<"Achievement", 'String'>
    readonly color: FieldRef<"Achievement", 'String'>
    readonly xpReward: FieldRef<"Achievement", 'Int'>
    readonly requirementType: FieldRef<"Achievement", 'String'>
    readonly requirementValue: FieldRef<"Achievement", 'Int'>
    readonly createdAt: FieldRef<"Achievement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Achievement findUnique
   */
  export type AchievementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement findUniqueOrThrow
   */
  export type AchievementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement findFirst
   */
  export type AchievementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Achievements.
     */
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement findFirstOrThrow
   */
  export type AchievementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Achievements.
     */
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement findMany
   */
  export type AchievementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Filter, which Achievements to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement create
   */
  export type AchievementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * The data needed to create a Achievement.
     */
    data: XOR<AchievementCreateInput, AchievementUncheckedCreateInput>
  }

  /**
   * Achievement createMany
   */
  export type AchievementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Achievements.
     */
    data: AchievementCreateManyInput | AchievementCreateManyInput[]
  }

  /**
   * Achievement createManyAndReturn
   */
  export type AchievementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Achievements.
     */
    data: AchievementCreateManyInput | AchievementCreateManyInput[]
  }

  /**
   * Achievement update
   */
  export type AchievementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * The data needed to update a Achievement.
     */
    data: XOR<AchievementUpdateInput, AchievementUncheckedUpdateInput>
    /**
     * Choose, which Achievement to update.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement updateMany
   */
  export type AchievementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Achievements.
     */
    data: XOR<AchievementUpdateManyMutationInput, AchievementUncheckedUpdateManyInput>
    /**
     * Filter which Achievements to update
     */
    where?: AchievementWhereInput
  }

  /**
   * Achievement upsert
   */
  export type AchievementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * The filter to search for the Achievement to update in case it exists.
     */
    where: AchievementWhereUniqueInput
    /**
     * In case the Achievement found by the `where` argument doesn't exist, create a new Achievement with this data.
     */
    create: XOR<AchievementCreateInput, AchievementUncheckedCreateInput>
    /**
     * In case the Achievement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AchievementUpdateInput, AchievementUncheckedUpdateInput>
  }

  /**
   * Achievement delete
   */
  export type AchievementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Filter which Achievement to delete.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement deleteMany
   */
  export type AchievementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Achievements to delete
     */
    where?: AchievementWhereInput
  }

  /**
   * Achievement without action
   */
  export type AchievementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
  }


  /**
   * Model UserAchievement
   */

  export type AggregateUserAchievement = {
    _count: UserAchievementCountAggregateOutputType | null
    _min: UserAchievementMinAggregateOutputType | null
    _max: UserAchievementMaxAggregateOutputType | null
  }

  export type UserAchievementMinAggregateOutputType = {
    id: string | null
    userGamificationId: string | null
    achievementId: string | null
    unlockedAt: Date | null
  }

  export type UserAchievementMaxAggregateOutputType = {
    id: string | null
    userGamificationId: string | null
    achievementId: string | null
    unlockedAt: Date | null
  }

  export type UserAchievementCountAggregateOutputType = {
    id: number
    userGamificationId: number
    achievementId: number
    unlockedAt: number
    _all: number
  }


  export type UserAchievementMinAggregateInputType = {
    id?: true
    userGamificationId?: true
    achievementId?: true
    unlockedAt?: true
  }

  export type UserAchievementMaxAggregateInputType = {
    id?: true
    userGamificationId?: true
    achievementId?: true
    unlockedAt?: true
  }

  export type UserAchievementCountAggregateInputType = {
    id?: true
    userGamificationId?: true
    achievementId?: true
    unlockedAt?: true
    _all?: true
  }

  export type UserAchievementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAchievement to aggregate.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAchievements
    **/
    _count?: true | UserAchievementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAchievementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAchievementMaxAggregateInputType
  }

  export type GetUserAchievementAggregateType<T extends UserAchievementAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAchievement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAchievement[P]>
      : GetScalarType<T[P], AggregateUserAchievement[P]>
  }




  export type UserAchievementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAchievementWhereInput
    orderBy?: UserAchievementOrderByWithAggregationInput | UserAchievementOrderByWithAggregationInput[]
    by: UserAchievementScalarFieldEnum[] | UserAchievementScalarFieldEnum
    having?: UserAchievementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAchievementCountAggregateInputType | true
    _min?: UserAchievementMinAggregateInputType
    _max?: UserAchievementMaxAggregateInputType
  }

  export type UserAchievementGroupByOutputType = {
    id: string
    userGamificationId: string
    achievementId: string
    unlockedAt: Date
    _count: UserAchievementCountAggregateOutputType | null
    _min: UserAchievementMinAggregateOutputType | null
    _max: UserAchievementMaxAggregateOutputType | null
  }

  type GetUserAchievementGroupByPayload<T extends UserAchievementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserAchievementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAchievementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAchievementGroupByOutputType[P]>
            : GetScalarType<T[P], UserAchievementGroupByOutputType[P]>
        }
      >
    >


  export type UserAchievementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userGamificationId?: boolean
    achievementId?: boolean
    unlockedAt?: boolean
    UserGamification?: boolean | UserGamificationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAchievement"]>

  export type UserAchievementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userGamificationId?: boolean
    achievementId?: boolean
    unlockedAt?: boolean
    UserGamification?: boolean | UserGamificationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAchievement"]>

  export type UserAchievementSelectScalar = {
    id?: boolean
    userGamificationId?: boolean
    achievementId?: boolean
    unlockedAt?: boolean
  }

  export type UserAchievementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    UserGamification?: boolean | UserGamificationDefaultArgs<ExtArgs>
  }
  export type UserAchievementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    UserGamification?: boolean | UserGamificationDefaultArgs<ExtArgs>
  }

  export type $UserAchievementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserAchievement"
    objects: {
      UserGamification: Prisma.$UserGamificationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userGamificationId: string
      achievementId: string
      unlockedAt: Date
    }, ExtArgs["result"]["userAchievement"]>
    composites: {}
  }

  type UserAchievementGetPayload<S extends boolean | null | undefined | UserAchievementDefaultArgs> = $Result.GetResult<Prisma.$UserAchievementPayload, S>

  type UserAchievementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserAchievementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserAchievementCountAggregateInputType | true
    }

  export interface UserAchievementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAchievement'], meta: { name: 'UserAchievement' } }
    /**
     * Find zero or one UserAchievement that matches the filter.
     * @param {UserAchievementFindUniqueArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserAchievementFindUniqueArgs>(args: SelectSubset<T, UserAchievementFindUniqueArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserAchievement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserAchievementFindUniqueOrThrowArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserAchievementFindUniqueOrThrowArgs>(args: SelectSubset<T, UserAchievementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserAchievement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementFindFirstArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserAchievementFindFirstArgs>(args?: SelectSubset<T, UserAchievementFindFirstArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserAchievement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementFindFirstOrThrowArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserAchievementFindFirstOrThrowArgs>(args?: SelectSubset<T, UserAchievementFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserAchievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAchievements
     * const userAchievements = await prisma.userAchievement.findMany()
     * 
     * // Get first 10 UserAchievements
     * const userAchievements = await prisma.userAchievement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userAchievementWithIdOnly = await prisma.userAchievement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserAchievementFindManyArgs>(args?: SelectSubset<T, UserAchievementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserAchievement.
     * @param {UserAchievementCreateArgs} args - Arguments to create a UserAchievement.
     * @example
     * // Create one UserAchievement
     * const UserAchievement = await prisma.userAchievement.create({
     *   data: {
     *     // ... data to create a UserAchievement
     *   }
     * })
     * 
     */
    create<T extends UserAchievementCreateArgs>(args: SelectSubset<T, UserAchievementCreateArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserAchievements.
     * @param {UserAchievementCreateManyArgs} args - Arguments to create many UserAchievements.
     * @example
     * // Create many UserAchievements
     * const userAchievement = await prisma.userAchievement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserAchievementCreateManyArgs>(args?: SelectSubset<T, UserAchievementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserAchievements and returns the data saved in the database.
     * @param {UserAchievementCreateManyAndReturnArgs} args - Arguments to create many UserAchievements.
     * @example
     * // Create many UserAchievements
     * const userAchievement = await prisma.userAchievement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserAchievements and only return the `id`
     * const userAchievementWithIdOnly = await prisma.userAchievement.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserAchievementCreateManyAndReturnArgs>(args?: SelectSubset<T, UserAchievementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserAchievement.
     * @param {UserAchievementDeleteArgs} args - Arguments to delete one UserAchievement.
     * @example
     * // Delete one UserAchievement
     * const UserAchievement = await prisma.userAchievement.delete({
     *   where: {
     *     // ... filter to delete one UserAchievement
     *   }
     * })
     * 
     */
    delete<T extends UserAchievementDeleteArgs>(args: SelectSubset<T, UserAchievementDeleteArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserAchievement.
     * @param {UserAchievementUpdateArgs} args - Arguments to update one UserAchievement.
     * @example
     * // Update one UserAchievement
     * const userAchievement = await prisma.userAchievement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserAchievementUpdateArgs>(args: SelectSubset<T, UserAchievementUpdateArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserAchievements.
     * @param {UserAchievementDeleteManyArgs} args - Arguments to filter UserAchievements to delete.
     * @example
     * // Delete a few UserAchievements
     * const { count } = await prisma.userAchievement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserAchievementDeleteManyArgs>(args?: SelectSubset<T, UserAchievementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAchievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAchievements
     * const userAchievement = await prisma.userAchievement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserAchievementUpdateManyArgs>(args: SelectSubset<T, UserAchievementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserAchievement.
     * @param {UserAchievementUpsertArgs} args - Arguments to update or create a UserAchievement.
     * @example
     * // Update or create a UserAchievement
     * const userAchievement = await prisma.userAchievement.upsert({
     *   create: {
     *     // ... data to create a UserAchievement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAchievement we want to update
     *   }
     * })
     */
    upsert<T extends UserAchievementUpsertArgs>(args: SelectSubset<T, UserAchievementUpsertArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserAchievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementCountArgs} args - Arguments to filter UserAchievements to count.
     * @example
     * // Count the number of UserAchievements
     * const count = await prisma.userAchievement.count({
     *   where: {
     *     // ... the filter for the UserAchievements we want to count
     *   }
     * })
    **/
    count<T extends UserAchievementCountArgs>(
      args?: Subset<T, UserAchievementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAchievementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAchievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAchievementAggregateArgs>(args: Subset<T, UserAchievementAggregateArgs>): Prisma.PrismaPromise<GetUserAchievementAggregateType<T>>

    /**
     * Group by UserAchievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAchievementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAchievementGroupByArgs['orderBy'] }
        : { orderBy?: UserAchievementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAchievementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAchievementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserAchievement model
   */
  readonly fields: UserAchievementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAchievement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAchievementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    UserGamification<T extends UserGamificationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserGamificationDefaultArgs<ExtArgs>>): Prisma__UserGamificationClient<$Result.GetResult<Prisma.$UserGamificationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserAchievement model
   */ 
  interface UserAchievementFieldRefs {
    readonly id: FieldRef<"UserAchievement", 'String'>
    readonly userGamificationId: FieldRef<"UserAchievement", 'String'>
    readonly achievementId: FieldRef<"UserAchievement", 'String'>
    readonly unlockedAt: FieldRef<"UserAchievement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserAchievement findUnique
   */
  export type UserAchievementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement findUniqueOrThrow
   */
  export type UserAchievementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement findFirst
   */
  export type UserAchievementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAchievements.
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAchievements.
     */
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * UserAchievement findFirstOrThrow
   */
  export type UserAchievementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAchievements.
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAchievements.
     */
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * UserAchievement findMany
   */
  export type UserAchievementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievements to fetch.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAchievements.
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * UserAchievement create
   */
  export type UserAchievementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * The data needed to create a UserAchievement.
     */
    data: XOR<UserAchievementCreateInput, UserAchievementUncheckedCreateInput>
  }

  /**
   * UserAchievement createMany
   */
  export type UserAchievementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAchievements.
     */
    data: UserAchievementCreateManyInput | UserAchievementCreateManyInput[]
  }

  /**
   * UserAchievement createManyAndReturn
   */
  export type UserAchievementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserAchievements.
     */
    data: UserAchievementCreateManyInput | UserAchievementCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAchievement update
   */
  export type UserAchievementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * The data needed to update a UserAchievement.
     */
    data: XOR<UserAchievementUpdateInput, UserAchievementUncheckedUpdateInput>
    /**
     * Choose, which UserAchievement to update.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement updateMany
   */
  export type UserAchievementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAchievements.
     */
    data: XOR<UserAchievementUpdateManyMutationInput, UserAchievementUncheckedUpdateManyInput>
    /**
     * Filter which UserAchievements to update
     */
    where?: UserAchievementWhereInput
  }

  /**
   * UserAchievement upsert
   */
  export type UserAchievementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * The filter to search for the UserAchievement to update in case it exists.
     */
    where: UserAchievementWhereUniqueInput
    /**
     * In case the UserAchievement found by the `where` argument doesn't exist, create a new UserAchievement with this data.
     */
    create: XOR<UserAchievementCreateInput, UserAchievementUncheckedCreateInput>
    /**
     * In case the UserAchievement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAchievementUpdateInput, UserAchievementUncheckedUpdateInput>
  }

  /**
   * UserAchievement delete
   */
  export type UserAchievementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter which UserAchievement to delete.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement deleteMany
   */
  export type UserAchievementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAchievements to delete
     */
    where?: UserAchievementWhereInput
  }

  /**
   * UserAchievement without action
   */
  export type UserAchievementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
  }


  /**
   * Model Envelope
   */

  export type AggregateEnvelope = {
    _count: EnvelopeCountAggregateOutputType | null
    _avg: EnvelopeAvgAggregateOutputType | null
    _sum: EnvelopeSumAggregateOutputType | null
    _min: EnvelopeMinAggregateOutputType | null
    _max: EnvelopeMaxAggregateOutputType | null
  }

  export type EnvelopeAvgAggregateOutputType = {
    budgetedAmount: number | null
    availableAmount: number | null
    spentAmount: number | null
    month: number | null
    year: number | null
  }

  export type EnvelopeSumAggregateOutputType = {
    budgetedAmount: number | null
    availableAmount: number | null
    spentAmount: number | null
    month: number | null
    year: number | null
  }

  export type EnvelopeMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    categoryId: string | null
    name: string | null
    description: string | null
    color: string | null
    budgetedAmount: number | null
    availableAmount: number | null
    spentAmount: number | null
    month: number | null
    year: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EnvelopeMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    categoryId: string | null
    name: string | null
    description: string | null
    color: string | null
    budgetedAmount: number | null
    availableAmount: number | null
    spentAmount: number | null
    month: number | null
    year: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EnvelopeCountAggregateOutputType = {
    id: number
    workspaceId: number
    categoryId: number
    name: number
    description: number
    color: number
    budgetedAmount: number
    availableAmount: number
    spentAmount: number
    month: number
    year: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EnvelopeAvgAggregateInputType = {
    budgetedAmount?: true
    availableAmount?: true
    spentAmount?: true
    month?: true
    year?: true
  }

  export type EnvelopeSumAggregateInputType = {
    budgetedAmount?: true
    availableAmount?: true
    spentAmount?: true
    month?: true
    year?: true
  }

  export type EnvelopeMinAggregateInputType = {
    id?: true
    workspaceId?: true
    categoryId?: true
    name?: true
    description?: true
    color?: true
    budgetedAmount?: true
    availableAmount?: true
    spentAmount?: true
    month?: true
    year?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EnvelopeMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    categoryId?: true
    name?: true
    description?: true
    color?: true
    budgetedAmount?: true
    availableAmount?: true
    spentAmount?: true
    month?: true
    year?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EnvelopeCountAggregateInputType = {
    id?: true
    workspaceId?: true
    categoryId?: true
    name?: true
    description?: true
    color?: true
    budgetedAmount?: true
    availableAmount?: true
    spentAmount?: true
    month?: true
    year?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EnvelopeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Envelope to aggregate.
     */
    where?: EnvelopeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Envelopes to fetch.
     */
    orderBy?: EnvelopeOrderByWithRelationInput | EnvelopeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EnvelopeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Envelopes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Envelopes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Envelopes
    **/
    _count?: true | EnvelopeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EnvelopeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EnvelopeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnvelopeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnvelopeMaxAggregateInputType
  }

  export type GetEnvelopeAggregateType<T extends EnvelopeAggregateArgs> = {
        [P in keyof T & keyof AggregateEnvelope]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEnvelope[P]>
      : GetScalarType<T[P], AggregateEnvelope[P]>
  }




  export type EnvelopeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnvelopeWhereInput
    orderBy?: EnvelopeOrderByWithAggregationInput | EnvelopeOrderByWithAggregationInput[]
    by: EnvelopeScalarFieldEnum[] | EnvelopeScalarFieldEnum
    having?: EnvelopeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnvelopeCountAggregateInputType | true
    _avg?: EnvelopeAvgAggregateInputType
    _sum?: EnvelopeSumAggregateInputType
    _min?: EnvelopeMinAggregateInputType
    _max?: EnvelopeMaxAggregateInputType
  }

  export type EnvelopeGroupByOutputType = {
    id: string
    workspaceId: string
    categoryId: string | null
    name: string
    description: string | null
    color: string
    budgetedAmount: number
    availableAmount: number
    spentAmount: number
    month: number
    year: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: EnvelopeCountAggregateOutputType | null
    _avg: EnvelopeAvgAggregateOutputType | null
    _sum: EnvelopeSumAggregateOutputType | null
    _min: EnvelopeMinAggregateOutputType | null
    _max: EnvelopeMaxAggregateOutputType | null
  }

  type GetEnvelopeGroupByPayload<T extends EnvelopeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EnvelopeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnvelopeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnvelopeGroupByOutputType[P]>
            : GetScalarType<T[P], EnvelopeGroupByOutputType[P]>
        }
      >
    >


  export type EnvelopeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    categoryId?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    budgetedAmount?: boolean
    availableAmount?: boolean
    spentAmount?: boolean
    month?: boolean
    year?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    Category?: boolean | Envelope$CategoryArgs<ExtArgs>
  }, ExtArgs["result"]["envelope"]>

  export type EnvelopeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    categoryId?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    budgetedAmount?: boolean
    availableAmount?: boolean
    spentAmount?: boolean
    month?: boolean
    year?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    Category?: boolean | Envelope$CategoryArgs<ExtArgs>
  }, ExtArgs["result"]["envelope"]>

  export type EnvelopeSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    categoryId?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    budgetedAmount?: boolean
    availableAmount?: boolean
    spentAmount?: boolean
    month?: boolean
    year?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EnvelopeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    Category?: boolean | Envelope$CategoryArgs<ExtArgs>
  }
  export type EnvelopeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    Category?: boolean | Envelope$CategoryArgs<ExtArgs>
  }

  export type $EnvelopePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Envelope"
    objects: {
      Workspace: Prisma.$WorkspacePayload<ExtArgs>
      Category: Prisma.$CategoryPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      categoryId: string | null
      name: string
      description: string | null
      color: string
      budgetedAmount: number
      availableAmount: number
      spentAmount: number
      month: number
      year: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["envelope"]>
    composites: {}
  }

  type EnvelopeGetPayload<S extends boolean | null | undefined | EnvelopeDefaultArgs> = $Result.GetResult<Prisma.$EnvelopePayload, S>

  type EnvelopeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EnvelopeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EnvelopeCountAggregateInputType | true
    }

  export interface EnvelopeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Envelope'], meta: { name: 'Envelope' } }
    /**
     * Find zero or one Envelope that matches the filter.
     * @param {EnvelopeFindUniqueArgs} args - Arguments to find a Envelope
     * @example
     * // Get one Envelope
     * const envelope = await prisma.envelope.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EnvelopeFindUniqueArgs>(args: SelectSubset<T, EnvelopeFindUniqueArgs<ExtArgs>>): Prisma__EnvelopeClient<$Result.GetResult<Prisma.$EnvelopePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Envelope that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EnvelopeFindUniqueOrThrowArgs} args - Arguments to find a Envelope
     * @example
     * // Get one Envelope
     * const envelope = await prisma.envelope.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EnvelopeFindUniqueOrThrowArgs>(args: SelectSubset<T, EnvelopeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EnvelopeClient<$Result.GetResult<Prisma.$EnvelopePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Envelope that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvelopeFindFirstArgs} args - Arguments to find a Envelope
     * @example
     * // Get one Envelope
     * const envelope = await prisma.envelope.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EnvelopeFindFirstArgs>(args?: SelectSubset<T, EnvelopeFindFirstArgs<ExtArgs>>): Prisma__EnvelopeClient<$Result.GetResult<Prisma.$EnvelopePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Envelope that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvelopeFindFirstOrThrowArgs} args - Arguments to find a Envelope
     * @example
     * // Get one Envelope
     * const envelope = await prisma.envelope.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EnvelopeFindFirstOrThrowArgs>(args?: SelectSubset<T, EnvelopeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EnvelopeClient<$Result.GetResult<Prisma.$EnvelopePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Envelopes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvelopeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Envelopes
     * const envelopes = await prisma.envelope.findMany()
     * 
     * // Get first 10 Envelopes
     * const envelopes = await prisma.envelope.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const envelopeWithIdOnly = await prisma.envelope.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EnvelopeFindManyArgs>(args?: SelectSubset<T, EnvelopeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnvelopePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Envelope.
     * @param {EnvelopeCreateArgs} args - Arguments to create a Envelope.
     * @example
     * // Create one Envelope
     * const Envelope = await prisma.envelope.create({
     *   data: {
     *     // ... data to create a Envelope
     *   }
     * })
     * 
     */
    create<T extends EnvelopeCreateArgs>(args: SelectSubset<T, EnvelopeCreateArgs<ExtArgs>>): Prisma__EnvelopeClient<$Result.GetResult<Prisma.$EnvelopePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Envelopes.
     * @param {EnvelopeCreateManyArgs} args - Arguments to create many Envelopes.
     * @example
     * // Create many Envelopes
     * const envelope = await prisma.envelope.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EnvelopeCreateManyArgs>(args?: SelectSubset<T, EnvelopeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Envelopes and returns the data saved in the database.
     * @param {EnvelopeCreateManyAndReturnArgs} args - Arguments to create many Envelopes.
     * @example
     * // Create many Envelopes
     * const envelope = await prisma.envelope.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Envelopes and only return the `id`
     * const envelopeWithIdOnly = await prisma.envelope.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EnvelopeCreateManyAndReturnArgs>(args?: SelectSubset<T, EnvelopeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnvelopePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Envelope.
     * @param {EnvelopeDeleteArgs} args - Arguments to delete one Envelope.
     * @example
     * // Delete one Envelope
     * const Envelope = await prisma.envelope.delete({
     *   where: {
     *     // ... filter to delete one Envelope
     *   }
     * })
     * 
     */
    delete<T extends EnvelopeDeleteArgs>(args: SelectSubset<T, EnvelopeDeleteArgs<ExtArgs>>): Prisma__EnvelopeClient<$Result.GetResult<Prisma.$EnvelopePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Envelope.
     * @param {EnvelopeUpdateArgs} args - Arguments to update one Envelope.
     * @example
     * // Update one Envelope
     * const envelope = await prisma.envelope.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EnvelopeUpdateArgs>(args: SelectSubset<T, EnvelopeUpdateArgs<ExtArgs>>): Prisma__EnvelopeClient<$Result.GetResult<Prisma.$EnvelopePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Envelopes.
     * @param {EnvelopeDeleteManyArgs} args - Arguments to filter Envelopes to delete.
     * @example
     * // Delete a few Envelopes
     * const { count } = await prisma.envelope.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EnvelopeDeleteManyArgs>(args?: SelectSubset<T, EnvelopeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Envelopes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvelopeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Envelopes
     * const envelope = await prisma.envelope.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EnvelopeUpdateManyArgs>(args: SelectSubset<T, EnvelopeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Envelope.
     * @param {EnvelopeUpsertArgs} args - Arguments to update or create a Envelope.
     * @example
     * // Update or create a Envelope
     * const envelope = await prisma.envelope.upsert({
     *   create: {
     *     // ... data to create a Envelope
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Envelope we want to update
     *   }
     * })
     */
    upsert<T extends EnvelopeUpsertArgs>(args: SelectSubset<T, EnvelopeUpsertArgs<ExtArgs>>): Prisma__EnvelopeClient<$Result.GetResult<Prisma.$EnvelopePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Envelopes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvelopeCountArgs} args - Arguments to filter Envelopes to count.
     * @example
     * // Count the number of Envelopes
     * const count = await prisma.envelope.count({
     *   where: {
     *     // ... the filter for the Envelopes we want to count
     *   }
     * })
    **/
    count<T extends EnvelopeCountArgs>(
      args?: Subset<T, EnvelopeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnvelopeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Envelope.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvelopeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnvelopeAggregateArgs>(args: Subset<T, EnvelopeAggregateArgs>): Prisma.PrismaPromise<GetEnvelopeAggregateType<T>>

    /**
     * Group by Envelope.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvelopeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EnvelopeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EnvelopeGroupByArgs['orderBy'] }
        : { orderBy?: EnvelopeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EnvelopeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnvelopeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Envelope model
   */
  readonly fields: EnvelopeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Envelope.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EnvelopeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Category<T extends Envelope$CategoryArgs<ExtArgs> = {}>(args?: Subset<T, Envelope$CategoryArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Envelope model
   */ 
  interface EnvelopeFieldRefs {
    readonly id: FieldRef<"Envelope", 'String'>
    readonly workspaceId: FieldRef<"Envelope", 'String'>
    readonly categoryId: FieldRef<"Envelope", 'String'>
    readonly name: FieldRef<"Envelope", 'String'>
    readonly description: FieldRef<"Envelope", 'String'>
    readonly color: FieldRef<"Envelope", 'String'>
    readonly budgetedAmount: FieldRef<"Envelope", 'Float'>
    readonly availableAmount: FieldRef<"Envelope", 'Float'>
    readonly spentAmount: FieldRef<"Envelope", 'Float'>
    readonly month: FieldRef<"Envelope", 'Int'>
    readonly year: FieldRef<"Envelope", 'Int'>
    readonly isActive: FieldRef<"Envelope", 'Boolean'>
    readonly createdAt: FieldRef<"Envelope", 'DateTime'>
    readonly updatedAt: FieldRef<"Envelope", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Envelope findUnique
   */
  export type EnvelopeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Envelope
     */
    select?: EnvelopeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvelopeInclude<ExtArgs> | null
    /**
     * Filter, which Envelope to fetch.
     */
    where: EnvelopeWhereUniqueInput
  }

  /**
   * Envelope findUniqueOrThrow
   */
  export type EnvelopeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Envelope
     */
    select?: EnvelopeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvelopeInclude<ExtArgs> | null
    /**
     * Filter, which Envelope to fetch.
     */
    where: EnvelopeWhereUniqueInput
  }

  /**
   * Envelope findFirst
   */
  export type EnvelopeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Envelope
     */
    select?: EnvelopeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvelopeInclude<ExtArgs> | null
    /**
     * Filter, which Envelope to fetch.
     */
    where?: EnvelopeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Envelopes to fetch.
     */
    orderBy?: EnvelopeOrderByWithRelationInput | EnvelopeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Envelopes.
     */
    cursor?: EnvelopeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Envelopes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Envelopes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Envelopes.
     */
    distinct?: EnvelopeScalarFieldEnum | EnvelopeScalarFieldEnum[]
  }

  /**
   * Envelope findFirstOrThrow
   */
  export type EnvelopeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Envelope
     */
    select?: EnvelopeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvelopeInclude<ExtArgs> | null
    /**
     * Filter, which Envelope to fetch.
     */
    where?: EnvelopeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Envelopes to fetch.
     */
    orderBy?: EnvelopeOrderByWithRelationInput | EnvelopeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Envelopes.
     */
    cursor?: EnvelopeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Envelopes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Envelopes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Envelopes.
     */
    distinct?: EnvelopeScalarFieldEnum | EnvelopeScalarFieldEnum[]
  }

  /**
   * Envelope findMany
   */
  export type EnvelopeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Envelope
     */
    select?: EnvelopeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvelopeInclude<ExtArgs> | null
    /**
     * Filter, which Envelopes to fetch.
     */
    where?: EnvelopeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Envelopes to fetch.
     */
    orderBy?: EnvelopeOrderByWithRelationInput | EnvelopeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Envelopes.
     */
    cursor?: EnvelopeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Envelopes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Envelopes.
     */
    skip?: number
    distinct?: EnvelopeScalarFieldEnum | EnvelopeScalarFieldEnum[]
  }

  /**
   * Envelope create
   */
  export type EnvelopeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Envelope
     */
    select?: EnvelopeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvelopeInclude<ExtArgs> | null
    /**
     * The data needed to create a Envelope.
     */
    data: XOR<EnvelopeCreateInput, EnvelopeUncheckedCreateInput>
  }

  /**
   * Envelope createMany
   */
  export type EnvelopeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Envelopes.
     */
    data: EnvelopeCreateManyInput | EnvelopeCreateManyInput[]
  }

  /**
   * Envelope createManyAndReturn
   */
  export type EnvelopeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Envelope
     */
    select?: EnvelopeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Envelopes.
     */
    data: EnvelopeCreateManyInput | EnvelopeCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvelopeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Envelope update
   */
  export type EnvelopeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Envelope
     */
    select?: EnvelopeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvelopeInclude<ExtArgs> | null
    /**
     * The data needed to update a Envelope.
     */
    data: XOR<EnvelopeUpdateInput, EnvelopeUncheckedUpdateInput>
    /**
     * Choose, which Envelope to update.
     */
    where: EnvelopeWhereUniqueInput
  }

  /**
   * Envelope updateMany
   */
  export type EnvelopeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Envelopes.
     */
    data: XOR<EnvelopeUpdateManyMutationInput, EnvelopeUncheckedUpdateManyInput>
    /**
     * Filter which Envelopes to update
     */
    where?: EnvelopeWhereInput
  }

  /**
   * Envelope upsert
   */
  export type EnvelopeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Envelope
     */
    select?: EnvelopeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvelopeInclude<ExtArgs> | null
    /**
     * The filter to search for the Envelope to update in case it exists.
     */
    where: EnvelopeWhereUniqueInput
    /**
     * In case the Envelope found by the `where` argument doesn't exist, create a new Envelope with this data.
     */
    create: XOR<EnvelopeCreateInput, EnvelopeUncheckedCreateInput>
    /**
     * In case the Envelope was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EnvelopeUpdateInput, EnvelopeUncheckedUpdateInput>
  }

  /**
   * Envelope delete
   */
  export type EnvelopeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Envelope
     */
    select?: EnvelopeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvelopeInclude<ExtArgs> | null
    /**
     * Filter which Envelope to delete.
     */
    where: EnvelopeWhereUniqueInput
  }

  /**
   * Envelope deleteMany
   */
  export type EnvelopeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Envelopes to delete
     */
    where?: EnvelopeWhereInput
  }

  /**
   * Envelope.Category
   */
  export type Envelope$CategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * Envelope without action
   */
  export type EnvelopeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Envelope
     */
    select?: EnvelopeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvelopeInclude<ExtArgs> | null
  }


  /**
   * Model Asset
   */

  export type AggregateAsset = {
    _count: AssetCountAggregateOutputType | null
    _avg: AssetAvgAggregateOutputType | null
    _sum: AssetSumAggregateOutputType | null
    _min: AssetMinAggregateOutputType | null
    _max: AssetMaxAggregateOutputType | null
  }

  export type AssetAvgAggregateOutputType = {
    currentValue: number | null
    purchaseValue: number | null
  }

  export type AssetSumAggregateOutputType = {
    currentValue: number | null
    purchaseValue: number | null
  }

  export type AssetMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    name: string | null
    type: string | null
    description: string | null
    currentValue: number | null
    purchaseValue: number | null
    purchaseDate: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AssetMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    name: string | null
    type: string | null
    description: string | null
    currentValue: number | null
    purchaseValue: number | null
    purchaseDate: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AssetCountAggregateOutputType = {
    id: number
    workspaceId: number
    name: number
    type: number
    description: number
    currentValue: number
    purchaseValue: number
    purchaseDate: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AssetAvgAggregateInputType = {
    currentValue?: true
    purchaseValue?: true
  }

  export type AssetSumAggregateInputType = {
    currentValue?: true
    purchaseValue?: true
  }

  export type AssetMinAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    type?: true
    description?: true
    currentValue?: true
    purchaseValue?: true
    purchaseDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AssetMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    type?: true
    description?: true
    currentValue?: true
    purchaseValue?: true
    purchaseDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AssetCountAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    type?: true
    description?: true
    currentValue?: true
    purchaseValue?: true
    purchaseDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AssetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Asset to aggregate.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Assets
    **/
    _count?: true | AssetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssetMaxAggregateInputType
  }

  export type GetAssetAggregateType<T extends AssetAggregateArgs> = {
        [P in keyof T & keyof AggregateAsset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAsset[P]>
      : GetScalarType<T[P], AggregateAsset[P]>
  }




  export type AssetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetWhereInput
    orderBy?: AssetOrderByWithAggregationInput | AssetOrderByWithAggregationInput[]
    by: AssetScalarFieldEnum[] | AssetScalarFieldEnum
    having?: AssetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssetCountAggregateInputType | true
    _avg?: AssetAvgAggregateInputType
    _sum?: AssetSumAggregateInputType
    _min?: AssetMinAggregateInputType
    _max?: AssetMaxAggregateInputType
  }

  export type AssetGroupByOutputType = {
    id: string
    workspaceId: string
    name: string
    type: string
    description: string | null
    currentValue: number
    purchaseValue: number | null
    purchaseDate: Date | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: AssetCountAggregateOutputType | null
    _avg: AssetAvgAggregateOutputType | null
    _sum: AssetSumAggregateOutputType | null
    _min: AssetMinAggregateOutputType | null
    _max: AssetMaxAggregateOutputType | null
  }

  type GetAssetGroupByPayload<T extends AssetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssetGroupByOutputType[P]>
            : GetScalarType<T[P], AssetGroupByOutputType[P]>
        }
      >
    >


  export type AssetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    currentValue?: boolean
    purchaseValue?: boolean
    purchaseDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["asset"]>

  export type AssetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    currentValue?: boolean
    purchaseValue?: boolean
    purchaseDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["asset"]>

  export type AssetSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    currentValue?: boolean
    purchaseValue?: boolean
    purchaseDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AssetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type AssetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $AssetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Asset"
    objects: {
      Workspace: Prisma.$WorkspacePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      name: string
      type: string
      description: string | null
      currentValue: number
      purchaseValue: number | null
      purchaseDate: Date | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["asset"]>
    composites: {}
  }

  type AssetGetPayload<S extends boolean | null | undefined | AssetDefaultArgs> = $Result.GetResult<Prisma.$AssetPayload, S>

  type AssetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AssetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AssetCountAggregateInputType | true
    }

  export interface AssetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Asset'], meta: { name: 'Asset' } }
    /**
     * Find zero or one Asset that matches the filter.
     * @param {AssetFindUniqueArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssetFindUniqueArgs>(args: SelectSubset<T, AssetFindUniqueArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Asset that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AssetFindUniqueOrThrowArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssetFindUniqueOrThrowArgs>(args: SelectSubset<T, AssetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Asset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetFindFirstArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssetFindFirstArgs>(args?: SelectSubset<T, AssetFindFirstArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Asset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetFindFirstOrThrowArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssetFindFirstOrThrowArgs>(args?: SelectSubset<T, AssetFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Assets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Assets
     * const assets = await prisma.asset.findMany()
     * 
     * // Get first 10 Assets
     * const assets = await prisma.asset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assetWithIdOnly = await prisma.asset.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssetFindManyArgs>(args?: SelectSubset<T, AssetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Asset.
     * @param {AssetCreateArgs} args - Arguments to create a Asset.
     * @example
     * // Create one Asset
     * const Asset = await prisma.asset.create({
     *   data: {
     *     // ... data to create a Asset
     *   }
     * })
     * 
     */
    create<T extends AssetCreateArgs>(args: SelectSubset<T, AssetCreateArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Assets.
     * @param {AssetCreateManyArgs} args - Arguments to create many Assets.
     * @example
     * // Create many Assets
     * const asset = await prisma.asset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssetCreateManyArgs>(args?: SelectSubset<T, AssetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Assets and returns the data saved in the database.
     * @param {AssetCreateManyAndReturnArgs} args - Arguments to create many Assets.
     * @example
     * // Create many Assets
     * const asset = await prisma.asset.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Assets and only return the `id`
     * const assetWithIdOnly = await prisma.asset.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssetCreateManyAndReturnArgs>(args?: SelectSubset<T, AssetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Asset.
     * @param {AssetDeleteArgs} args - Arguments to delete one Asset.
     * @example
     * // Delete one Asset
     * const Asset = await prisma.asset.delete({
     *   where: {
     *     // ... filter to delete one Asset
     *   }
     * })
     * 
     */
    delete<T extends AssetDeleteArgs>(args: SelectSubset<T, AssetDeleteArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Asset.
     * @param {AssetUpdateArgs} args - Arguments to update one Asset.
     * @example
     * // Update one Asset
     * const asset = await prisma.asset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssetUpdateArgs>(args: SelectSubset<T, AssetUpdateArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Assets.
     * @param {AssetDeleteManyArgs} args - Arguments to filter Assets to delete.
     * @example
     * // Delete a few Assets
     * const { count } = await prisma.asset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssetDeleteManyArgs>(args?: SelectSubset<T, AssetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Assets
     * const asset = await prisma.asset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssetUpdateManyArgs>(args: SelectSubset<T, AssetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Asset.
     * @param {AssetUpsertArgs} args - Arguments to update or create a Asset.
     * @example
     * // Update or create a Asset
     * const asset = await prisma.asset.upsert({
     *   create: {
     *     // ... data to create a Asset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Asset we want to update
     *   }
     * })
     */
    upsert<T extends AssetUpsertArgs>(args: SelectSubset<T, AssetUpsertArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetCountArgs} args - Arguments to filter Assets to count.
     * @example
     * // Count the number of Assets
     * const count = await prisma.asset.count({
     *   where: {
     *     // ... the filter for the Assets we want to count
     *   }
     * })
    **/
    count<T extends AssetCountArgs>(
      args?: Subset<T, AssetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Asset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssetAggregateArgs>(args: Subset<T, AssetAggregateArgs>): Prisma.PrismaPromise<GetAssetAggregateType<T>>

    /**
     * Group by Asset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssetGroupByArgs['orderBy'] }
        : { orderBy?: AssetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Asset model
   */
  readonly fields: AssetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Asset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Asset model
   */ 
  interface AssetFieldRefs {
    readonly id: FieldRef<"Asset", 'String'>
    readonly workspaceId: FieldRef<"Asset", 'String'>
    readonly name: FieldRef<"Asset", 'String'>
    readonly type: FieldRef<"Asset", 'String'>
    readonly description: FieldRef<"Asset", 'String'>
    readonly currentValue: FieldRef<"Asset", 'Float'>
    readonly purchaseValue: FieldRef<"Asset", 'Float'>
    readonly purchaseDate: FieldRef<"Asset", 'DateTime'>
    readonly isActive: FieldRef<"Asset", 'Boolean'>
    readonly createdAt: FieldRef<"Asset", 'DateTime'>
    readonly updatedAt: FieldRef<"Asset", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Asset findUnique
   */
  export type AssetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset findUniqueOrThrow
   */
  export type AssetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset findFirst
   */
  export type AssetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assets.
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assets.
     */
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Asset findFirstOrThrow
   */
  export type AssetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assets.
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assets.
     */
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Asset findMany
   */
  export type AssetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Assets to fetch.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Assets.
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Asset create
   */
  export type AssetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * The data needed to create a Asset.
     */
    data: XOR<AssetCreateInput, AssetUncheckedCreateInput>
  }

  /**
   * Asset createMany
   */
  export type AssetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Assets.
     */
    data: AssetCreateManyInput | AssetCreateManyInput[]
  }

  /**
   * Asset createManyAndReturn
   */
  export type AssetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Assets.
     */
    data: AssetCreateManyInput | AssetCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Asset update
   */
  export type AssetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * The data needed to update a Asset.
     */
    data: XOR<AssetUpdateInput, AssetUncheckedUpdateInput>
    /**
     * Choose, which Asset to update.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset updateMany
   */
  export type AssetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Assets.
     */
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyInput>
    /**
     * Filter which Assets to update
     */
    where?: AssetWhereInput
  }

  /**
   * Asset upsert
   */
  export type AssetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * The filter to search for the Asset to update in case it exists.
     */
    where: AssetWhereUniqueInput
    /**
     * In case the Asset found by the `where` argument doesn't exist, create a new Asset with this data.
     */
    create: XOR<AssetCreateInput, AssetUncheckedCreateInput>
    /**
     * In case the Asset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssetUpdateInput, AssetUncheckedUpdateInput>
  }

  /**
   * Asset delete
   */
  export type AssetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter which Asset to delete.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset deleteMany
   */
  export type AssetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assets to delete
     */
    where?: AssetWhereInput
  }

  /**
   * Asset without action
   */
  export type AssetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
  }


  /**
   * Model Liability
   */

  export type AggregateLiability = {
    _count: LiabilityCountAggregateOutputType | null
    _avg: LiabilityAvgAggregateOutputType | null
    _sum: LiabilitySumAggregateOutputType | null
    _min: LiabilityMinAggregateOutputType | null
    _max: LiabilityMaxAggregateOutputType | null
  }

  export type LiabilityAvgAggregateOutputType = {
    currentBalance: number | null
    originalAmount: number | null
    interestRate: number | null
  }

  export type LiabilitySumAggregateOutputType = {
    currentBalance: number | null
    originalAmount: number | null
    interestRate: number | null
  }

  export type LiabilityMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    name: string | null
    type: string | null
    description: string | null
    currentBalance: number | null
    originalAmount: number | null
    interestRate: number | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LiabilityMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    name: string | null
    type: string | null
    description: string | null
    currentBalance: number | null
    originalAmount: number | null
    interestRate: number | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LiabilityCountAggregateOutputType = {
    id: number
    workspaceId: number
    name: number
    type: number
    description: number
    currentBalance: number
    originalAmount: number
    interestRate: number
    startDate: number
    endDate: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LiabilityAvgAggregateInputType = {
    currentBalance?: true
    originalAmount?: true
    interestRate?: true
  }

  export type LiabilitySumAggregateInputType = {
    currentBalance?: true
    originalAmount?: true
    interestRate?: true
  }

  export type LiabilityMinAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    type?: true
    description?: true
    currentBalance?: true
    originalAmount?: true
    interestRate?: true
    startDate?: true
    endDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LiabilityMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    type?: true
    description?: true
    currentBalance?: true
    originalAmount?: true
    interestRate?: true
    startDate?: true
    endDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LiabilityCountAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    type?: true
    description?: true
    currentBalance?: true
    originalAmount?: true
    interestRate?: true
    startDate?: true
    endDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LiabilityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Liability to aggregate.
     */
    where?: LiabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Liabilities to fetch.
     */
    orderBy?: LiabilityOrderByWithRelationInput | LiabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LiabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Liabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Liabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Liabilities
    **/
    _count?: true | LiabilityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LiabilityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LiabilitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LiabilityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LiabilityMaxAggregateInputType
  }

  export type GetLiabilityAggregateType<T extends LiabilityAggregateArgs> = {
        [P in keyof T & keyof AggregateLiability]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLiability[P]>
      : GetScalarType<T[P], AggregateLiability[P]>
  }




  export type LiabilityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LiabilityWhereInput
    orderBy?: LiabilityOrderByWithAggregationInput | LiabilityOrderByWithAggregationInput[]
    by: LiabilityScalarFieldEnum[] | LiabilityScalarFieldEnum
    having?: LiabilityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LiabilityCountAggregateInputType | true
    _avg?: LiabilityAvgAggregateInputType
    _sum?: LiabilitySumAggregateInputType
    _min?: LiabilityMinAggregateInputType
    _max?: LiabilityMaxAggregateInputType
  }

  export type LiabilityGroupByOutputType = {
    id: string
    workspaceId: string
    name: string
    type: string
    description: string | null
    currentBalance: number
    originalAmount: number
    interestRate: number | null
    startDate: Date
    endDate: Date | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: LiabilityCountAggregateOutputType | null
    _avg: LiabilityAvgAggregateOutputType | null
    _sum: LiabilitySumAggregateOutputType | null
    _min: LiabilityMinAggregateOutputType | null
    _max: LiabilityMaxAggregateOutputType | null
  }

  type GetLiabilityGroupByPayload<T extends LiabilityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LiabilityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LiabilityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LiabilityGroupByOutputType[P]>
            : GetScalarType<T[P], LiabilityGroupByOutputType[P]>
        }
      >
    >


  export type LiabilitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    currentBalance?: boolean
    originalAmount?: boolean
    interestRate?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["liability"]>

  export type LiabilitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    currentBalance?: boolean
    originalAmount?: boolean
    interestRate?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["liability"]>

  export type LiabilitySelectScalar = {
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    currentBalance?: boolean
    originalAmount?: boolean
    interestRate?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LiabilityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type LiabilityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $LiabilityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Liability"
    objects: {
      Workspace: Prisma.$WorkspacePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      name: string
      type: string
      description: string | null
      currentBalance: number
      originalAmount: number
      interestRate: number | null
      startDate: Date
      endDate: Date | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["liability"]>
    composites: {}
  }

  type LiabilityGetPayload<S extends boolean | null | undefined | LiabilityDefaultArgs> = $Result.GetResult<Prisma.$LiabilityPayload, S>

  type LiabilityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LiabilityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LiabilityCountAggregateInputType | true
    }

  export interface LiabilityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Liability'], meta: { name: 'Liability' } }
    /**
     * Find zero or one Liability that matches the filter.
     * @param {LiabilityFindUniqueArgs} args - Arguments to find a Liability
     * @example
     * // Get one Liability
     * const liability = await prisma.liability.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LiabilityFindUniqueArgs>(args: SelectSubset<T, LiabilityFindUniqueArgs<ExtArgs>>): Prisma__LiabilityClient<$Result.GetResult<Prisma.$LiabilityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Liability that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LiabilityFindUniqueOrThrowArgs} args - Arguments to find a Liability
     * @example
     * // Get one Liability
     * const liability = await prisma.liability.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LiabilityFindUniqueOrThrowArgs>(args: SelectSubset<T, LiabilityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LiabilityClient<$Result.GetResult<Prisma.$LiabilityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Liability that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiabilityFindFirstArgs} args - Arguments to find a Liability
     * @example
     * // Get one Liability
     * const liability = await prisma.liability.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LiabilityFindFirstArgs>(args?: SelectSubset<T, LiabilityFindFirstArgs<ExtArgs>>): Prisma__LiabilityClient<$Result.GetResult<Prisma.$LiabilityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Liability that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiabilityFindFirstOrThrowArgs} args - Arguments to find a Liability
     * @example
     * // Get one Liability
     * const liability = await prisma.liability.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LiabilityFindFirstOrThrowArgs>(args?: SelectSubset<T, LiabilityFindFirstOrThrowArgs<ExtArgs>>): Prisma__LiabilityClient<$Result.GetResult<Prisma.$LiabilityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Liabilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiabilityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Liabilities
     * const liabilities = await prisma.liability.findMany()
     * 
     * // Get first 10 Liabilities
     * const liabilities = await prisma.liability.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const liabilityWithIdOnly = await prisma.liability.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LiabilityFindManyArgs>(args?: SelectSubset<T, LiabilityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiabilityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Liability.
     * @param {LiabilityCreateArgs} args - Arguments to create a Liability.
     * @example
     * // Create one Liability
     * const Liability = await prisma.liability.create({
     *   data: {
     *     // ... data to create a Liability
     *   }
     * })
     * 
     */
    create<T extends LiabilityCreateArgs>(args: SelectSubset<T, LiabilityCreateArgs<ExtArgs>>): Prisma__LiabilityClient<$Result.GetResult<Prisma.$LiabilityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Liabilities.
     * @param {LiabilityCreateManyArgs} args - Arguments to create many Liabilities.
     * @example
     * // Create many Liabilities
     * const liability = await prisma.liability.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LiabilityCreateManyArgs>(args?: SelectSubset<T, LiabilityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Liabilities and returns the data saved in the database.
     * @param {LiabilityCreateManyAndReturnArgs} args - Arguments to create many Liabilities.
     * @example
     * // Create many Liabilities
     * const liability = await prisma.liability.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Liabilities and only return the `id`
     * const liabilityWithIdOnly = await prisma.liability.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LiabilityCreateManyAndReturnArgs>(args?: SelectSubset<T, LiabilityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiabilityPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Liability.
     * @param {LiabilityDeleteArgs} args - Arguments to delete one Liability.
     * @example
     * // Delete one Liability
     * const Liability = await prisma.liability.delete({
     *   where: {
     *     // ... filter to delete one Liability
     *   }
     * })
     * 
     */
    delete<T extends LiabilityDeleteArgs>(args: SelectSubset<T, LiabilityDeleteArgs<ExtArgs>>): Prisma__LiabilityClient<$Result.GetResult<Prisma.$LiabilityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Liability.
     * @param {LiabilityUpdateArgs} args - Arguments to update one Liability.
     * @example
     * // Update one Liability
     * const liability = await prisma.liability.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LiabilityUpdateArgs>(args: SelectSubset<T, LiabilityUpdateArgs<ExtArgs>>): Prisma__LiabilityClient<$Result.GetResult<Prisma.$LiabilityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Liabilities.
     * @param {LiabilityDeleteManyArgs} args - Arguments to filter Liabilities to delete.
     * @example
     * // Delete a few Liabilities
     * const { count } = await prisma.liability.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LiabilityDeleteManyArgs>(args?: SelectSubset<T, LiabilityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Liabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiabilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Liabilities
     * const liability = await prisma.liability.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LiabilityUpdateManyArgs>(args: SelectSubset<T, LiabilityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Liability.
     * @param {LiabilityUpsertArgs} args - Arguments to update or create a Liability.
     * @example
     * // Update or create a Liability
     * const liability = await prisma.liability.upsert({
     *   create: {
     *     // ... data to create a Liability
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Liability we want to update
     *   }
     * })
     */
    upsert<T extends LiabilityUpsertArgs>(args: SelectSubset<T, LiabilityUpsertArgs<ExtArgs>>): Prisma__LiabilityClient<$Result.GetResult<Prisma.$LiabilityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Liabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiabilityCountArgs} args - Arguments to filter Liabilities to count.
     * @example
     * // Count the number of Liabilities
     * const count = await prisma.liability.count({
     *   where: {
     *     // ... the filter for the Liabilities we want to count
     *   }
     * })
    **/
    count<T extends LiabilityCountArgs>(
      args?: Subset<T, LiabilityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LiabilityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Liability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiabilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LiabilityAggregateArgs>(args: Subset<T, LiabilityAggregateArgs>): Prisma.PrismaPromise<GetLiabilityAggregateType<T>>

    /**
     * Group by Liability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiabilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LiabilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LiabilityGroupByArgs['orderBy'] }
        : { orderBy?: LiabilityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LiabilityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLiabilityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Liability model
   */
  readonly fields: LiabilityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Liability.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LiabilityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Liability model
   */ 
  interface LiabilityFieldRefs {
    readonly id: FieldRef<"Liability", 'String'>
    readonly workspaceId: FieldRef<"Liability", 'String'>
    readonly name: FieldRef<"Liability", 'String'>
    readonly type: FieldRef<"Liability", 'String'>
    readonly description: FieldRef<"Liability", 'String'>
    readonly currentBalance: FieldRef<"Liability", 'Float'>
    readonly originalAmount: FieldRef<"Liability", 'Float'>
    readonly interestRate: FieldRef<"Liability", 'Float'>
    readonly startDate: FieldRef<"Liability", 'DateTime'>
    readonly endDate: FieldRef<"Liability", 'DateTime'>
    readonly isActive: FieldRef<"Liability", 'Boolean'>
    readonly createdAt: FieldRef<"Liability", 'DateTime'>
    readonly updatedAt: FieldRef<"Liability", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Liability findUnique
   */
  export type LiabilityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liability
     */
    select?: LiabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiabilityInclude<ExtArgs> | null
    /**
     * Filter, which Liability to fetch.
     */
    where: LiabilityWhereUniqueInput
  }

  /**
   * Liability findUniqueOrThrow
   */
  export type LiabilityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liability
     */
    select?: LiabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiabilityInclude<ExtArgs> | null
    /**
     * Filter, which Liability to fetch.
     */
    where: LiabilityWhereUniqueInput
  }

  /**
   * Liability findFirst
   */
  export type LiabilityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liability
     */
    select?: LiabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiabilityInclude<ExtArgs> | null
    /**
     * Filter, which Liability to fetch.
     */
    where?: LiabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Liabilities to fetch.
     */
    orderBy?: LiabilityOrderByWithRelationInput | LiabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Liabilities.
     */
    cursor?: LiabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Liabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Liabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Liabilities.
     */
    distinct?: LiabilityScalarFieldEnum | LiabilityScalarFieldEnum[]
  }

  /**
   * Liability findFirstOrThrow
   */
  export type LiabilityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liability
     */
    select?: LiabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiabilityInclude<ExtArgs> | null
    /**
     * Filter, which Liability to fetch.
     */
    where?: LiabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Liabilities to fetch.
     */
    orderBy?: LiabilityOrderByWithRelationInput | LiabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Liabilities.
     */
    cursor?: LiabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Liabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Liabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Liabilities.
     */
    distinct?: LiabilityScalarFieldEnum | LiabilityScalarFieldEnum[]
  }

  /**
   * Liability findMany
   */
  export type LiabilityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liability
     */
    select?: LiabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiabilityInclude<ExtArgs> | null
    /**
     * Filter, which Liabilities to fetch.
     */
    where?: LiabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Liabilities to fetch.
     */
    orderBy?: LiabilityOrderByWithRelationInput | LiabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Liabilities.
     */
    cursor?: LiabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Liabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Liabilities.
     */
    skip?: number
    distinct?: LiabilityScalarFieldEnum | LiabilityScalarFieldEnum[]
  }

  /**
   * Liability create
   */
  export type LiabilityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liability
     */
    select?: LiabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiabilityInclude<ExtArgs> | null
    /**
     * The data needed to create a Liability.
     */
    data: XOR<LiabilityCreateInput, LiabilityUncheckedCreateInput>
  }

  /**
   * Liability createMany
   */
  export type LiabilityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Liabilities.
     */
    data: LiabilityCreateManyInput | LiabilityCreateManyInput[]
  }

  /**
   * Liability createManyAndReturn
   */
  export type LiabilityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liability
     */
    select?: LiabilitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Liabilities.
     */
    data: LiabilityCreateManyInput | LiabilityCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiabilityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Liability update
   */
  export type LiabilityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liability
     */
    select?: LiabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiabilityInclude<ExtArgs> | null
    /**
     * The data needed to update a Liability.
     */
    data: XOR<LiabilityUpdateInput, LiabilityUncheckedUpdateInput>
    /**
     * Choose, which Liability to update.
     */
    where: LiabilityWhereUniqueInput
  }

  /**
   * Liability updateMany
   */
  export type LiabilityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Liabilities.
     */
    data: XOR<LiabilityUpdateManyMutationInput, LiabilityUncheckedUpdateManyInput>
    /**
     * Filter which Liabilities to update
     */
    where?: LiabilityWhereInput
  }

  /**
   * Liability upsert
   */
  export type LiabilityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liability
     */
    select?: LiabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiabilityInclude<ExtArgs> | null
    /**
     * The filter to search for the Liability to update in case it exists.
     */
    where: LiabilityWhereUniqueInput
    /**
     * In case the Liability found by the `where` argument doesn't exist, create a new Liability with this data.
     */
    create: XOR<LiabilityCreateInput, LiabilityUncheckedCreateInput>
    /**
     * In case the Liability was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LiabilityUpdateInput, LiabilityUncheckedUpdateInput>
  }

  /**
   * Liability delete
   */
  export type LiabilityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liability
     */
    select?: LiabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiabilityInclude<ExtArgs> | null
    /**
     * Filter which Liability to delete.
     */
    where: LiabilityWhereUniqueInput
  }

  /**
   * Liability deleteMany
   */
  export type LiabilityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Liabilities to delete
     */
    where?: LiabilityWhereInput
  }

  /**
   * Liability without action
   */
  export type LiabilityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liability
     */
    select?: LiabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiabilityInclude<ExtArgs> | null
  }


  /**
   * Model AIInsight
   */

  export type AggregateAIInsight = {
    _count: AIInsightCountAggregateOutputType | null
    _avg: AIInsightAvgAggregateOutputType | null
    _sum: AIInsightSumAggregateOutputType | null
    _min: AIInsightMinAggregateOutputType | null
    _max: AIInsightMaxAggregateOutputType | null
  }

  export type AIInsightAvgAggregateOutputType = {
    confidenceScore: number | null
  }

  export type AIInsightSumAggregateOutputType = {
    confidenceScore: number | null
  }

  export type AIInsightMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    userId: string | null
    type: string | null
    title: string | null
    description: string | null
    severity: string | null
    suggestedAction: string | null
    actionTaken: boolean | null
    confidenceScore: number | null
    dismissedAt: Date | null
    createdAt: Date | null
  }

  export type AIInsightMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    userId: string | null
    type: string | null
    title: string | null
    description: string | null
    severity: string | null
    suggestedAction: string | null
    actionTaken: boolean | null
    confidenceScore: number | null
    dismissedAt: Date | null
    createdAt: Date | null
  }

  export type AIInsightCountAggregateOutputType = {
    id: number
    workspaceId: number
    userId: number
    type: number
    title: number
    description: number
    severity: number
    suggestedAction: number
    actionTaken: number
    confidenceScore: number
    dismissedAt: number
    createdAt: number
    _all: number
  }


  export type AIInsightAvgAggregateInputType = {
    confidenceScore?: true
  }

  export type AIInsightSumAggregateInputType = {
    confidenceScore?: true
  }

  export type AIInsightMinAggregateInputType = {
    id?: true
    workspaceId?: true
    userId?: true
    type?: true
    title?: true
    description?: true
    severity?: true
    suggestedAction?: true
    actionTaken?: true
    confidenceScore?: true
    dismissedAt?: true
    createdAt?: true
  }

  export type AIInsightMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    userId?: true
    type?: true
    title?: true
    description?: true
    severity?: true
    suggestedAction?: true
    actionTaken?: true
    confidenceScore?: true
    dismissedAt?: true
    createdAt?: true
  }

  export type AIInsightCountAggregateInputType = {
    id?: true
    workspaceId?: true
    userId?: true
    type?: true
    title?: true
    description?: true
    severity?: true
    suggestedAction?: true
    actionTaken?: true
    confidenceScore?: true
    dismissedAt?: true
    createdAt?: true
    _all?: true
  }

  export type AIInsightAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIInsight to aggregate.
     */
    where?: AIInsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIInsights to fetch.
     */
    orderBy?: AIInsightOrderByWithRelationInput | AIInsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIInsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIInsights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIInsights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIInsights
    **/
    _count?: true | AIInsightCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AIInsightAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AIInsightSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIInsightMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIInsightMaxAggregateInputType
  }

  export type GetAIInsightAggregateType<T extends AIInsightAggregateArgs> = {
        [P in keyof T & keyof AggregateAIInsight]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIInsight[P]>
      : GetScalarType<T[P], AggregateAIInsight[P]>
  }




  export type AIInsightGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIInsightWhereInput
    orderBy?: AIInsightOrderByWithAggregationInput | AIInsightOrderByWithAggregationInput[]
    by: AIInsightScalarFieldEnum[] | AIInsightScalarFieldEnum
    having?: AIInsightScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIInsightCountAggregateInputType | true
    _avg?: AIInsightAvgAggregateInputType
    _sum?: AIInsightSumAggregateInputType
    _min?: AIInsightMinAggregateInputType
    _max?: AIInsightMaxAggregateInputType
  }

  export type AIInsightGroupByOutputType = {
    id: string
    workspaceId: string
    userId: string
    type: string
    title: string
    description: string
    severity: string
    suggestedAction: string | null
    actionTaken: boolean
    confidenceScore: number | null
    dismissedAt: Date | null
    createdAt: Date
    _count: AIInsightCountAggregateOutputType | null
    _avg: AIInsightAvgAggregateOutputType | null
    _sum: AIInsightSumAggregateOutputType | null
    _min: AIInsightMinAggregateOutputType | null
    _max: AIInsightMaxAggregateOutputType | null
  }

  type GetAIInsightGroupByPayload<T extends AIInsightGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIInsightGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIInsightGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIInsightGroupByOutputType[P]>
            : GetScalarType<T[P], AIInsightGroupByOutputType[P]>
        }
      >
    >


  export type AIInsightSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    severity?: boolean
    suggestedAction?: boolean
    actionTaken?: boolean
    confidenceScore?: boolean
    dismissedAt?: boolean
    createdAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    Workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIInsight"]>

  export type AIInsightSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    severity?: boolean
    suggestedAction?: boolean
    actionTaken?: boolean
    confidenceScore?: boolean
    dismissedAt?: boolean
    createdAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    Workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIInsight"]>

  export type AIInsightSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    severity?: boolean
    suggestedAction?: boolean
    actionTaken?: boolean
    confidenceScore?: boolean
    dismissedAt?: boolean
    createdAt?: boolean
  }

  export type AIInsightInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    Workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type AIInsightIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    Workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $AIInsightPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIInsight"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
      Workspace: Prisma.$WorkspacePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      userId: string
      type: string
      title: string
      description: string
      severity: string
      suggestedAction: string | null
      actionTaken: boolean
      confidenceScore: number | null
      dismissedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["aIInsight"]>
    composites: {}
  }

  type AIInsightGetPayload<S extends boolean | null | undefined | AIInsightDefaultArgs> = $Result.GetResult<Prisma.$AIInsightPayload, S>

  type AIInsightCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AIInsightFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AIInsightCountAggregateInputType | true
    }

  export interface AIInsightDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIInsight'], meta: { name: 'AIInsight' } }
    /**
     * Find zero or one AIInsight that matches the filter.
     * @param {AIInsightFindUniqueArgs} args - Arguments to find a AIInsight
     * @example
     * // Get one AIInsight
     * const aIInsight = await prisma.aIInsight.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIInsightFindUniqueArgs>(args: SelectSubset<T, AIInsightFindUniqueArgs<ExtArgs>>): Prisma__AIInsightClient<$Result.GetResult<Prisma.$AIInsightPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AIInsight that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AIInsightFindUniqueOrThrowArgs} args - Arguments to find a AIInsight
     * @example
     * // Get one AIInsight
     * const aIInsight = await prisma.aIInsight.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIInsightFindUniqueOrThrowArgs>(args: SelectSubset<T, AIInsightFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIInsightClient<$Result.GetResult<Prisma.$AIInsightPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AIInsight that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIInsightFindFirstArgs} args - Arguments to find a AIInsight
     * @example
     * // Get one AIInsight
     * const aIInsight = await prisma.aIInsight.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIInsightFindFirstArgs>(args?: SelectSubset<T, AIInsightFindFirstArgs<ExtArgs>>): Prisma__AIInsightClient<$Result.GetResult<Prisma.$AIInsightPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AIInsight that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIInsightFindFirstOrThrowArgs} args - Arguments to find a AIInsight
     * @example
     * // Get one AIInsight
     * const aIInsight = await prisma.aIInsight.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIInsightFindFirstOrThrowArgs>(args?: SelectSubset<T, AIInsightFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIInsightClient<$Result.GetResult<Prisma.$AIInsightPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AIInsights that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIInsightFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIInsights
     * const aIInsights = await prisma.aIInsight.findMany()
     * 
     * // Get first 10 AIInsights
     * const aIInsights = await prisma.aIInsight.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIInsightWithIdOnly = await prisma.aIInsight.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIInsightFindManyArgs>(args?: SelectSubset<T, AIInsightFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIInsightPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AIInsight.
     * @param {AIInsightCreateArgs} args - Arguments to create a AIInsight.
     * @example
     * // Create one AIInsight
     * const AIInsight = await prisma.aIInsight.create({
     *   data: {
     *     // ... data to create a AIInsight
     *   }
     * })
     * 
     */
    create<T extends AIInsightCreateArgs>(args: SelectSubset<T, AIInsightCreateArgs<ExtArgs>>): Prisma__AIInsightClient<$Result.GetResult<Prisma.$AIInsightPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AIInsights.
     * @param {AIInsightCreateManyArgs} args - Arguments to create many AIInsights.
     * @example
     * // Create many AIInsights
     * const aIInsight = await prisma.aIInsight.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIInsightCreateManyArgs>(args?: SelectSubset<T, AIInsightCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AIInsights and returns the data saved in the database.
     * @param {AIInsightCreateManyAndReturnArgs} args - Arguments to create many AIInsights.
     * @example
     * // Create many AIInsights
     * const aIInsight = await prisma.aIInsight.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AIInsights and only return the `id`
     * const aIInsightWithIdOnly = await prisma.aIInsight.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AIInsightCreateManyAndReturnArgs>(args?: SelectSubset<T, AIInsightCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIInsightPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AIInsight.
     * @param {AIInsightDeleteArgs} args - Arguments to delete one AIInsight.
     * @example
     * // Delete one AIInsight
     * const AIInsight = await prisma.aIInsight.delete({
     *   where: {
     *     // ... filter to delete one AIInsight
     *   }
     * })
     * 
     */
    delete<T extends AIInsightDeleteArgs>(args: SelectSubset<T, AIInsightDeleteArgs<ExtArgs>>): Prisma__AIInsightClient<$Result.GetResult<Prisma.$AIInsightPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AIInsight.
     * @param {AIInsightUpdateArgs} args - Arguments to update one AIInsight.
     * @example
     * // Update one AIInsight
     * const aIInsight = await prisma.aIInsight.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIInsightUpdateArgs>(args: SelectSubset<T, AIInsightUpdateArgs<ExtArgs>>): Prisma__AIInsightClient<$Result.GetResult<Prisma.$AIInsightPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AIInsights.
     * @param {AIInsightDeleteManyArgs} args - Arguments to filter AIInsights to delete.
     * @example
     * // Delete a few AIInsights
     * const { count } = await prisma.aIInsight.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIInsightDeleteManyArgs>(args?: SelectSubset<T, AIInsightDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIInsights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIInsightUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIInsights
     * const aIInsight = await prisma.aIInsight.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIInsightUpdateManyArgs>(args: SelectSubset<T, AIInsightUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AIInsight.
     * @param {AIInsightUpsertArgs} args - Arguments to update or create a AIInsight.
     * @example
     * // Update or create a AIInsight
     * const aIInsight = await prisma.aIInsight.upsert({
     *   create: {
     *     // ... data to create a AIInsight
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIInsight we want to update
     *   }
     * })
     */
    upsert<T extends AIInsightUpsertArgs>(args: SelectSubset<T, AIInsightUpsertArgs<ExtArgs>>): Prisma__AIInsightClient<$Result.GetResult<Prisma.$AIInsightPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AIInsights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIInsightCountArgs} args - Arguments to filter AIInsights to count.
     * @example
     * // Count the number of AIInsights
     * const count = await prisma.aIInsight.count({
     *   where: {
     *     // ... the filter for the AIInsights we want to count
     *   }
     * })
    **/
    count<T extends AIInsightCountArgs>(
      args?: Subset<T, AIInsightCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIInsightCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIInsight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIInsightAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIInsightAggregateArgs>(args: Subset<T, AIInsightAggregateArgs>): Prisma.PrismaPromise<GetAIInsightAggregateType<T>>

    /**
     * Group by AIInsight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIInsightGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIInsightGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIInsightGroupByArgs['orderBy'] }
        : { orderBy?: AIInsightGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIInsightGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIInsightGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIInsight model
   */
  readonly fields: AIInsightFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIInsight.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIInsightClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIInsight model
   */ 
  interface AIInsightFieldRefs {
    readonly id: FieldRef<"AIInsight", 'String'>
    readonly workspaceId: FieldRef<"AIInsight", 'String'>
    readonly userId: FieldRef<"AIInsight", 'String'>
    readonly type: FieldRef<"AIInsight", 'String'>
    readonly title: FieldRef<"AIInsight", 'String'>
    readonly description: FieldRef<"AIInsight", 'String'>
    readonly severity: FieldRef<"AIInsight", 'String'>
    readonly suggestedAction: FieldRef<"AIInsight", 'String'>
    readonly actionTaken: FieldRef<"AIInsight", 'Boolean'>
    readonly confidenceScore: FieldRef<"AIInsight", 'Float'>
    readonly dismissedAt: FieldRef<"AIInsight", 'DateTime'>
    readonly createdAt: FieldRef<"AIInsight", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AIInsight findUnique
   */
  export type AIInsightFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIInsight
     */
    select?: AIInsightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIInsightInclude<ExtArgs> | null
    /**
     * Filter, which AIInsight to fetch.
     */
    where: AIInsightWhereUniqueInput
  }

  /**
   * AIInsight findUniqueOrThrow
   */
  export type AIInsightFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIInsight
     */
    select?: AIInsightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIInsightInclude<ExtArgs> | null
    /**
     * Filter, which AIInsight to fetch.
     */
    where: AIInsightWhereUniqueInput
  }

  /**
   * AIInsight findFirst
   */
  export type AIInsightFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIInsight
     */
    select?: AIInsightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIInsightInclude<ExtArgs> | null
    /**
     * Filter, which AIInsight to fetch.
     */
    where?: AIInsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIInsights to fetch.
     */
    orderBy?: AIInsightOrderByWithRelationInput | AIInsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIInsights.
     */
    cursor?: AIInsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIInsights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIInsights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIInsights.
     */
    distinct?: AIInsightScalarFieldEnum | AIInsightScalarFieldEnum[]
  }

  /**
   * AIInsight findFirstOrThrow
   */
  export type AIInsightFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIInsight
     */
    select?: AIInsightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIInsightInclude<ExtArgs> | null
    /**
     * Filter, which AIInsight to fetch.
     */
    where?: AIInsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIInsights to fetch.
     */
    orderBy?: AIInsightOrderByWithRelationInput | AIInsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIInsights.
     */
    cursor?: AIInsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIInsights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIInsights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIInsights.
     */
    distinct?: AIInsightScalarFieldEnum | AIInsightScalarFieldEnum[]
  }

  /**
   * AIInsight findMany
   */
  export type AIInsightFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIInsight
     */
    select?: AIInsightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIInsightInclude<ExtArgs> | null
    /**
     * Filter, which AIInsights to fetch.
     */
    where?: AIInsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIInsights to fetch.
     */
    orderBy?: AIInsightOrderByWithRelationInput | AIInsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIInsights.
     */
    cursor?: AIInsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIInsights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIInsights.
     */
    skip?: number
    distinct?: AIInsightScalarFieldEnum | AIInsightScalarFieldEnum[]
  }

  /**
   * AIInsight create
   */
  export type AIInsightCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIInsight
     */
    select?: AIInsightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIInsightInclude<ExtArgs> | null
    /**
     * The data needed to create a AIInsight.
     */
    data: XOR<AIInsightCreateInput, AIInsightUncheckedCreateInput>
  }

  /**
   * AIInsight createMany
   */
  export type AIInsightCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIInsights.
     */
    data: AIInsightCreateManyInput | AIInsightCreateManyInput[]
  }

  /**
   * AIInsight createManyAndReturn
   */
  export type AIInsightCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIInsight
     */
    select?: AIInsightSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AIInsights.
     */
    data: AIInsightCreateManyInput | AIInsightCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIInsightIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIInsight update
   */
  export type AIInsightUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIInsight
     */
    select?: AIInsightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIInsightInclude<ExtArgs> | null
    /**
     * The data needed to update a AIInsight.
     */
    data: XOR<AIInsightUpdateInput, AIInsightUncheckedUpdateInput>
    /**
     * Choose, which AIInsight to update.
     */
    where: AIInsightWhereUniqueInput
  }

  /**
   * AIInsight updateMany
   */
  export type AIInsightUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIInsights.
     */
    data: XOR<AIInsightUpdateManyMutationInput, AIInsightUncheckedUpdateManyInput>
    /**
     * Filter which AIInsights to update
     */
    where?: AIInsightWhereInput
  }

  /**
   * AIInsight upsert
   */
  export type AIInsightUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIInsight
     */
    select?: AIInsightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIInsightInclude<ExtArgs> | null
    /**
     * The filter to search for the AIInsight to update in case it exists.
     */
    where: AIInsightWhereUniqueInput
    /**
     * In case the AIInsight found by the `where` argument doesn't exist, create a new AIInsight with this data.
     */
    create: XOR<AIInsightCreateInput, AIInsightUncheckedCreateInput>
    /**
     * In case the AIInsight was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIInsightUpdateInput, AIInsightUncheckedUpdateInput>
  }

  /**
   * AIInsight delete
   */
  export type AIInsightDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIInsight
     */
    select?: AIInsightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIInsightInclude<ExtArgs> | null
    /**
     * Filter which AIInsight to delete.
     */
    where: AIInsightWhereUniqueInput
  }

  /**
   * AIInsight deleteMany
   */
  export type AIInsightDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIInsights to delete
     */
    where?: AIInsightWhereInput
  }

  /**
   * AIInsight without action
   */
  export type AIInsightDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIInsight
     */
    select?: AIInsightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIInsightInclude<ExtArgs> | null
  }


  /**
   * Model Scenario
   */

  export type AggregateScenario = {
    _count: ScenarioCountAggregateOutputType | null
    _min: ScenarioMinAggregateOutputType | null
    _max: ScenarioMaxAggregateOutputType | null
  }

  export type ScenarioMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    userId: string | null
    name: string | null
    description: string | null
    type: string | null
    parameters: string | null
    isFavorite: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScenarioMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    userId: string | null
    name: string | null
    description: string | null
    type: string | null
    parameters: string | null
    isFavorite: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScenarioCountAggregateOutputType = {
    id: number
    workspaceId: number
    userId: number
    name: number
    description: number
    type: number
    parameters: number
    isFavorite: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ScenarioMinAggregateInputType = {
    id?: true
    workspaceId?: true
    userId?: true
    name?: true
    description?: true
    type?: true
    parameters?: true
    isFavorite?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScenarioMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    userId?: true
    name?: true
    description?: true
    type?: true
    parameters?: true
    isFavorite?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScenarioCountAggregateInputType = {
    id?: true
    workspaceId?: true
    userId?: true
    name?: true
    description?: true
    type?: true
    parameters?: true
    isFavorite?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ScenarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Scenario to aggregate.
     */
    where?: ScenarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Scenarios to fetch.
     */
    orderBy?: ScenarioOrderByWithRelationInput | ScenarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScenarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Scenarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Scenarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Scenarios
    **/
    _count?: true | ScenarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScenarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScenarioMaxAggregateInputType
  }

  export type GetScenarioAggregateType<T extends ScenarioAggregateArgs> = {
        [P in keyof T & keyof AggregateScenario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScenario[P]>
      : GetScalarType<T[P], AggregateScenario[P]>
  }




  export type ScenarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScenarioWhereInput
    orderBy?: ScenarioOrderByWithAggregationInput | ScenarioOrderByWithAggregationInput[]
    by: ScenarioScalarFieldEnum[] | ScenarioScalarFieldEnum
    having?: ScenarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScenarioCountAggregateInputType | true
    _min?: ScenarioMinAggregateInputType
    _max?: ScenarioMaxAggregateInputType
  }

  export type ScenarioGroupByOutputType = {
    id: string
    workspaceId: string
    userId: string
    name: string
    description: string | null
    type: string
    parameters: string
    isFavorite: boolean
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ScenarioCountAggregateOutputType | null
    _min: ScenarioMinAggregateOutputType | null
    _max: ScenarioMaxAggregateOutputType | null
  }

  type GetScenarioGroupByPayload<T extends ScenarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScenarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScenarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScenarioGroupByOutputType[P]>
            : GetScalarType<T[P], ScenarioGroupByOutputType[P]>
        }
      >
    >


  export type ScenarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    parameters?: boolean
    isFavorite?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    Workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scenario"]>

  export type ScenarioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    parameters?: boolean
    isFavorite?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    Workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scenario"]>

  export type ScenarioSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    parameters?: boolean
    isFavorite?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ScenarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    Workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type ScenarioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    Workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $ScenarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Scenario"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
      Workspace: Prisma.$WorkspacePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      userId: string
      name: string
      description: string | null
      type: string
      parameters: string
      isFavorite: boolean
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["scenario"]>
    composites: {}
  }

  type ScenarioGetPayload<S extends boolean | null | undefined | ScenarioDefaultArgs> = $Result.GetResult<Prisma.$ScenarioPayload, S>

  type ScenarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ScenarioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ScenarioCountAggregateInputType | true
    }

  export interface ScenarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Scenario'], meta: { name: 'Scenario' } }
    /**
     * Find zero or one Scenario that matches the filter.
     * @param {ScenarioFindUniqueArgs} args - Arguments to find a Scenario
     * @example
     * // Get one Scenario
     * const scenario = await prisma.scenario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScenarioFindUniqueArgs>(args: SelectSubset<T, ScenarioFindUniqueArgs<ExtArgs>>): Prisma__ScenarioClient<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Scenario that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ScenarioFindUniqueOrThrowArgs} args - Arguments to find a Scenario
     * @example
     * // Get one Scenario
     * const scenario = await prisma.scenario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScenarioFindUniqueOrThrowArgs>(args: SelectSubset<T, ScenarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScenarioClient<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Scenario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScenarioFindFirstArgs} args - Arguments to find a Scenario
     * @example
     * // Get one Scenario
     * const scenario = await prisma.scenario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScenarioFindFirstArgs>(args?: SelectSubset<T, ScenarioFindFirstArgs<ExtArgs>>): Prisma__ScenarioClient<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Scenario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScenarioFindFirstOrThrowArgs} args - Arguments to find a Scenario
     * @example
     * // Get one Scenario
     * const scenario = await prisma.scenario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScenarioFindFirstOrThrowArgs>(args?: SelectSubset<T, ScenarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScenarioClient<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Scenarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScenarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Scenarios
     * const scenarios = await prisma.scenario.findMany()
     * 
     * // Get first 10 Scenarios
     * const scenarios = await prisma.scenario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scenarioWithIdOnly = await prisma.scenario.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScenarioFindManyArgs>(args?: SelectSubset<T, ScenarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Scenario.
     * @param {ScenarioCreateArgs} args - Arguments to create a Scenario.
     * @example
     * // Create one Scenario
     * const Scenario = await prisma.scenario.create({
     *   data: {
     *     // ... data to create a Scenario
     *   }
     * })
     * 
     */
    create<T extends ScenarioCreateArgs>(args: SelectSubset<T, ScenarioCreateArgs<ExtArgs>>): Prisma__ScenarioClient<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Scenarios.
     * @param {ScenarioCreateManyArgs} args - Arguments to create many Scenarios.
     * @example
     * // Create many Scenarios
     * const scenario = await prisma.scenario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScenarioCreateManyArgs>(args?: SelectSubset<T, ScenarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Scenarios and returns the data saved in the database.
     * @param {ScenarioCreateManyAndReturnArgs} args - Arguments to create many Scenarios.
     * @example
     * // Create many Scenarios
     * const scenario = await prisma.scenario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Scenarios and only return the `id`
     * const scenarioWithIdOnly = await prisma.scenario.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScenarioCreateManyAndReturnArgs>(args?: SelectSubset<T, ScenarioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Scenario.
     * @param {ScenarioDeleteArgs} args - Arguments to delete one Scenario.
     * @example
     * // Delete one Scenario
     * const Scenario = await prisma.scenario.delete({
     *   where: {
     *     // ... filter to delete one Scenario
     *   }
     * })
     * 
     */
    delete<T extends ScenarioDeleteArgs>(args: SelectSubset<T, ScenarioDeleteArgs<ExtArgs>>): Prisma__ScenarioClient<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Scenario.
     * @param {ScenarioUpdateArgs} args - Arguments to update one Scenario.
     * @example
     * // Update one Scenario
     * const scenario = await prisma.scenario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScenarioUpdateArgs>(args: SelectSubset<T, ScenarioUpdateArgs<ExtArgs>>): Prisma__ScenarioClient<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Scenarios.
     * @param {ScenarioDeleteManyArgs} args - Arguments to filter Scenarios to delete.
     * @example
     * // Delete a few Scenarios
     * const { count } = await prisma.scenario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScenarioDeleteManyArgs>(args?: SelectSubset<T, ScenarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Scenarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScenarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Scenarios
     * const scenario = await prisma.scenario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScenarioUpdateManyArgs>(args: SelectSubset<T, ScenarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Scenario.
     * @param {ScenarioUpsertArgs} args - Arguments to update or create a Scenario.
     * @example
     * // Update or create a Scenario
     * const scenario = await prisma.scenario.upsert({
     *   create: {
     *     // ... data to create a Scenario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Scenario we want to update
     *   }
     * })
     */
    upsert<T extends ScenarioUpsertArgs>(args: SelectSubset<T, ScenarioUpsertArgs<ExtArgs>>): Prisma__ScenarioClient<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Scenarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScenarioCountArgs} args - Arguments to filter Scenarios to count.
     * @example
     * // Count the number of Scenarios
     * const count = await prisma.scenario.count({
     *   where: {
     *     // ... the filter for the Scenarios we want to count
     *   }
     * })
    **/
    count<T extends ScenarioCountArgs>(
      args?: Subset<T, ScenarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScenarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Scenario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScenarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScenarioAggregateArgs>(args: Subset<T, ScenarioAggregateArgs>): Prisma.PrismaPromise<GetScenarioAggregateType<T>>

    /**
     * Group by Scenario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScenarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScenarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScenarioGroupByArgs['orderBy'] }
        : { orderBy?: ScenarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScenarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScenarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Scenario model
   */
  readonly fields: ScenarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Scenario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScenarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Scenario model
   */ 
  interface ScenarioFieldRefs {
    readonly id: FieldRef<"Scenario", 'String'>
    readonly workspaceId: FieldRef<"Scenario", 'String'>
    readonly userId: FieldRef<"Scenario", 'String'>
    readonly name: FieldRef<"Scenario", 'String'>
    readonly description: FieldRef<"Scenario", 'String'>
    readonly type: FieldRef<"Scenario", 'String'>
    readonly parameters: FieldRef<"Scenario", 'String'>
    readonly isFavorite: FieldRef<"Scenario", 'Boolean'>
    readonly isActive: FieldRef<"Scenario", 'Boolean'>
    readonly createdAt: FieldRef<"Scenario", 'DateTime'>
    readonly updatedAt: FieldRef<"Scenario", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Scenario findUnique
   */
  export type ScenarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    /**
     * Filter, which Scenario to fetch.
     */
    where: ScenarioWhereUniqueInput
  }

  /**
   * Scenario findUniqueOrThrow
   */
  export type ScenarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    /**
     * Filter, which Scenario to fetch.
     */
    where: ScenarioWhereUniqueInput
  }

  /**
   * Scenario findFirst
   */
  export type ScenarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    /**
     * Filter, which Scenario to fetch.
     */
    where?: ScenarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Scenarios to fetch.
     */
    orderBy?: ScenarioOrderByWithRelationInput | ScenarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Scenarios.
     */
    cursor?: ScenarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Scenarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Scenarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Scenarios.
     */
    distinct?: ScenarioScalarFieldEnum | ScenarioScalarFieldEnum[]
  }

  /**
   * Scenario findFirstOrThrow
   */
  export type ScenarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    /**
     * Filter, which Scenario to fetch.
     */
    where?: ScenarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Scenarios to fetch.
     */
    orderBy?: ScenarioOrderByWithRelationInput | ScenarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Scenarios.
     */
    cursor?: ScenarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Scenarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Scenarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Scenarios.
     */
    distinct?: ScenarioScalarFieldEnum | ScenarioScalarFieldEnum[]
  }

  /**
   * Scenario findMany
   */
  export type ScenarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    /**
     * Filter, which Scenarios to fetch.
     */
    where?: ScenarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Scenarios to fetch.
     */
    orderBy?: ScenarioOrderByWithRelationInput | ScenarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Scenarios.
     */
    cursor?: ScenarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Scenarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Scenarios.
     */
    skip?: number
    distinct?: ScenarioScalarFieldEnum | ScenarioScalarFieldEnum[]
  }

  /**
   * Scenario create
   */
  export type ScenarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    /**
     * The data needed to create a Scenario.
     */
    data: XOR<ScenarioCreateInput, ScenarioUncheckedCreateInput>
  }

  /**
   * Scenario createMany
   */
  export type ScenarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Scenarios.
     */
    data: ScenarioCreateManyInput | ScenarioCreateManyInput[]
  }

  /**
   * Scenario createManyAndReturn
   */
  export type ScenarioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Scenarios.
     */
    data: ScenarioCreateManyInput | ScenarioCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Scenario update
   */
  export type ScenarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    /**
     * The data needed to update a Scenario.
     */
    data: XOR<ScenarioUpdateInput, ScenarioUncheckedUpdateInput>
    /**
     * Choose, which Scenario to update.
     */
    where: ScenarioWhereUniqueInput
  }

  /**
   * Scenario updateMany
   */
  export type ScenarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Scenarios.
     */
    data: XOR<ScenarioUpdateManyMutationInput, ScenarioUncheckedUpdateManyInput>
    /**
     * Filter which Scenarios to update
     */
    where?: ScenarioWhereInput
  }

  /**
   * Scenario upsert
   */
  export type ScenarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    /**
     * The filter to search for the Scenario to update in case it exists.
     */
    where: ScenarioWhereUniqueInput
    /**
     * In case the Scenario found by the `where` argument doesn't exist, create a new Scenario with this data.
     */
    create: XOR<ScenarioCreateInput, ScenarioUncheckedCreateInput>
    /**
     * In case the Scenario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScenarioUpdateInput, ScenarioUncheckedUpdateInput>
  }

  /**
   * Scenario delete
   */
  export type ScenarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    /**
     * Filter which Scenario to delete.
     */
    where: ScenarioWhereUniqueInput
  }

  /**
   * Scenario deleteMany
   */
  export type ScenarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Scenarios to delete
     */
    where?: ScenarioWhereInput
  }

  /**
   * Scenario without action
   */
  export type ScenarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
  }


  /**
   * Model BankConnection
   */

  export type AggregateBankConnection = {
    _count: BankConnectionCountAggregateOutputType | null
    _min: BankConnectionMinAggregateOutputType | null
    _max: BankConnectionMaxAggregateOutputType | null
  }

  export type BankConnectionMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    accountId: string | null
    bankName: string | null
    bankCode: string | null
    accessToken: string | null
    status: string | null
    lastSyncAt: Date | null
    lastSyncError: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BankConnectionMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    accountId: string | null
    bankName: string | null
    bankCode: string | null
    accessToken: string | null
    status: string | null
    lastSyncAt: Date | null
    lastSyncError: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BankConnectionCountAggregateOutputType = {
    id: number
    workspaceId: number
    accountId: number
    bankName: number
    bankCode: number
    accessToken: number
    status: number
    lastSyncAt: number
    lastSyncError: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BankConnectionMinAggregateInputType = {
    id?: true
    workspaceId?: true
    accountId?: true
    bankName?: true
    bankCode?: true
    accessToken?: true
    status?: true
    lastSyncAt?: true
    lastSyncError?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BankConnectionMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    accountId?: true
    bankName?: true
    bankCode?: true
    accessToken?: true
    status?: true
    lastSyncAt?: true
    lastSyncError?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BankConnectionCountAggregateInputType = {
    id?: true
    workspaceId?: true
    accountId?: true
    bankName?: true
    bankCode?: true
    accessToken?: true
    status?: true
    lastSyncAt?: true
    lastSyncError?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BankConnectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BankConnection to aggregate.
     */
    where?: BankConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankConnections to fetch.
     */
    orderBy?: BankConnectionOrderByWithRelationInput | BankConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BankConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankConnections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankConnections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BankConnections
    **/
    _count?: true | BankConnectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BankConnectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BankConnectionMaxAggregateInputType
  }

  export type GetBankConnectionAggregateType<T extends BankConnectionAggregateArgs> = {
        [P in keyof T & keyof AggregateBankConnection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBankConnection[P]>
      : GetScalarType<T[P], AggregateBankConnection[P]>
  }




  export type BankConnectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BankConnectionWhereInput
    orderBy?: BankConnectionOrderByWithAggregationInput | BankConnectionOrderByWithAggregationInput[]
    by: BankConnectionScalarFieldEnum[] | BankConnectionScalarFieldEnum
    having?: BankConnectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BankConnectionCountAggregateInputType | true
    _min?: BankConnectionMinAggregateInputType
    _max?: BankConnectionMaxAggregateInputType
  }

  export type BankConnectionGroupByOutputType = {
    id: string
    workspaceId: string
    accountId: string
    bankName: string
    bankCode: string
    accessToken: string
    status: string
    lastSyncAt: Date | null
    lastSyncError: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: BankConnectionCountAggregateOutputType | null
    _min: BankConnectionMinAggregateOutputType | null
    _max: BankConnectionMaxAggregateOutputType | null
  }

  type GetBankConnectionGroupByPayload<T extends BankConnectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BankConnectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BankConnectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BankConnectionGroupByOutputType[P]>
            : GetScalarType<T[P], BankConnectionGroupByOutputType[P]>
        }
      >
    >


  export type BankConnectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    accountId?: boolean
    bankName?: boolean
    bankCode?: boolean
    accessToken?: boolean
    status?: boolean
    lastSyncAt?: boolean
    lastSyncError?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    Account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bankConnection"]>

  export type BankConnectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    accountId?: boolean
    bankName?: boolean
    bankCode?: boolean
    accessToken?: boolean
    status?: boolean
    lastSyncAt?: boolean
    lastSyncError?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    Account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bankConnection"]>

  export type BankConnectionSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    accountId?: boolean
    bankName?: boolean
    bankCode?: boolean
    accessToken?: boolean
    status?: boolean
    lastSyncAt?: boolean
    lastSyncError?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BankConnectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    Account?: boolean | AccountDefaultArgs<ExtArgs>
  }
  export type BankConnectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    Account?: boolean | AccountDefaultArgs<ExtArgs>
  }

  export type $BankConnectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BankConnection"
    objects: {
      Workspace: Prisma.$WorkspacePayload<ExtArgs>
      Account: Prisma.$AccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      accountId: string
      bankName: string
      bankCode: string
      accessToken: string
      status: string
      lastSyncAt: Date | null
      lastSyncError: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bankConnection"]>
    composites: {}
  }

  type BankConnectionGetPayload<S extends boolean | null | undefined | BankConnectionDefaultArgs> = $Result.GetResult<Prisma.$BankConnectionPayload, S>

  type BankConnectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BankConnectionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BankConnectionCountAggregateInputType | true
    }

  export interface BankConnectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BankConnection'], meta: { name: 'BankConnection' } }
    /**
     * Find zero or one BankConnection that matches the filter.
     * @param {BankConnectionFindUniqueArgs} args - Arguments to find a BankConnection
     * @example
     * // Get one BankConnection
     * const bankConnection = await prisma.bankConnection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BankConnectionFindUniqueArgs>(args: SelectSubset<T, BankConnectionFindUniqueArgs<ExtArgs>>): Prisma__BankConnectionClient<$Result.GetResult<Prisma.$BankConnectionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BankConnection that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BankConnectionFindUniqueOrThrowArgs} args - Arguments to find a BankConnection
     * @example
     * // Get one BankConnection
     * const bankConnection = await prisma.bankConnection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BankConnectionFindUniqueOrThrowArgs>(args: SelectSubset<T, BankConnectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BankConnectionClient<$Result.GetResult<Prisma.$BankConnectionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BankConnection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankConnectionFindFirstArgs} args - Arguments to find a BankConnection
     * @example
     * // Get one BankConnection
     * const bankConnection = await prisma.bankConnection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BankConnectionFindFirstArgs>(args?: SelectSubset<T, BankConnectionFindFirstArgs<ExtArgs>>): Prisma__BankConnectionClient<$Result.GetResult<Prisma.$BankConnectionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BankConnection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankConnectionFindFirstOrThrowArgs} args - Arguments to find a BankConnection
     * @example
     * // Get one BankConnection
     * const bankConnection = await prisma.bankConnection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BankConnectionFindFirstOrThrowArgs>(args?: SelectSubset<T, BankConnectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__BankConnectionClient<$Result.GetResult<Prisma.$BankConnectionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BankConnections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankConnectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BankConnections
     * const bankConnections = await prisma.bankConnection.findMany()
     * 
     * // Get first 10 BankConnections
     * const bankConnections = await prisma.bankConnection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bankConnectionWithIdOnly = await prisma.bankConnection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BankConnectionFindManyArgs>(args?: SelectSubset<T, BankConnectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankConnectionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BankConnection.
     * @param {BankConnectionCreateArgs} args - Arguments to create a BankConnection.
     * @example
     * // Create one BankConnection
     * const BankConnection = await prisma.bankConnection.create({
     *   data: {
     *     // ... data to create a BankConnection
     *   }
     * })
     * 
     */
    create<T extends BankConnectionCreateArgs>(args: SelectSubset<T, BankConnectionCreateArgs<ExtArgs>>): Prisma__BankConnectionClient<$Result.GetResult<Prisma.$BankConnectionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BankConnections.
     * @param {BankConnectionCreateManyArgs} args - Arguments to create many BankConnections.
     * @example
     * // Create many BankConnections
     * const bankConnection = await prisma.bankConnection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BankConnectionCreateManyArgs>(args?: SelectSubset<T, BankConnectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BankConnections and returns the data saved in the database.
     * @param {BankConnectionCreateManyAndReturnArgs} args - Arguments to create many BankConnections.
     * @example
     * // Create many BankConnections
     * const bankConnection = await prisma.bankConnection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BankConnections and only return the `id`
     * const bankConnectionWithIdOnly = await prisma.bankConnection.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BankConnectionCreateManyAndReturnArgs>(args?: SelectSubset<T, BankConnectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankConnectionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BankConnection.
     * @param {BankConnectionDeleteArgs} args - Arguments to delete one BankConnection.
     * @example
     * // Delete one BankConnection
     * const BankConnection = await prisma.bankConnection.delete({
     *   where: {
     *     // ... filter to delete one BankConnection
     *   }
     * })
     * 
     */
    delete<T extends BankConnectionDeleteArgs>(args: SelectSubset<T, BankConnectionDeleteArgs<ExtArgs>>): Prisma__BankConnectionClient<$Result.GetResult<Prisma.$BankConnectionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BankConnection.
     * @param {BankConnectionUpdateArgs} args - Arguments to update one BankConnection.
     * @example
     * // Update one BankConnection
     * const bankConnection = await prisma.bankConnection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BankConnectionUpdateArgs>(args: SelectSubset<T, BankConnectionUpdateArgs<ExtArgs>>): Prisma__BankConnectionClient<$Result.GetResult<Prisma.$BankConnectionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BankConnections.
     * @param {BankConnectionDeleteManyArgs} args - Arguments to filter BankConnections to delete.
     * @example
     * // Delete a few BankConnections
     * const { count } = await prisma.bankConnection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BankConnectionDeleteManyArgs>(args?: SelectSubset<T, BankConnectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BankConnections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankConnectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BankConnections
     * const bankConnection = await prisma.bankConnection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BankConnectionUpdateManyArgs>(args: SelectSubset<T, BankConnectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BankConnection.
     * @param {BankConnectionUpsertArgs} args - Arguments to update or create a BankConnection.
     * @example
     * // Update or create a BankConnection
     * const bankConnection = await prisma.bankConnection.upsert({
     *   create: {
     *     // ... data to create a BankConnection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BankConnection we want to update
     *   }
     * })
     */
    upsert<T extends BankConnectionUpsertArgs>(args: SelectSubset<T, BankConnectionUpsertArgs<ExtArgs>>): Prisma__BankConnectionClient<$Result.GetResult<Prisma.$BankConnectionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BankConnections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankConnectionCountArgs} args - Arguments to filter BankConnections to count.
     * @example
     * // Count the number of BankConnections
     * const count = await prisma.bankConnection.count({
     *   where: {
     *     // ... the filter for the BankConnections we want to count
     *   }
     * })
    **/
    count<T extends BankConnectionCountArgs>(
      args?: Subset<T, BankConnectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BankConnectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BankConnection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankConnectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BankConnectionAggregateArgs>(args: Subset<T, BankConnectionAggregateArgs>): Prisma.PrismaPromise<GetBankConnectionAggregateType<T>>

    /**
     * Group by BankConnection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankConnectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BankConnectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BankConnectionGroupByArgs['orderBy'] }
        : { orderBy?: BankConnectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BankConnectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBankConnectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BankConnection model
   */
  readonly fields: BankConnectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BankConnection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BankConnectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BankConnection model
   */ 
  interface BankConnectionFieldRefs {
    readonly id: FieldRef<"BankConnection", 'String'>
    readonly workspaceId: FieldRef<"BankConnection", 'String'>
    readonly accountId: FieldRef<"BankConnection", 'String'>
    readonly bankName: FieldRef<"BankConnection", 'String'>
    readonly bankCode: FieldRef<"BankConnection", 'String'>
    readonly accessToken: FieldRef<"BankConnection", 'String'>
    readonly status: FieldRef<"BankConnection", 'String'>
    readonly lastSyncAt: FieldRef<"BankConnection", 'DateTime'>
    readonly lastSyncError: FieldRef<"BankConnection", 'String'>
    readonly isActive: FieldRef<"BankConnection", 'Boolean'>
    readonly createdAt: FieldRef<"BankConnection", 'DateTime'>
    readonly updatedAt: FieldRef<"BankConnection", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BankConnection findUnique
   */
  export type BankConnectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankConnection
     */
    select?: BankConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankConnectionInclude<ExtArgs> | null
    /**
     * Filter, which BankConnection to fetch.
     */
    where: BankConnectionWhereUniqueInput
  }

  /**
   * BankConnection findUniqueOrThrow
   */
  export type BankConnectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankConnection
     */
    select?: BankConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankConnectionInclude<ExtArgs> | null
    /**
     * Filter, which BankConnection to fetch.
     */
    where: BankConnectionWhereUniqueInput
  }

  /**
   * BankConnection findFirst
   */
  export type BankConnectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankConnection
     */
    select?: BankConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankConnectionInclude<ExtArgs> | null
    /**
     * Filter, which BankConnection to fetch.
     */
    where?: BankConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankConnections to fetch.
     */
    orderBy?: BankConnectionOrderByWithRelationInput | BankConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BankConnections.
     */
    cursor?: BankConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankConnections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankConnections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BankConnections.
     */
    distinct?: BankConnectionScalarFieldEnum | BankConnectionScalarFieldEnum[]
  }

  /**
   * BankConnection findFirstOrThrow
   */
  export type BankConnectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankConnection
     */
    select?: BankConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankConnectionInclude<ExtArgs> | null
    /**
     * Filter, which BankConnection to fetch.
     */
    where?: BankConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankConnections to fetch.
     */
    orderBy?: BankConnectionOrderByWithRelationInput | BankConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BankConnections.
     */
    cursor?: BankConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankConnections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankConnections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BankConnections.
     */
    distinct?: BankConnectionScalarFieldEnum | BankConnectionScalarFieldEnum[]
  }

  /**
   * BankConnection findMany
   */
  export type BankConnectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankConnection
     */
    select?: BankConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankConnectionInclude<ExtArgs> | null
    /**
     * Filter, which BankConnections to fetch.
     */
    where?: BankConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankConnections to fetch.
     */
    orderBy?: BankConnectionOrderByWithRelationInput | BankConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BankConnections.
     */
    cursor?: BankConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankConnections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankConnections.
     */
    skip?: number
    distinct?: BankConnectionScalarFieldEnum | BankConnectionScalarFieldEnum[]
  }

  /**
   * BankConnection create
   */
  export type BankConnectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankConnection
     */
    select?: BankConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankConnectionInclude<ExtArgs> | null
    /**
     * The data needed to create a BankConnection.
     */
    data: XOR<BankConnectionCreateInput, BankConnectionUncheckedCreateInput>
  }

  /**
   * BankConnection createMany
   */
  export type BankConnectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BankConnections.
     */
    data: BankConnectionCreateManyInput | BankConnectionCreateManyInput[]
  }

  /**
   * BankConnection createManyAndReturn
   */
  export type BankConnectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankConnection
     */
    select?: BankConnectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BankConnections.
     */
    data: BankConnectionCreateManyInput | BankConnectionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankConnectionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BankConnection update
   */
  export type BankConnectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankConnection
     */
    select?: BankConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankConnectionInclude<ExtArgs> | null
    /**
     * The data needed to update a BankConnection.
     */
    data: XOR<BankConnectionUpdateInput, BankConnectionUncheckedUpdateInput>
    /**
     * Choose, which BankConnection to update.
     */
    where: BankConnectionWhereUniqueInput
  }

  /**
   * BankConnection updateMany
   */
  export type BankConnectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BankConnections.
     */
    data: XOR<BankConnectionUpdateManyMutationInput, BankConnectionUncheckedUpdateManyInput>
    /**
     * Filter which BankConnections to update
     */
    where?: BankConnectionWhereInput
  }

  /**
   * BankConnection upsert
   */
  export type BankConnectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankConnection
     */
    select?: BankConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankConnectionInclude<ExtArgs> | null
    /**
     * The filter to search for the BankConnection to update in case it exists.
     */
    where: BankConnectionWhereUniqueInput
    /**
     * In case the BankConnection found by the `where` argument doesn't exist, create a new BankConnection with this data.
     */
    create: XOR<BankConnectionCreateInput, BankConnectionUncheckedCreateInput>
    /**
     * In case the BankConnection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BankConnectionUpdateInput, BankConnectionUncheckedUpdateInput>
  }

  /**
   * BankConnection delete
   */
  export type BankConnectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankConnection
     */
    select?: BankConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankConnectionInclude<ExtArgs> | null
    /**
     * Filter which BankConnection to delete.
     */
    where: BankConnectionWhereUniqueInput
  }

  /**
   * BankConnection deleteMany
   */
  export type BankConnectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BankConnections to delete
     */
    where?: BankConnectionWhereInput
  }

  /**
   * BankConnection without action
   */
  export type BankConnectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankConnection
     */
    select?: BankConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankConnectionInclude<ExtArgs> | null
  }


  /**
   * Model AutoRule
   */

  export type AggregateAutoRule = {
    _count: AutoRuleCountAggregateOutputType | null
    _avg: AutoRuleAvgAggregateOutputType | null
    _sum: AutoRuleSumAggregateOutputType | null
    _min: AutoRuleMinAggregateOutputType | null
    _max: AutoRuleMaxAggregateOutputType | null
  }

  export type AutoRuleAvgAggregateOutputType = {
    priority: number | null
    timesApplied: number | null
  }

  export type AutoRuleSumAggregateOutputType = {
    priority: number | null
    timesApplied: number | null
  }

  export type AutoRuleMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    userId: string | null
    name: string | null
    description: string | null
    isActive: boolean | null
    priority: number | null
    conditions: string | null
    actions: string | null
    timesApplied: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AutoRuleMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    userId: string | null
    name: string | null
    description: string | null
    isActive: boolean | null
    priority: number | null
    conditions: string | null
    actions: string | null
    timesApplied: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AutoRuleCountAggregateOutputType = {
    id: number
    workspaceId: number
    userId: number
    name: number
    description: number
    isActive: number
    priority: number
    conditions: number
    actions: number
    timesApplied: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AutoRuleAvgAggregateInputType = {
    priority?: true
    timesApplied?: true
  }

  export type AutoRuleSumAggregateInputType = {
    priority?: true
    timesApplied?: true
  }

  export type AutoRuleMinAggregateInputType = {
    id?: true
    workspaceId?: true
    userId?: true
    name?: true
    description?: true
    isActive?: true
    priority?: true
    conditions?: true
    actions?: true
    timesApplied?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AutoRuleMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    userId?: true
    name?: true
    description?: true
    isActive?: true
    priority?: true
    conditions?: true
    actions?: true
    timesApplied?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AutoRuleCountAggregateInputType = {
    id?: true
    workspaceId?: true
    userId?: true
    name?: true
    description?: true
    isActive?: true
    priority?: true
    conditions?: true
    actions?: true
    timesApplied?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AutoRuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutoRule to aggregate.
     */
    where?: AutoRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoRules to fetch.
     */
    orderBy?: AutoRuleOrderByWithRelationInput | AutoRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AutoRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AutoRules
    **/
    _count?: true | AutoRuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AutoRuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AutoRuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AutoRuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AutoRuleMaxAggregateInputType
  }

  export type GetAutoRuleAggregateType<T extends AutoRuleAggregateArgs> = {
        [P in keyof T & keyof AggregateAutoRule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutoRule[P]>
      : GetScalarType<T[P], AggregateAutoRule[P]>
  }




  export type AutoRuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutoRuleWhereInput
    orderBy?: AutoRuleOrderByWithAggregationInput | AutoRuleOrderByWithAggregationInput[]
    by: AutoRuleScalarFieldEnum[] | AutoRuleScalarFieldEnum
    having?: AutoRuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AutoRuleCountAggregateInputType | true
    _avg?: AutoRuleAvgAggregateInputType
    _sum?: AutoRuleSumAggregateInputType
    _min?: AutoRuleMinAggregateInputType
    _max?: AutoRuleMaxAggregateInputType
  }

  export type AutoRuleGroupByOutputType = {
    id: string
    workspaceId: string
    userId: string
    name: string
    description: string | null
    isActive: boolean
    priority: number
    conditions: string
    actions: string
    timesApplied: number
    createdAt: Date
    updatedAt: Date
    _count: AutoRuleCountAggregateOutputType | null
    _avg: AutoRuleAvgAggregateOutputType | null
    _sum: AutoRuleSumAggregateOutputType | null
    _min: AutoRuleMinAggregateOutputType | null
    _max: AutoRuleMaxAggregateOutputType | null
  }

  type GetAutoRuleGroupByPayload<T extends AutoRuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AutoRuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AutoRuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AutoRuleGroupByOutputType[P]>
            : GetScalarType<T[P], AutoRuleGroupByOutputType[P]>
        }
      >
    >


  export type AutoRuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    priority?: boolean
    conditions?: boolean
    actions?: boolean
    timesApplied?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    Workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["autoRule"]>

  export type AutoRuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    priority?: boolean
    conditions?: boolean
    actions?: boolean
    timesApplied?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    Workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["autoRule"]>

  export type AutoRuleSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    priority?: boolean
    conditions?: boolean
    actions?: boolean
    timesApplied?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AutoRuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    Workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type AutoRuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    Workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $AutoRulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AutoRule"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
      Workspace: Prisma.$WorkspacePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      userId: string
      name: string
      description: string | null
      isActive: boolean
      priority: number
      conditions: string
      actions: string
      timesApplied: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["autoRule"]>
    composites: {}
  }

  type AutoRuleGetPayload<S extends boolean | null | undefined | AutoRuleDefaultArgs> = $Result.GetResult<Prisma.$AutoRulePayload, S>

  type AutoRuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AutoRuleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AutoRuleCountAggregateInputType | true
    }

  export interface AutoRuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AutoRule'], meta: { name: 'AutoRule' } }
    /**
     * Find zero or one AutoRule that matches the filter.
     * @param {AutoRuleFindUniqueArgs} args - Arguments to find a AutoRule
     * @example
     * // Get one AutoRule
     * const autoRule = await prisma.autoRule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AutoRuleFindUniqueArgs>(args: SelectSubset<T, AutoRuleFindUniqueArgs<ExtArgs>>): Prisma__AutoRuleClient<$Result.GetResult<Prisma.$AutoRulePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AutoRule that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AutoRuleFindUniqueOrThrowArgs} args - Arguments to find a AutoRule
     * @example
     * // Get one AutoRule
     * const autoRule = await prisma.autoRule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AutoRuleFindUniqueOrThrowArgs>(args: SelectSubset<T, AutoRuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AutoRuleClient<$Result.GetResult<Prisma.$AutoRulePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AutoRule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoRuleFindFirstArgs} args - Arguments to find a AutoRule
     * @example
     * // Get one AutoRule
     * const autoRule = await prisma.autoRule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AutoRuleFindFirstArgs>(args?: SelectSubset<T, AutoRuleFindFirstArgs<ExtArgs>>): Prisma__AutoRuleClient<$Result.GetResult<Prisma.$AutoRulePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AutoRule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoRuleFindFirstOrThrowArgs} args - Arguments to find a AutoRule
     * @example
     * // Get one AutoRule
     * const autoRule = await prisma.autoRule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AutoRuleFindFirstOrThrowArgs>(args?: SelectSubset<T, AutoRuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__AutoRuleClient<$Result.GetResult<Prisma.$AutoRulePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AutoRules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoRuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AutoRules
     * const autoRules = await prisma.autoRule.findMany()
     * 
     * // Get first 10 AutoRules
     * const autoRules = await prisma.autoRule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const autoRuleWithIdOnly = await prisma.autoRule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AutoRuleFindManyArgs>(args?: SelectSubset<T, AutoRuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutoRulePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AutoRule.
     * @param {AutoRuleCreateArgs} args - Arguments to create a AutoRule.
     * @example
     * // Create one AutoRule
     * const AutoRule = await prisma.autoRule.create({
     *   data: {
     *     // ... data to create a AutoRule
     *   }
     * })
     * 
     */
    create<T extends AutoRuleCreateArgs>(args: SelectSubset<T, AutoRuleCreateArgs<ExtArgs>>): Prisma__AutoRuleClient<$Result.GetResult<Prisma.$AutoRulePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AutoRules.
     * @param {AutoRuleCreateManyArgs} args - Arguments to create many AutoRules.
     * @example
     * // Create many AutoRules
     * const autoRule = await prisma.autoRule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AutoRuleCreateManyArgs>(args?: SelectSubset<T, AutoRuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AutoRules and returns the data saved in the database.
     * @param {AutoRuleCreateManyAndReturnArgs} args - Arguments to create many AutoRules.
     * @example
     * // Create many AutoRules
     * const autoRule = await prisma.autoRule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AutoRules and only return the `id`
     * const autoRuleWithIdOnly = await prisma.autoRule.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AutoRuleCreateManyAndReturnArgs>(args?: SelectSubset<T, AutoRuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutoRulePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AutoRule.
     * @param {AutoRuleDeleteArgs} args - Arguments to delete one AutoRule.
     * @example
     * // Delete one AutoRule
     * const AutoRule = await prisma.autoRule.delete({
     *   where: {
     *     // ... filter to delete one AutoRule
     *   }
     * })
     * 
     */
    delete<T extends AutoRuleDeleteArgs>(args: SelectSubset<T, AutoRuleDeleteArgs<ExtArgs>>): Prisma__AutoRuleClient<$Result.GetResult<Prisma.$AutoRulePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AutoRule.
     * @param {AutoRuleUpdateArgs} args - Arguments to update one AutoRule.
     * @example
     * // Update one AutoRule
     * const autoRule = await prisma.autoRule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AutoRuleUpdateArgs>(args: SelectSubset<T, AutoRuleUpdateArgs<ExtArgs>>): Prisma__AutoRuleClient<$Result.GetResult<Prisma.$AutoRulePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AutoRules.
     * @param {AutoRuleDeleteManyArgs} args - Arguments to filter AutoRules to delete.
     * @example
     * // Delete a few AutoRules
     * const { count } = await prisma.autoRule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AutoRuleDeleteManyArgs>(args?: SelectSubset<T, AutoRuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AutoRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoRuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AutoRules
     * const autoRule = await prisma.autoRule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AutoRuleUpdateManyArgs>(args: SelectSubset<T, AutoRuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AutoRule.
     * @param {AutoRuleUpsertArgs} args - Arguments to update or create a AutoRule.
     * @example
     * // Update or create a AutoRule
     * const autoRule = await prisma.autoRule.upsert({
     *   create: {
     *     // ... data to create a AutoRule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AutoRule we want to update
     *   }
     * })
     */
    upsert<T extends AutoRuleUpsertArgs>(args: SelectSubset<T, AutoRuleUpsertArgs<ExtArgs>>): Prisma__AutoRuleClient<$Result.GetResult<Prisma.$AutoRulePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AutoRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoRuleCountArgs} args - Arguments to filter AutoRules to count.
     * @example
     * // Count the number of AutoRules
     * const count = await prisma.autoRule.count({
     *   where: {
     *     // ... the filter for the AutoRules we want to count
     *   }
     * })
    **/
    count<T extends AutoRuleCountArgs>(
      args?: Subset<T, AutoRuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AutoRuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AutoRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoRuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AutoRuleAggregateArgs>(args: Subset<T, AutoRuleAggregateArgs>): Prisma.PrismaPromise<GetAutoRuleAggregateType<T>>

    /**
     * Group by AutoRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoRuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AutoRuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AutoRuleGroupByArgs['orderBy'] }
        : { orderBy?: AutoRuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AutoRuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutoRuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AutoRule model
   */
  readonly fields: AutoRuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AutoRule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AutoRuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AutoRule model
   */ 
  interface AutoRuleFieldRefs {
    readonly id: FieldRef<"AutoRule", 'String'>
    readonly workspaceId: FieldRef<"AutoRule", 'String'>
    readonly userId: FieldRef<"AutoRule", 'String'>
    readonly name: FieldRef<"AutoRule", 'String'>
    readonly description: FieldRef<"AutoRule", 'String'>
    readonly isActive: FieldRef<"AutoRule", 'Boolean'>
    readonly priority: FieldRef<"AutoRule", 'Int'>
    readonly conditions: FieldRef<"AutoRule", 'String'>
    readonly actions: FieldRef<"AutoRule", 'String'>
    readonly timesApplied: FieldRef<"AutoRule", 'Int'>
    readonly createdAt: FieldRef<"AutoRule", 'DateTime'>
    readonly updatedAt: FieldRef<"AutoRule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AutoRule findUnique
   */
  export type AutoRuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoRule
     */
    select?: AutoRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoRuleInclude<ExtArgs> | null
    /**
     * Filter, which AutoRule to fetch.
     */
    where: AutoRuleWhereUniqueInput
  }

  /**
   * AutoRule findUniqueOrThrow
   */
  export type AutoRuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoRule
     */
    select?: AutoRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoRuleInclude<ExtArgs> | null
    /**
     * Filter, which AutoRule to fetch.
     */
    where: AutoRuleWhereUniqueInput
  }

  /**
   * AutoRule findFirst
   */
  export type AutoRuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoRule
     */
    select?: AutoRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoRuleInclude<ExtArgs> | null
    /**
     * Filter, which AutoRule to fetch.
     */
    where?: AutoRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoRules to fetch.
     */
    orderBy?: AutoRuleOrderByWithRelationInput | AutoRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutoRules.
     */
    cursor?: AutoRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutoRules.
     */
    distinct?: AutoRuleScalarFieldEnum | AutoRuleScalarFieldEnum[]
  }

  /**
   * AutoRule findFirstOrThrow
   */
  export type AutoRuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoRule
     */
    select?: AutoRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoRuleInclude<ExtArgs> | null
    /**
     * Filter, which AutoRule to fetch.
     */
    where?: AutoRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoRules to fetch.
     */
    orderBy?: AutoRuleOrderByWithRelationInput | AutoRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutoRules.
     */
    cursor?: AutoRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutoRules.
     */
    distinct?: AutoRuleScalarFieldEnum | AutoRuleScalarFieldEnum[]
  }

  /**
   * AutoRule findMany
   */
  export type AutoRuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoRule
     */
    select?: AutoRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoRuleInclude<ExtArgs> | null
    /**
     * Filter, which AutoRules to fetch.
     */
    where?: AutoRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoRules to fetch.
     */
    orderBy?: AutoRuleOrderByWithRelationInput | AutoRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AutoRules.
     */
    cursor?: AutoRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoRules.
     */
    skip?: number
    distinct?: AutoRuleScalarFieldEnum | AutoRuleScalarFieldEnum[]
  }

  /**
   * AutoRule create
   */
  export type AutoRuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoRule
     */
    select?: AutoRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoRuleInclude<ExtArgs> | null
    /**
     * The data needed to create a AutoRule.
     */
    data: XOR<AutoRuleCreateInput, AutoRuleUncheckedCreateInput>
  }

  /**
   * AutoRule createMany
   */
  export type AutoRuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AutoRules.
     */
    data: AutoRuleCreateManyInput | AutoRuleCreateManyInput[]
  }

  /**
   * AutoRule createManyAndReturn
   */
  export type AutoRuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoRule
     */
    select?: AutoRuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AutoRules.
     */
    data: AutoRuleCreateManyInput | AutoRuleCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoRuleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AutoRule update
   */
  export type AutoRuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoRule
     */
    select?: AutoRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoRuleInclude<ExtArgs> | null
    /**
     * The data needed to update a AutoRule.
     */
    data: XOR<AutoRuleUpdateInput, AutoRuleUncheckedUpdateInput>
    /**
     * Choose, which AutoRule to update.
     */
    where: AutoRuleWhereUniqueInput
  }

  /**
   * AutoRule updateMany
   */
  export type AutoRuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AutoRules.
     */
    data: XOR<AutoRuleUpdateManyMutationInput, AutoRuleUncheckedUpdateManyInput>
    /**
     * Filter which AutoRules to update
     */
    where?: AutoRuleWhereInput
  }

  /**
   * AutoRule upsert
   */
  export type AutoRuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoRule
     */
    select?: AutoRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoRuleInclude<ExtArgs> | null
    /**
     * The filter to search for the AutoRule to update in case it exists.
     */
    where: AutoRuleWhereUniqueInput
    /**
     * In case the AutoRule found by the `where` argument doesn't exist, create a new AutoRule with this data.
     */
    create: XOR<AutoRuleCreateInput, AutoRuleUncheckedCreateInput>
    /**
     * In case the AutoRule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AutoRuleUpdateInput, AutoRuleUncheckedUpdateInput>
  }

  /**
   * AutoRule delete
   */
  export type AutoRuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoRule
     */
    select?: AutoRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoRuleInclude<ExtArgs> | null
    /**
     * Filter which AutoRule to delete.
     */
    where: AutoRuleWhereUniqueInput
  }

  /**
   * AutoRule deleteMany
   */
  export type AutoRuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutoRules to delete
     */
    where?: AutoRuleWhereInput
  }

  /**
   * AutoRule without action
   */
  export type AutoRuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoRule
     */
    select?: AutoRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoRuleInclude<ExtArgs> | null
  }


  /**
   * Model CashFlowProjection
   */

  export type AggregateCashFlowProjection = {
    _count: CashFlowProjectionCountAggregateOutputType | null
    _avg: CashFlowProjectionAvgAggregateOutputType | null
    _sum: CashFlowProjectionSumAggregateOutputType | null
    _min: CashFlowProjectionMinAggregateOutputType | null
    _max: CashFlowProjectionMaxAggregateOutputType | null
  }

  export type CashFlowProjectionAvgAggregateOutputType = {
    month: number | null
    year: number | null
    projectedIncome: number | null
    projectedExpense: number | null
    projectedBalance: number | null
  }

  export type CashFlowProjectionSumAggregateOutputType = {
    month: number | null
    year: number | null
    projectedIncome: number | null
    projectedExpense: number | null
    projectedBalance: number | null
  }

  export type CashFlowProjectionMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    month: number | null
    year: number | null
    projectedIncome: number | null
    projectedExpense: number | null
    projectedBalance: number | null
    generatedAt: Date | null
    updatedAt: Date | null
  }

  export type CashFlowProjectionMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    month: number | null
    year: number | null
    projectedIncome: number | null
    projectedExpense: number | null
    projectedBalance: number | null
    generatedAt: Date | null
    updatedAt: Date | null
  }

  export type CashFlowProjectionCountAggregateOutputType = {
    id: number
    workspaceId: number
    month: number
    year: number
    projectedIncome: number
    projectedExpense: number
    projectedBalance: number
    generatedAt: number
    updatedAt: number
    _all: number
  }


  export type CashFlowProjectionAvgAggregateInputType = {
    month?: true
    year?: true
    projectedIncome?: true
    projectedExpense?: true
    projectedBalance?: true
  }

  export type CashFlowProjectionSumAggregateInputType = {
    month?: true
    year?: true
    projectedIncome?: true
    projectedExpense?: true
    projectedBalance?: true
  }

  export type CashFlowProjectionMinAggregateInputType = {
    id?: true
    workspaceId?: true
    month?: true
    year?: true
    projectedIncome?: true
    projectedExpense?: true
    projectedBalance?: true
    generatedAt?: true
    updatedAt?: true
  }

  export type CashFlowProjectionMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    month?: true
    year?: true
    projectedIncome?: true
    projectedExpense?: true
    projectedBalance?: true
    generatedAt?: true
    updatedAt?: true
  }

  export type CashFlowProjectionCountAggregateInputType = {
    id?: true
    workspaceId?: true
    month?: true
    year?: true
    projectedIncome?: true
    projectedExpense?: true
    projectedBalance?: true
    generatedAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CashFlowProjectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashFlowProjection to aggregate.
     */
    where?: CashFlowProjectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashFlowProjections to fetch.
     */
    orderBy?: CashFlowProjectionOrderByWithRelationInput | CashFlowProjectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CashFlowProjectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashFlowProjections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashFlowProjections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CashFlowProjections
    **/
    _count?: true | CashFlowProjectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CashFlowProjectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CashFlowProjectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CashFlowProjectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CashFlowProjectionMaxAggregateInputType
  }

  export type GetCashFlowProjectionAggregateType<T extends CashFlowProjectionAggregateArgs> = {
        [P in keyof T & keyof AggregateCashFlowProjection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCashFlowProjection[P]>
      : GetScalarType<T[P], AggregateCashFlowProjection[P]>
  }




  export type CashFlowProjectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashFlowProjectionWhereInput
    orderBy?: CashFlowProjectionOrderByWithAggregationInput | CashFlowProjectionOrderByWithAggregationInput[]
    by: CashFlowProjectionScalarFieldEnum[] | CashFlowProjectionScalarFieldEnum
    having?: CashFlowProjectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CashFlowProjectionCountAggregateInputType | true
    _avg?: CashFlowProjectionAvgAggregateInputType
    _sum?: CashFlowProjectionSumAggregateInputType
    _min?: CashFlowProjectionMinAggregateInputType
    _max?: CashFlowProjectionMaxAggregateInputType
  }

  export type CashFlowProjectionGroupByOutputType = {
    id: string
    workspaceId: string
    month: number
    year: number
    projectedIncome: number
    projectedExpense: number
    projectedBalance: number
    generatedAt: Date
    updatedAt: Date
    _count: CashFlowProjectionCountAggregateOutputType | null
    _avg: CashFlowProjectionAvgAggregateOutputType | null
    _sum: CashFlowProjectionSumAggregateOutputType | null
    _min: CashFlowProjectionMinAggregateOutputType | null
    _max: CashFlowProjectionMaxAggregateOutputType | null
  }

  type GetCashFlowProjectionGroupByPayload<T extends CashFlowProjectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CashFlowProjectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CashFlowProjectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CashFlowProjectionGroupByOutputType[P]>
            : GetScalarType<T[P], CashFlowProjectionGroupByOutputType[P]>
        }
      >
    >


  export type CashFlowProjectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    month?: boolean
    year?: boolean
    projectedIncome?: boolean
    projectedExpense?: boolean
    projectedBalance?: boolean
    generatedAt?: boolean
    updatedAt?: boolean
    Workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cashFlowProjection"]>

  export type CashFlowProjectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    month?: boolean
    year?: boolean
    projectedIncome?: boolean
    projectedExpense?: boolean
    projectedBalance?: boolean
    generatedAt?: boolean
    updatedAt?: boolean
    Workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cashFlowProjection"]>

  export type CashFlowProjectionSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    month?: boolean
    year?: boolean
    projectedIncome?: boolean
    projectedExpense?: boolean
    projectedBalance?: boolean
    generatedAt?: boolean
    updatedAt?: boolean
  }

  export type CashFlowProjectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type CashFlowProjectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $CashFlowProjectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CashFlowProjection"
    objects: {
      Workspace: Prisma.$WorkspacePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      month: number
      year: number
      projectedIncome: number
      projectedExpense: number
      projectedBalance: number
      generatedAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cashFlowProjection"]>
    composites: {}
  }

  type CashFlowProjectionGetPayload<S extends boolean | null | undefined | CashFlowProjectionDefaultArgs> = $Result.GetResult<Prisma.$CashFlowProjectionPayload, S>

  type CashFlowProjectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CashFlowProjectionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CashFlowProjectionCountAggregateInputType | true
    }

  export interface CashFlowProjectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CashFlowProjection'], meta: { name: 'CashFlowProjection' } }
    /**
     * Find zero or one CashFlowProjection that matches the filter.
     * @param {CashFlowProjectionFindUniqueArgs} args - Arguments to find a CashFlowProjection
     * @example
     * // Get one CashFlowProjection
     * const cashFlowProjection = await prisma.cashFlowProjection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CashFlowProjectionFindUniqueArgs>(args: SelectSubset<T, CashFlowProjectionFindUniqueArgs<ExtArgs>>): Prisma__CashFlowProjectionClient<$Result.GetResult<Prisma.$CashFlowProjectionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CashFlowProjection that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CashFlowProjectionFindUniqueOrThrowArgs} args - Arguments to find a CashFlowProjection
     * @example
     * // Get one CashFlowProjection
     * const cashFlowProjection = await prisma.cashFlowProjection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CashFlowProjectionFindUniqueOrThrowArgs>(args: SelectSubset<T, CashFlowProjectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CashFlowProjectionClient<$Result.GetResult<Prisma.$CashFlowProjectionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CashFlowProjection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashFlowProjectionFindFirstArgs} args - Arguments to find a CashFlowProjection
     * @example
     * // Get one CashFlowProjection
     * const cashFlowProjection = await prisma.cashFlowProjection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CashFlowProjectionFindFirstArgs>(args?: SelectSubset<T, CashFlowProjectionFindFirstArgs<ExtArgs>>): Prisma__CashFlowProjectionClient<$Result.GetResult<Prisma.$CashFlowProjectionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CashFlowProjection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashFlowProjectionFindFirstOrThrowArgs} args - Arguments to find a CashFlowProjection
     * @example
     * // Get one CashFlowProjection
     * const cashFlowProjection = await prisma.cashFlowProjection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CashFlowProjectionFindFirstOrThrowArgs>(args?: SelectSubset<T, CashFlowProjectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CashFlowProjectionClient<$Result.GetResult<Prisma.$CashFlowProjectionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CashFlowProjections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashFlowProjectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CashFlowProjections
     * const cashFlowProjections = await prisma.cashFlowProjection.findMany()
     * 
     * // Get first 10 CashFlowProjections
     * const cashFlowProjections = await prisma.cashFlowProjection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cashFlowProjectionWithIdOnly = await prisma.cashFlowProjection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CashFlowProjectionFindManyArgs>(args?: SelectSubset<T, CashFlowProjectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashFlowProjectionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CashFlowProjection.
     * @param {CashFlowProjectionCreateArgs} args - Arguments to create a CashFlowProjection.
     * @example
     * // Create one CashFlowProjection
     * const CashFlowProjection = await prisma.cashFlowProjection.create({
     *   data: {
     *     // ... data to create a CashFlowProjection
     *   }
     * })
     * 
     */
    create<T extends CashFlowProjectionCreateArgs>(args: SelectSubset<T, CashFlowProjectionCreateArgs<ExtArgs>>): Prisma__CashFlowProjectionClient<$Result.GetResult<Prisma.$CashFlowProjectionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CashFlowProjections.
     * @param {CashFlowProjectionCreateManyArgs} args - Arguments to create many CashFlowProjections.
     * @example
     * // Create many CashFlowProjections
     * const cashFlowProjection = await prisma.cashFlowProjection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CashFlowProjectionCreateManyArgs>(args?: SelectSubset<T, CashFlowProjectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CashFlowProjections and returns the data saved in the database.
     * @param {CashFlowProjectionCreateManyAndReturnArgs} args - Arguments to create many CashFlowProjections.
     * @example
     * // Create many CashFlowProjections
     * const cashFlowProjection = await prisma.cashFlowProjection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CashFlowProjections and only return the `id`
     * const cashFlowProjectionWithIdOnly = await prisma.cashFlowProjection.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CashFlowProjectionCreateManyAndReturnArgs>(args?: SelectSubset<T, CashFlowProjectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashFlowProjectionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CashFlowProjection.
     * @param {CashFlowProjectionDeleteArgs} args - Arguments to delete one CashFlowProjection.
     * @example
     * // Delete one CashFlowProjection
     * const CashFlowProjection = await prisma.cashFlowProjection.delete({
     *   where: {
     *     // ... filter to delete one CashFlowProjection
     *   }
     * })
     * 
     */
    delete<T extends CashFlowProjectionDeleteArgs>(args: SelectSubset<T, CashFlowProjectionDeleteArgs<ExtArgs>>): Prisma__CashFlowProjectionClient<$Result.GetResult<Prisma.$CashFlowProjectionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CashFlowProjection.
     * @param {CashFlowProjectionUpdateArgs} args - Arguments to update one CashFlowProjection.
     * @example
     * // Update one CashFlowProjection
     * const cashFlowProjection = await prisma.cashFlowProjection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CashFlowProjectionUpdateArgs>(args: SelectSubset<T, CashFlowProjectionUpdateArgs<ExtArgs>>): Prisma__CashFlowProjectionClient<$Result.GetResult<Prisma.$CashFlowProjectionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CashFlowProjections.
     * @param {CashFlowProjectionDeleteManyArgs} args - Arguments to filter CashFlowProjections to delete.
     * @example
     * // Delete a few CashFlowProjections
     * const { count } = await prisma.cashFlowProjection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CashFlowProjectionDeleteManyArgs>(args?: SelectSubset<T, CashFlowProjectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CashFlowProjections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashFlowProjectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CashFlowProjections
     * const cashFlowProjection = await prisma.cashFlowProjection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CashFlowProjectionUpdateManyArgs>(args: SelectSubset<T, CashFlowProjectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CashFlowProjection.
     * @param {CashFlowProjectionUpsertArgs} args - Arguments to update or create a CashFlowProjection.
     * @example
     * // Update or create a CashFlowProjection
     * const cashFlowProjection = await prisma.cashFlowProjection.upsert({
     *   create: {
     *     // ... data to create a CashFlowProjection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CashFlowProjection we want to update
     *   }
     * })
     */
    upsert<T extends CashFlowProjectionUpsertArgs>(args: SelectSubset<T, CashFlowProjectionUpsertArgs<ExtArgs>>): Prisma__CashFlowProjectionClient<$Result.GetResult<Prisma.$CashFlowProjectionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CashFlowProjections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashFlowProjectionCountArgs} args - Arguments to filter CashFlowProjections to count.
     * @example
     * // Count the number of CashFlowProjections
     * const count = await prisma.cashFlowProjection.count({
     *   where: {
     *     // ... the filter for the CashFlowProjections we want to count
     *   }
     * })
    **/
    count<T extends CashFlowProjectionCountArgs>(
      args?: Subset<T, CashFlowProjectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CashFlowProjectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CashFlowProjection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashFlowProjectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CashFlowProjectionAggregateArgs>(args: Subset<T, CashFlowProjectionAggregateArgs>): Prisma.PrismaPromise<GetCashFlowProjectionAggregateType<T>>

    /**
     * Group by CashFlowProjection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashFlowProjectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CashFlowProjectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CashFlowProjectionGroupByArgs['orderBy'] }
        : { orderBy?: CashFlowProjectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CashFlowProjectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCashFlowProjectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CashFlowProjection model
   */
  readonly fields: CashFlowProjectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CashFlowProjection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CashFlowProjectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CashFlowProjection model
   */ 
  interface CashFlowProjectionFieldRefs {
    readonly id: FieldRef<"CashFlowProjection", 'String'>
    readonly workspaceId: FieldRef<"CashFlowProjection", 'String'>
    readonly month: FieldRef<"CashFlowProjection", 'Int'>
    readonly year: FieldRef<"CashFlowProjection", 'Int'>
    readonly projectedIncome: FieldRef<"CashFlowProjection", 'Float'>
    readonly projectedExpense: FieldRef<"CashFlowProjection", 'Float'>
    readonly projectedBalance: FieldRef<"CashFlowProjection", 'Float'>
    readonly generatedAt: FieldRef<"CashFlowProjection", 'DateTime'>
    readonly updatedAt: FieldRef<"CashFlowProjection", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CashFlowProjection findUnique
   */
  export type CashFlowProjectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashFlowProjection
     */
    select?: CashFlowProjectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashFlowProjectionInclude<ExtArgs> | null
    /**
     * Filter, which CashFlowProjection to fetch.
     */
    where: CashFlowProjectionWhereUniqueInput
  }

  /**
   * CashFlowProjection findUniqueOrThrow
   */
  export type CashFlowProjectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashFlowProjection
     */
    select?: CashFlowProjectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashFlowProjectionInclude<ExtArgs> | null
    /**
     * Filter, which CashFlowProjection to fetch.
     */
    where: CashFlowProjectionWhereUniqueInput
  }

  /**
   * CashFlowProjection findFirst
   */
  export type CashFlowProjectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashFlowProjection
     */
    select?: CashFlowProjectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashFlowProjectionInclude<ExtArgs> | null
    /**
     * Filter, which CashFlowProjection to fetch.
     */
    where?: CashFlowProjectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashFlowProjections to fetch.
     */
    orderBy?: CashFlowProjectionOrderByWithRelationInput | CashFlowProjectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashFlowProjections.
     */
    cursor?: CashFlowProjectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashFlowProjections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashFlowProjections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashFlowProjections.
     */
    distinct?: CashFlowProjectionScalarFieldEnum | CashFlowProjectionScalarFieldEnum[]
  }

  /**
   * CashFlowProjection findFirstOrThrow
   */
  export type CashFlowProjectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashFlowProjection
     */
    select?: CashFlowProjectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashFlowProjectionInclude<ExtArgs> | null
    /**
     * Filter, which CashFlowProjection to fetch.
     */
    where?: CashFlowProjectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashFlowProjections to fetch.
     */
    orderBy?: CashFlowProjectionOrderByWithRelationInput | CashFlowProjectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashFlowProjections.
     */
    cursor?: CashFlowProjectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashFlowProjections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashFlowProjections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashFlowProjections.
     */
    distinct?: CashFlowProjectionScalarFieldEnum | CashFlowProjectionScalarFieldEnum[]
  }

  /**
   * CashFlowProjection findMany
   */
  export type CashFlowProjectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashFlowProjection
     */
    select?: CashFlowProjectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashFlowProjectionInclude<ExtArgs> | null
    /**
     * Filter, which CashFlowProjections to fetch.
     */
    where?: CashFlowProjectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashFlowProjections to fetch.
     */
    orderBy?: CashFlowProjectionOrderByWithRelationInput | CashFlowProjectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CashFlowProjections.
     */
    cursor?: CashFlowProjectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashFlowProjections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashFlowProjections.
     */
    skip?: number
    distinct?: CashFlowProjectionScalarFieldEnum | CashFlowProjectionScalarFieldEnum[]
  }

  /**
   * CashFlowProjection create
   */
  export type CashFlowProjectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashFlowProjection
     */
    select?: CashFlowProjectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashFlowProjectionInclude<ExtArgs> | null
    /**
     * The data needed to create a CashFlowProjection.
     */
    data: XOR<CashFlowProjectionCreateInput, CashFlowProjectionUncheckedCreateInput>
  }

  /**
   * CashFlowProjection createMany
   */
  export type CashFlowProjectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CashFlowProjections.
     */
    data: CashFlowProjectionCreateManyInput | CashFlowProjectionCreateManyInput[]
  }

  /**
   * CashFlowProjection createManyAndReturn
   */
  export type CashFlowProjectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashFlowProjection
     */
    select?: CashFlowProjectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CashFlowProjections.
     */
    data: CashFlowProjectionCreateManyInput | CashFlowProjectionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashFlowProjectionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CashFlowProjection update
   */
  export type CashFlowProjectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashFlowProjection
     */
    select?: CashFlowProjectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashFlowProjectionInclude<ExtArgs> | null
    /**
     * The data needed to update a CashFlowProjection.
     */
    data: XOR<CashFlowProjectionUpdateInput, CashFlowProjectionUncheckedUpdateInput>
    /**
     * Choose, which CashFlowProjection to update.
     */
    where: CashFlowProjectionWhereUniqueInput
  }

  /**
   * CashFlowProjection updateMany
   */
  export type CashFlowProjectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CashFlowProjections.
     */
    data: XOR<CashFlowProjectionUpdateManyMutationInput, CashFlowProjectionUncheckedUpdateManyInput>
    /**
     * Filter which CashFlowProjections to update
     */
    where?: CashFlowProjectionWhereInput
  }

  /**
   * CashFlowProjection upsert
   */
  export type CashFlowProjectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashFlowProjection
     */
    select?: CashFlowProjectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashFlowProjectionInclude<ExtArgs> | null
    /**
     * The filter to search for the CashFlowProjection to update in case it exists.
     */
    where: CashFlowProjectionWhereUniqueInput
    /**
     * In case the CashFlowProjection found by the `where` argument doesn't exist, create a new CashFlowProjection with this data.
     */
    create: XOR<CashFlowProjectionCreateInput, CashFlowProjectionUncheckedCreateInput>
    /**
     * In case the CashFlowProjection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CashFlowProjectionUpdateInput, CashFlowProjectionUncheckedUpdateInput>
  }

  /**
   * CashFlowProjection delete
   */
  export type CashFlowProjectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashFlowProjection
     */
    select?: CashFlowProjectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashFlowProjectionInclude<ExtArgs> | null
    /**
     * Filter which CashFlowProjection to delete.
     */
    where: CashFlowProjectionWhereUniqueInput
  }

  /**
   * CashFlowProjection deleteMany
   */
  export type CashFlowProjectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashFlowProjections to delete
     */
    where?: CashFlowProjectionWhereInput
  }

  /**
   * CashFlowProjection without action
   */
  export type CashFlowProjectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashFlowProjection
     */
    select?: CashFlowProjectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashFlowProjectionInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    firstName: 'firstName',
    lastName: 'lastName',
    avatarUrl: 'avatarUrl',
    phone: 'phone',
    emailVerified: 'emailVerified',
    twoFactorEnabled: 'twoFactorEnabled',
    twoFactorSecret: 'twoFactorSecret',
    lastLoginAt: 'lastLoginAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const RefreshTokenScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    revokedAt: 'revokedAt'
  };

  export type RefreshTokenScalarFieldEnum = (typeof RefreshTokenScalarFieldEnum)[keyof typeof RefreshTokenScalarFieldEnum]


  export const PasswordResetScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    expiresAt: 'expiresAt',
    usedAt: 'usedAt',
    createdAt: 'createdAt'
  };

  export type PasswordResetScalarFieldEnum = (typeof PasswordResetScalarFieldEnum)[keyof typeof PasswordResetScalarFieldEnum]


  export const WorkspaceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    type: 'type',
    currency: 'currency',
    timezone: 'timezone',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WorkspaceScalarFieldEnum = (typeof WorkspaceScalarFieldEnum)[keyof typeof WorkspaceScalarFieldEnum]


  export const WorkspaceMemberScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    userId: 'userId',
    role: 'role',
    joinedAt: 'joinedAt',
    invitedBy: 'invitedBy'
  };

  export type WorkspaceMemberScalarFieldEnum = (typeof WorkspaceMemberScalarFieldEnum)[keyof typeof WorkspaceMemberScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    name: 'name',
    type: 'type',
    description: 'description',
    bankName: 'bankName',
    bankCode: 'bankCode',
    agency: 'agency',
    accountNumber: 'accountNumber',
    initialBalance: 'initialBalance',
    currentBalance: 'currentBalance',
    creditLimit: 'creditLimit',
    closingDay: 'closingDay',
    dueDay: 'dueDay',
    color: 'color',
    icon: 'icon',
    isActive: 'isActive',
    archivedAt: 'archivedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    parentId: 'parentId',
    name: 'name',
    type: 'type',
    color: 'color',
    icon: 'icon',
    description: 'description',
    keywords: 'keywords',
    isSystem: 'isSystem',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    accountId: 'accountId',
    categoryId: 'categoryId',
    creditCardId: 'creditCardId',
    type: 'type',
    description: 'description',
    amount: 'amount',
    currency: 'currency',
    status: 'status',
    transactionDate: 'transactionDate',
    confirmedAt: 'confirmedAt',
    recurrenceId: 'recurrenceId',
    notes: 'notes',
    tags: 'tags',
    attachmentUrl: 'attachmentUrl',
    location: 'location',
    importId: 'importId',
    rawData: 'rawData',
    aiConfidence: 'aiConfidence',
    aiCategory: 'aiCategory',
    aiCategorizedAt: 'aiCategorizedAt',
    aiModelVersion: 'aiModelVersion',
    autoRuleId: 'autoRuleId',
    bankConnectionId: 'bankConnectionId',
    externalId: 'externalId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const RecurrenceScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    accountId: 'accountId',
    categoryId: 'categoryId',
    type: 'type',
    description: 'description',
    amount: 'amount',
    frequency: 'frequency',
    startDate: 'startDate',
    endDate: 'endDate',
    nextOccurrence: 'nextOccurrence',
    isActive: 'isActive',
    autoConfirm: 'autoConfirm',
    notifyBefore: 'notifyBefore',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RecurrenceScalarFieldEnum = (typeof RecurrenceScalarFieldEnum)[keyof typeof RecurrenceScalarFieldEnum]


  export const TransferScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    fromAccountId: 'fromAccountId',
    toAccountId: 'toAccountId',
    description: 'description',
    amount: 'amount',
    fee: 'fee',
    transferDate: 'transferDate',
    createdAt: 'createdAt'
  };

  export type TransferScalarFieldEnum = (typeof TransferScalarFieldEnum)[keyof typeof TransferScalarFieldEnum]


  export const BudgetScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    name: 'name',
    description: 'description',
    startDate: 'startDate',
    endDate: 'endDate',
    totalBudgeted: 'totalBudgeted',
    totalSpent: 'totalSpent',
    isActive: 'isActive',
    alertThreshold: 'alertThreshold',
    alertSent: 'alertSent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BudgetScalarFieldEnum = (typeof BudgetScalarFieldEnum)[keyof typeof BudgetScalarFieldEnum]


  export const BudgetCategoryScalarFieldEnum: {
    id: 'id',
    budgetId: 'budgetId',
    categoryId: 'categoryId',
    budgeted: 'budgeted',
    spent: 'spent'
  };

  export type BudgetCategoryScalarFieldEnum = (typeof BudgetCategoryScalarFieldEnum)[keyof typeof BudgetCategoryScalarFieldEnum]


  export const GoalScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    name: 'name',
    description: 'description',
    type: 'type',
    targetAmount: 'targetAmount',
    currentAmount: 'currentAmount',
    startDate: 'startDate',
    targetDate: 'targetDate',
    completedAt: 'completedAt',
    status: 'status',
    icon: 'icon',
    color: 'color',
    autoAllocate: 'autoAllocate',
    allocationPercentage: 'allocationPercentage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GoalScalarFieldEnum = (typeof GoalScalarFieldEnum)[keyof typeof GoalScalarFieldEnum]


  export const GoalContributionScalarFieldEnum: {
    id: 'id',
    goalId: 'goalId',
    amount: 'amount',
    description: 'description',
    contributedAt: 'contributedAt'
  };

  export type GoalContributionScalarFieldEnum = (typeof GoalContributionScalarFieldEnum)[keyof typeof GoalContributionScalarFieldEnum]


  export const ImportJobScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    accountId: 'accountId',
    format: 'format',
    fileName: 'fileName',
    fileSize: 'fileSize',
    fileUrl: 'fileUrl',
    status: 'status',
    progress: 'progress',
    totalRows: 'totalRows',
    processedRows: 'processedRows',
    importedRows: 'importedRows',
    errorLog: 'errorLog',
    mappingConfig: 'mappingConfig',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    createdAt: 'createdAt'
  };

  export type ImportJobScalarFieldEnum = (typeof ImportJobScalarFieldEnum)[keyof typeof ImportJobScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    workspaceId: 'workspaceId',
    type: 'type',
    title: 'title',
    message: 'message',
    data: 'data',
    readAt: 'readAt',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    workspaceId: 'workspaceId',
    action: 'action',
    entityType: 'entityType',
    entityId: 'entityId',
    oldData: 'oldData',
    newData: 'newData',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const UserGamificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    tier: 'tier',
    totalXP: 'totalXP',
    currentLevel: 'currentLevel',
    xpToNextLevel: 'xpToNextLevel',
    loginStreak: 'loginStreak',
    longestLoginStreak: 'longestLoginStreak',
    transactionStreak: 'transactionStreak',
    transactionsLogged: 'transactionsLogged',
    budgetsMet: 'budgetsMet',
    goalsAchieved: 'goalsAchieved',
    lastLoginDate: 'lastLoginDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserGamificationScalarFieldEnum = (typeof UserGamificationScalarFieldEnum)[keyof typeof UserGamificationScalarFieldEnum]


  export const AchievementScalarFieldEnum: {
    id: 'id',
    type: 'type',
    name: 'name',
    description: 'description',
    icon: 'icon',
    color: 'color',
    xpReward: 'xpReward',
    requirementType: 'requirementType',
    requirementValue: 'requirementValue',
    createdAt: 'createdAt'
  };

  export type AchievementScalarFieldEnum = (typeof AchievementScalarFieldEnum)[keyof typeof AchievementScalarFieldEnum]


  export const UserAchievementScalarFieldEnum: {
    id: 'id',
    userGamificationId: 'userGamificationId',
    achievementId: 'achievementId',
    unlockedAt: 'unlockedAt'
  };

  export type UserAchievementScalarFieldEnum = (typeof UserAchievementScalarFieldEnum)[keyof typeof UserAchievementScalarFieldEnum]


  export const EnvelopeScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    categoryId: 'categoryId',
    name: 'name',
    description: 'description',
    color: 'color',
    budgetedAmount: 'budgetedAmount',
    availableAmount: 'availableAmount',
    spentAmount: 'spentAmount',
    month: 'month',
    year: 'year',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EnvelopeScalarFieldEnum = (typeof EnvelopeScalarFieldEnum)[keyof typeof EnvelopeScalarFieldEnum]


  export const AssetScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    name: 'name',
    type: 'type',
    description: 'description',
    currentValue: 'currentValue',
    purchaseValue: 'purchaseValue',
    purchaseDate: 'purchaseDate',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AssetScalarFieldEnum = (typeof AssetScalarFieldEnum)[keyof typeof AssetScalarFieldEnum]


  export const LiabilityScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    name: 'name',
    type: 'type',
    description: 'description',
    currentBalance: 'currentBalance',
    originalAmount: 'originalAmount',
    interestRate: 'interestRate',
    startDate: 'startDate',
    endDate: 'endDate',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LiabilityScalarFieldEnum = (typeof LiabilityScalarFieldEnum)[keyof typeof LiabilityScalarFieldEnum]


  export const AIInsightScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    userId: 'userId',
    type: 'type',
    title: 'title',
    description: 'description',
    severity: 'severity',
    suggestedAction: 'suggestedAction',
    actionTaken: 'actionTaken',
    confidenceScore: 'confidenceScore',
    dismissedAt: 'dismissedAt',
    createdAt: 'createdAt'
  };

  export type AIInsightScalarFieldEnum = (typeof AIInsightScalarFieldEnum)[keyof typeof AIInsightScalarFieldEnum]


  export const ScenarioScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    userId: 'userId',
    name: 'name',
    description: 'description',
    type: 'type',
    parameters: 'parameters',
    isFavorite: 'isFavorite',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ScenarioScalarFieldEnum = (typeof ScenarioScalarFieldEnum)[keyof typeof ScenarioScalarFieldEnum]


  export const BankConnectionScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    accountId: 'accountId',
    bankName: 'bankName',
    bankCode: 'bankCode',
    accessToken: 'accessToken',
    status: 'status',
    lastSyncAt: 'lastSyncAt',
    lastSyncError: 'lastSyncError',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BankConnectionScalarFieldEnum = (typeof BankConnectionScalarFieldEnum)[keyof typeof BankConnectionScalarFieldEnum]


  export const AutoRuleScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    userId: 'userId',
    name: 'name',
    description: 'description',
    isActive: 'isActive',
    priority: 'priority',
    conditions: 'conditions',
    actions: 'actions',
    timesApplied: 'timesApplied',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AutoRuleScalarFieldEnum = (typeof AutoRuleScalarFieldEnum)[keyof typeof AutoRuleScalarFieldEnum]


  export const CashFlowProjectionScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    month: 'month',
    year: 'year',
    projectedIncome: 'projectedIncome',
    projectedExpense: 'projectedExpense',
    projectedBalance: 'projectedBalance',
    generatedAt: 'generatedAt',
    updatedAt: 'updatedAt'
  };

  export type CashFlowProjectionScalarFieldEnum = (typeof CashFlowProjectionScalarFieldEnum)[keyof typeof CashFlowProjectionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    avatarUrl?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    emailVerified?: BoolFilter<"User"> | boolean
    twoFactorEnabled?: BoolFilter<"User"> | boolean
    twoFactorSecret?: StringNullableFilter<"User"> | string | null
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    workspaces?: WorkspaceMemberListRelationFilter
    sessions?: SessionListRelationFilter
    notifications?: NotificationListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    passwordResets?: PasswordResetListRelationFilter
    refreshTokens?: RefreshTokenListRelationFilter
    gamification?: XOR<UserGamificationNullableRelationFilter, UserGamificationWhereInput> | null
    aiInsights?: AIInsightListRelationFilter
    scenarios?: ScenarioListRelationFilter
    autoRules?: AutoRuleListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    emailVerified?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    workspaces?: WorkspaceMemberOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    passwordResets?: PasswordResetOrderByRelationAggregateInput
    refreshTokens?: RefreshTokenOrderByRelationAggregateInput
    gamification?: UserGamificationOrderByWithRelationInput
    aiInsights?: AIInsightOrderByRelationAggregateInput
    scenarios?: ScenarioOrderByRelationAggregateInput
    autoRules?: AutoRuleOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    avatarUrl?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    emailVerified?: BoolFilter<"User"> | boolean
    twoFactorEnabled?: BoolFilter<"User"> | boolean
    twoFactorSecret?: StringNullableFilter<"User"> | string | null
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    workspaces?: WorkspaceMemberListRelationFilter
    sessions?: SessionListRelationFilter
    notifications?: NotificationListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    passwordResets?: PasswordResetListRelationFilter
    refreshTokens?: RefreshTokenListRelationFilter
    gamification?: XOR<UserGamificationNullableRelationFilter, UserGamificationWhereInput> | null
    aiInsights?: AIInsightListRelationFilter
    scenarios?: ScenarioListRelationFilter
    autoRules?: AutoRuleListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    emailVerified?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    avatarUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    twoFactorEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    twoFactorSecret?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    token?: StringFilter<"Session"> | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    token?: StringWithAggregatesFilter<"Session"> | string
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type RefreshTokenWhereInput = {
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    revokedAt?: DateTimeNullableFilter<"RefreshToken"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type RefreshTokenOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    revokedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type RefreshTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    userId?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    revokedAt?: DateTimeNullableFilter<"RefreshToken"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type RefreshTokenOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    revokedAt?: SortOrderInput | SortOrder
    _count?: RefreshTokenCountOrderByAggregateInput
    _max?: RefreshTokenMaxOrderByAggregateInput
    _min?: RefreshTokenMinOrderByAggregateInput
  }

  export type RefreshTokenScalarWhereWithAggregatesInput = {
    AND?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    OR?: RefreshTokenScalarWhereWithAggregatesInput[]
    NOT?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RefreshToken"> | string
    userId?: StringWithAggregatesFilter<"RefreshToken"> | string
    token?: StringWithAggregatesFilter<"RefreshToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    revokedAt?: DateTimeNullableWithAggregatesFilter<"RefreshToken"> | Date | string | null
  }

  export type PasswordResetWhereInput = {
    AND?: PasswordResetWhereInput | PasswordResetWhereInput[]
    OR?: PasswordResetWhereInput[]
    NOT?: PasswordResetWhereInput | PasswordResetWhereInput[]
    id?: StringFilter<"PasswordReset"> | string
    userId?: StringFilter<"PasswordReset"> | string
    token?: StringFilter<"PasswordReset"> | string
    expiresAt?: DateTimeFilter<"PasswordReset"> | Date | string
    usedAt?: DateTimeNullableFilter<"PasswordReset"> | Date | string | null
    createdAt?: DateTimeFilter<"PasswordReset"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type PasswordResetOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PasswordResetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: PasswordResetWhereInput | PasswordResetWhereInput[]
    OR?: PasswordResetWhereInput[]
    NOT?: PasswordResetWhereInput | PasswordResetWhereInput[]
    userId?: StringFilter<"PasswordReset"> | string
    expiresAt?: DateTimeFilter<"PasswordReset"> | Date | string
    usedAt?: DateTimeNullableFilter<"PasswordReset"> | Date | string | null
    createdAt?: DateTimeFilter<"PasswordReset"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type PasswordResetOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PasswordResetCountOrderByAggregateInput
    _max?: PasswordResetMaxOrderByAggregateInput
    _min?: PasswordResetMinOrderByAggregateInput
  }

  export type PasswordResetScalarWhereWithAggregatesInput = {
    AND?: PasswordResetScalarWhereWithAggregatesInput | PasswordResetScalarWhereWithAggregatesInput[]
    OR?: PasswordResetScalarWhereWithAggregatesInput[]
    NOT?: PasswordResetScalarWhereWithAggregatesInput | PasswordResetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PasswordReset"> | string
    userId?: StringWithAggregatesFilter<"PasswordReset"> | string
    token?: StringWithAggregatesFilter<"PasswordReset"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"PasswordReset"> | Date | string
    usedAt?: DateTimeNullableWithAggregatesFilter<"PasswordReset"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PasswordReset"> | Date | string
  }

  export type WorkspaceWhereInput = {
    AND?: WorkspaceWhereInput | WorkspaceWhereInput[]
    OR?: WorkspaceWhereInput[]
    NOT?: WorkspaceWhereInput | WorkspaceWhereInput[]
    id?: StringFilter<"Workspace"> | string
    name?: StringFilter<"Workspace"> | string
    slug?: StringFilter<"Workspace"> | string
    description?: StringNullableFilter<"Workspace"> | string | null
    type?: StringFilter<"Workspace"> | string
    currency?: StringFilter<"Workspace"> | string
    timezone?: StringFilter<"Workspace"> | string
    isActive?: BoolFilter<"Workspace"> | boolean
    createdAt?: DateTimeFilter<"Workspace"> | Date | string
    updatedAt?: DateTimeFilter<"Workspace"> | Date | string
    members?: WorkspaceMemberListRelationFilter
    accounts?: AccountListRelationFilter
    categories?: CategoryListRelationFilter
    goals?: GoalListRelationFilter
    budgets?: BudgetListRelationFilter
    imports?: ImportJobListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    envelopes?: EnvelopeListRelationFilter
    assets?: AssetListRelationFilter
    liabilities?: LiabilityListRelationFilter
    aiInsights?: AIInsightListRelationFilter
    scenarios?: ScenarioListRelationFilter
    bankConnections?: BankConnectionListRelationFilter
    autoRules?: AutoRuleListRelationFilter
    cashFlowProjections?: CashFlowProjectionListRelationFilter
    Transaction?: TransactionListRelationFilter
  }

  export type WorkspaceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    currency?: SortOrder
    timezone?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    members?: WorkspaceMemberOrderByRelationAggregateInput
    accounts?: AccountOrderByRelationAggregateInput
    categories?: CategoryOrderByRelationAggregateInput
    goals?: GoalOrderByRelationAggregateInput
    budgets?: BudgetOrderByRelationAggregateInput
    imports?: ImportJobOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    envelopes?: EnvelopeOrderByRelationAggregateInput
    assets?: AssetOrderByRelationAggregateInput
    liabilities?: LiabilityOrderByRelationAggregateInput
    aiInsights?: AIInsightOrderByRelationAggregateInput
    scenarios?: ScenarioOrderByRelationAggregateInput
    bankConnections?: BankConnectionOrderByRelationAggregateInput
    autoRules?: AutoRuleOrderByRelationAggregateInput
    cashFlowProjections?: CashFlowProjectionOrderByRelationAggregateInput
    Transaction?: TransactionOrderByRelationAggregateInput
  }

  export type WorkspaceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: WorkspaceWhereInput | WorkspaceWhereInput[]
    OR?: WorkspaceWhereInput[]
    NOT?: WorkspaceWhereInput | WorkspaceWhereInput[]
    name?: StringFilter<"Workspace"> | string
    description?: StringNullableFilter<"Workspace"> | string | null
    type?: StringFilter<"Workspace"> | string
    currency?: StringFilter<"Workspace"> | string
    timezone?: StringFilter<"Workspace"> | string
    isActive?: BoolFilter<"Workspace"> | boolean
    createdAt?: DateTimeFilter<"Workspace"> | Date | string
    updatedAt?: DateTimeFilter<"Workspace"> | Date | string
    members?: WorkspaceMemberListRelationFilter
    accounts?: AccountListRelationFilter
    categories?: CategoryListRelationFilter
    goals?: GoalListRelationFilter
    budgets?: BudgetListRelationFilter
    imports?: ImportJobListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    envelopes?: EnvelopeListRelationFilter
    assets?: AssetListRelationFilter
    liabilities?: LiabilityListRelationFilter
    aiInsights?: AIInsightListRelationFilter
    scenarios?: ScenarioListRelationFilter
    bankConnections?: BankConnectionListRelationFilter
    autoRules?: AutoRuleListRelationFilter
    cashFlowProjections?: CashFlowProjectionListRelationFilter
    Transaction?: TransactionListRelationFilter
  }, "id" | "slug">

  export type WorkspaceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    currency?: SortOrder
    timezone?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WorkspaceCountOrderByAggregateInput
    _max?: WorkspaceMaxOrderByAggregateInput
    _min?: WorkspaceMinOrderByAggregateInput
  }

  export type WorkspaceScalarWhereWithAggregatesInput = {
    AND?: WorkspaceScalarWhereWithAggregatesInput | WorkspaceScalarWhereWithAggregatesInput[]
    OR?: WorkspaceScalarWhereWithAggregatesInput[]
    NOT?: WorkspaceScalarWhereWithAggregatesInput | WorkspaceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Workspace"> | string
    name?: StringWithAggregatesFilter<"Workspace"> | string
    slug?: StringWithAggregatesFilter<"Workspace"> | string
    description?: StringNullableWithAggregatesFilter<"Workspace"> | string | null
    type?: StringWithAggregatesFilter<"Workspace"> | string
    currency?: StringWithAggregatesFilter<"Workspace"> | string
    timezone?: StringWithAggregatesFilter<"Workspace"> | string
    isActive?: BoolWithAggregatesFilter<"Workspace"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Workspace"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Workspace"> | Date | string
  }

  export type WorkspaceMemberWhereInput = {
    AND?: WorkspaceMemberWhereInput | WorkspaceMemberWhereInput[]
    OR?: WorkspaceMemberWhereInput[]
    NOT?: WorkspaceMemberWhereInput | WorkspaceMemberWhereInput[]
    id?: StringFilter<"WorkspaceMember"> | string
    workspaceId?: StringFilter<"WorkspaceMember"> | string
    userId?: StringFilter<"WorkspaceMember"> | string
    role?: StringFilter<"WorkspaceMember"> | string
    joinedAt?: DateTimeFilter<"WorkspaceMember"> | Date | string
    invitedBy?: StringNullableFilter<"WorkspaceMember"> | string | null
    workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type WorkspaceMemberOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    invitedBy?: SortOrderInput | SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type WorkspaceMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    workspaceId_userId?: WorkspaceMemberWorkspaceIdUserIdCompoundUniqueInput
    AND?: WorkspaceMemberWhereInput | WorkspaceMemberWhereInput[]
    OR?: WorkspaceMemberWhereInput[]
    NOT?: WorkspaceMemberWhereInput | WorkspaceMemberWhereInput[]
    workspaceId?: StringFilter<"WorkspaceMember"> | string
    userId?: StringFilter<"WorkspaceMember"> | string
    role?: StringFilter<"WorkspaceMember"> | string
    joinedAt?: DateTimeFilter<"WorkspaceMember"> | Date | string
    invitedBy?: StringNullableFilter<"WorkspaceMember"> | string | null
    workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "workspaceId_userId">

  export type WorkspaceMemberOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    invitedBy?: SortOrderInput | SortOrder
    _count?: WorkspaceMemberCountOrderByAggregateInput
    _max?: WorkspaceMemberMaxOrderByAggregateInput
    _min?: WorkspaceMemberMinOrderByAggregateInput
  }

  export type WorkspaceMemberScalarWhereWithAggregatesInput = {
    AND?: WorkspaceMemberScalarWhereWithAggregatesInput | WorkspaceMemberScalarWhereWithAggregatesInput[]
    OR?: WorkspaceMemberScalarWhereWithAggregatesInput[]
    NOT?: WorkspaceMemberScalarWhereWithAggregatesInput | WorkspaceMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkspaceMember"> | string
    workspaceId?: StringWithAggregatesFilter<"WorkspaceMember"> | string
    userId?: StringWithAggregatesFilter<"WorkspaceMember"> | string
    role?: StringWithAggregatesFilter<"WorkspaceMember"> | string
    joinedAt?: DateTimeWithAggregatesFilter<"WorkspaceMember"> | Date | string
    invitedBy?: StringNullableWithAggregatesFilter<"WorkspaceMember"> | string | null
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    workspaceId?: StringFilter<"Account"> | string
    name?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    description?: StringNullableFilter<"Account"> | string | null
    bankName?: StringNullableFilter<"Account"> | string | null
    bankCode?: StringNullableFilter<"Account"> | string | null
    agency?: StringNullableFilter<"Account"> | string | null
    accountNumber?: StringNullableFilter<"Account"> | string | null
    initialBalance?: FloatFilter<"Account"> | number
    currentBalance?: FloatFilter<"Account"> | number
    creditLimit?: FloatNullableFilter<"Account"> | number | null
    closingDay?: IntNullableFilter<"Account"> | number | null
    dueDay?: IntNullableFilter<"Account"> | number | null
    color?: StringFilter<"Account"> | string
    icon?: StringFilter<"Account"> | string
    isActive?: BoolFilter<"Account"> | boolean
    archivedAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
    transactions?: TransactionListRelationFilter
    fromTransfers?: TransferListRelationFilter
    toTransfers?: TransferListRelationFilter
    bankConnections?: BankConnectionListRelationFilter
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    bankName?: SortOrderInput | SortOrder
    bankCode?: SortOrderInput | SortOrder
    agency?: SortOrderInput | SortOrder
    accountNumber?: SortOrderInput | SortOrder
    initialBalance?: SortOrder
    currentBalance?: SortOrder
    creditLimit?: SortOrderInput | SortOrder
    closingDay?: SortOrderInput | SortOrder
    dueDay?: SortOrderInput | SortOrder
    color?: SortOrder
    icon?: SortOrder
    isActive?: SortOrder
    archivedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
    transactions?: TransactionOrderByRelationAggregateInput
    fromTransfers?: TransferOrderByRelationAggregateInput
    toTransfers?: TransferOrderByRelationAggregateInput
    bankConnections?: BankConnectionOrderByRelationAggregateInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    workspaceId?: StringFilter<"Account"> | string
    name?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    description?: StringNullableFilter<"Account"> | string | null
    bankName?: StringNullableFilter<"Account"> | string | null
    bankCode?: StringNullableFilter<"Account"> | string | null
    agency?: StringNullableFilter<"Account"> | string | null
    accountNumber?: StringNullableFilter<"Account"> | string | null
    initialBalance?: FloatFilter<"Account"> | number
    currentBalance?: FloatFilter<"Account"> | number
    creditLimit?: FloatNullableFilter<"Account"> | number | null
    closingDay?: IntNullableFilter<"Account"> | number | null
    dueDay?: IntNullableFilter<"Account"> | number | null
    color?: StringFilter<"Account"> | string
    icon?: StringFilter<"Account"> | string
    isActive?: BoolFilter<"Account"> | boolean
    archivedAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
    transactions?: TransactionListRelationFilter
    fromTransfers?: TransferListRelationFilter
    toTransfers?: TransferListRelationFilter
    bankConnections?: BankConnectionListRelationFilter
  }, "id">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    bankName?: SortOrderInput | SortOrder
    bankCode?: SortOrderInput | SortOrder
    agency?: SortOrderInput | SortOrder
    accountNumber?: SortOrderInput | SortOrder
    initialBalance?: SortOrder
    currentBalance?: SortOrder
    creditLimit?: SortOrderInput | SortOrder
    closingDay?: SortOrderInput | SortOrder
    dueDay?: SortOrderInput | SortOrder
    color?: SortOrder
    icon?: SortOrder
    isActive?: SortOrder
    archivedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    workspaceId?: StringWithAggregatesFilter<"Account"> | string
    name?: StringWithAggregatesFilter<"Account"> | string
    type?: StringWithAggregatesFilter<"Account"> | string
    description?: StringNullableWithAggregatesFilter<"Account"> | string | null
    bankName?: StringNullableWithAggregatesFilter<"Account"> | string | null
    bankCode?: StringNullableWithAggregatesFilter<"Account"> | string | null
    agency?: StringNullableWithAggregatesFilter<"Account"> | string | null
    accountNumber?: StringNullableWithAggregatesFilter<"Account"> | string | null
    initialBalance?: FloatWithAggregatesFilter<"Account"> | number
    currentBalance?: FloatWithAggregatesFilter<"Account"> | number
    creditLimit?: FloatNullableWithAggregatesFilter<"Account"> | number | null
    closingDay?: IntNullableWithAggregatesFilter<"Account"> | number | null
    dueDay?: IntNullableWithAggregatesFilter<"Account"> | number | null
    color?: StringWithAggregatesFilter<"Account"> | string
    icon?: StringWithAggregatesFilter<"Account"> | string
    isActive?: BoolWithAggregatesFilter<"Account"> | boolean
    archivedAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: StringFilter<"Category"> | string
    workspaceId?: StringFilter<"Category"> | string
    parentId?: StringNullableFilter<"Category"> | string | null
    name?: StringFilter<"Category"> | string
    type?: StringFilter<"Category"> | string
    color?: StringFilter<"Category"> | string
    icon?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    keywords?: StringFilter<"Category"> | string
    isSystem?: BoolFilter<"Category"> | boolean
    isActive?: BoolFilter<"Category"> | boolean
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
    parent?: XOR<CategoryNullableRelationFilter, CategoryWhereInput> | null
    children?: CategoryListRelationFilter
    transactions?: TransactionListRelationFilter
    budgets?: BudgetCategoryListRelationFilter
    envelopes?: EnvelopeListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    name?: SortOrder
    type?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    description?: SortOrderInput | SortOrder
    keywords?: SortOrder
    isSystem?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
    parent?: CategoryOrderByWithRelationInput
    children?: CategoryOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
    budgets?: BudgetCategoryOrderByRelationAggregateInput
    envelopes?: EnvelopeOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    workspaceId?: StringFilter<"Category"> | string
    parentId?: StringNullableFilter<"Category"> | string | null
    name?: StringFilter<"Category"> | string
    type?: StringFilter<"Category"> | string
    color?: StringFilter<"Category"> | string
    icon?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    keywords?: StringFilter<"Category"> | string
    isSystem?: BoolFilter<"Category"> | boolean
    isActive?: BoolFilter<"Category"> | boolean
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
    parent?: XOR<CategoryNullableRelationFilter, CategoryWhereInput> | null
    children?: CategoryListRelationFilter
    transactions?: TransactionListRelationFilter
    budgets?: BudgetCategoryListRelationFilter
    envelopes?: EnvelopeListRelationFilter
  }, "id">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    name?: SortOrder
    type?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    description?: SortOrderInput | SortOrder
    keywords?: SortOrder
    isSystem?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Category"> | string
    workspaceId?: StringWithAggregatesFilter<"Category"> | string
    parentId?: StringNullableWithAggregatesFilter<"Category"> | string | null
    name?: StringWithAggregatesFilter<"Category"> | string
    type?: StringWithAggregatesFilter<"Category"> | string
    color?: StringWithAggregatesFilter<"Category"> | string
    icon?: StringWithAggregatesFilter<"Category"> | string
    description?: StringNullableWithAggregatesFilter<"Category"> | string | null
    keywords?: StringWithAggregatesFilter<"Category"> | string
    isSystem?: BoolWithAggregatesFilter<"Category"> | boolean
    isActive?: BoolWithAggregatesFilter<"Category"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: StringFilter<"Transaction"> | string
    workspaceId?: StringFilter<"Transaction"> | string
    accountId?: StringFilter<"Transaction"> | string
    categoryId?: StringNullableFilter<"Transaction"> | string | null
    creditCardId?: StringNullableFilter<"Transaction"> | string | null
    type?: StringFilter<"Transaction"> | string
    description?: StringFilter<"Transaction"> | string
    amount?: FloatFilter<"Transaction"> | number
    currency?: StringFilter<"Transaction"> | string
    status?: StringFilter<"Transaction"> | string
    transactionDate?: DateTimeFilter<"Transaction"> | Date | string
    confirmedAt?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    recurrenceId?: StringNullableFilter<"Transaction"> | string | null
    notes?: StringNullableFilter<"Transaction"> | string | null
    tags?: StringFilter<"Transaction"> | string
    attachmentUrl?: StringNullableFilter<"Transaction"> | string | null
    location?: StringNullableFilter<"Transaction"> | string | null
    importId?: StringNullableFilter<"Transaction"> | string | null
    rawData?: StringNullableFilter<"Transaction"> | string | null
    aiConfidence?: FloatNullableFilter<"Transaction"> | number | null
    aiCategory?: StringNullableFilter<"Transaction"> | string | null
    aiCategorizedAt?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    aiModelVersion?: StringNullableFilter<"Transaction"> | string | null
    autoRuleId?: StringNullableFilter<"Transaction"> | string | null
    bankConnectionId?: StringNullableFilter<"Transaction"> | string | null
    externalId?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    category?: XOR<CategoryNullableRelationFilter, CategoryWhereInput> | null
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    accountId?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    creditCardId?: SortOrderInput | SortOrder
    type?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    transactionDate?: SortOrder
    confirmedAt?: SortOrderInput | SortOrder
    recurrenceId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    tags?: SortOrder
    attachmentUrl?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    importId?: SortOrderInput | SortOrder
    rawData?: SortOrderInput | SortOrder
    aiConfidence?: SortOrderInput | SortOrder
    aiCategory?: SortOrderInput | SortOrder
    aiCategorizedAt?: SortOrderInput | SortOrder
    aiModelVersion?: SortOrderInput | SortOrder
    autoRuleId?: SortOrderInput | SortOrder
    bankConnectionId?: SortOrderInput | SortOrder
    externalId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
    account?: AccountOrderByWithRelationInput
    category?: CategoryOrderByWithRelationInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    workspaceId?: StringFilter<"Transaction"> | string
    accountId?: StringFilter<"Transaction"> | string
    categoryId?: StringNullableFilter<"Transaction"> | string | null
    creditCardId?: StringNullableFilter<"Transaction"> | string | null
    type?: StringFilter<"Transaction"> | string
    description?: StringFilter<"Transaction"> | string
    amount?: FloatFilter<"Transaction"> | number
    currency?: StringFilter<"Transaction"> | string
    status?: StringFilter<"Transaction"> | string
    transactionDate?: DateTimeFilter<"Transaction"> | Date | string
    confirmedAt?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    recurrenceId?: StringNullableFilter<"Transaction"> | string | null
    notes?: StringNullableFilter<"Transaction"> | string | null
    tags?: StringFilter<"Transaction"> | string
    attachmentUrl?: StringNullableFilter<"Transaction"> | string | null
    location?: StringNullableFilter<"Transaction"> | string | null
    importId?: StringNullableFilter<"Transaction"> | string | null
    rawData?: StringNullableFilter<"Transaction"> | string | null
    aiConfidence?: FloatNullableFilter<"Transaction"> | number | null
    aiCategory?: StringNullableFilter<"Transaction"> | string | null
    aiCategorizedAt?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    aiModelVersion?: StringNullableFilter<"Transaction"> | string | null
    autoRuleId?: StringNullableFilter<"Transaction"> | string | null
    bankConnectionId?: StringNullableFilter<"Transaction"> | string | null
    externalId?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    category?: XOR<CategoryNullableRelationFilter, CategoryWhereInput> | null
  }, "id">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    accountId?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    creditCardId?: SortOrderInput | SortOrder
    type?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    transactionDate?: SortOrder
    confirmedAt?: SortOrderInput | SortOrder
    recurrenceId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    tags?: SortOrder
    attachmentUrl?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    importId?: SortOrderInput | SortOrder
    rawData?: SortOrderInput | SortOrder
    aiConfidence?: SortOrderInput | SortOrder
    aiCategory?: SortOrderInput | SortOrder
    aiCategorizedAt?: SortOrderInput | SortOrder
    aiModelVersion?: SortOrderInput | SortOrder
    autoRuleId?: SortOrderInput | SortOrder
    bankConnectionId?: SortOrderInput | SortOrder
    externalId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transaction"> | string
    workspaceId?: StringWithAggregatesFilter<"Transaction"> | string
    accountId?: StringWithAggregatesFilter<"Transaction"> | string
    categoryId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    creditCardId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    type?: StringWithAggregatesFilter<"Transaction"> | string
    description?: StringWithAggregatesFilter<"Transaction"> | string
    amount?: FloatWithAggregatesFilter<"Transaction"> | number
    currency?: StringWithAggregatesFilter<"Transaction"> | string
    status?: StringWithAggregatesFilter<"Transaction"> | string
    transactionDate?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    confirmedAt?: DateTimeNullableWithAggregatesFilter<"Transaction"> | Date | string | null
    recurrenceId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    tags?: StringWithAggregatesFilter<"Transaction"> | string
    attachmentUrl?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    location?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    importId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    rawData?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    aiConfidence?: FloatNullableWithAggregatesFilter<"Transaction"> | number | null
    aiCategory?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    aiCategorizedAt?: DateTimeNullableWithAggregatesFilter<"Transaction"> | Date | string | null
    aiModelVersion?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    autoRuleId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    bankConnectionId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    externalId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
  }

  export type RecurrenceWhereInput = {
    AND?: RecurrenceWhereInput | RecurrenceWhereInput[]
    OR?: RecurrenceWhereInput[]
    NOT?: RecurrenceWhereInput | RecurrenceWhereInput[]
    id?: StringFilter<"Recurrence"> | string
    workspaceId?: StringFilter<"Recurrence"> | string
    accountId?: StringFilter<"Recurrence"> | string
    categoryId?: StringNullableFilter<"Recurrence"> | string | null
    type?: StringFilter<"Recurrence"> | string
    description?: StringFilter<"Recurrence"> | string
    amount?: FloatFilter<"Recurrence"> | number
    frequency?: StringFilter<"Recurrence"> | string
    startDate?: DateTimeFilter<"Recurrence"> | Date | string
    endDate?: DateTimeNullableFilter<"Recurrence"> | Date | string | null
    nextOccurrence?: DateTimeFilter<"Recurrence"> | Date | string
    isActive?: BoolFilter<"Recurrence"> | boolean
    autoConfirm?: BoolFilter<"Recurrence"> | boolean
    notifyBefore?: IntFilter<"Recurrence"> | number
    createdAt?: DateTimeFilter<"Recurrence"> | Date | string
    updatedAt?: DateTimeFilter<"Recurrence"> | Date | string
  }

  export type RecurrenceOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    accountId?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    type?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    frequency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    nextOccurrence?: SortOrder
    isActive?: SortOrder
    autoConfirm?: SortOrder
    notifyBefore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecurrenceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RecurrenceWhereInput | RecurrenceWhereInput[]
    OR?: RecurrenceWhereInput[]
    NOT?: RecurrenceWhereInput | RecurrenceWhereInput[]
    workspaceId?: StringFilter<"Recurrence"> | string
    accountId?: StringFilter<"Recurrence"> | string
    categoryId?: StringNullableFilter<"Recurrence"> | string | null
    type?: StringFilter<"Recurrence"> | string
    description?: StringFilter<"Recurrence"> | string
    amount?: FloatFilter<"Recurrence"> | number
    frequency?: StringFilter<"Recurrence"> | string
    startDate?: DateTimeFilter<"Recurrence"> | Date | string
    endDate?: DateTimeNullableFilter<"Recurrence"> | Date | string | null
    nextOccurrence?: DateTimeFilter<"Recurrence"> | Date | string
    isActive?: BoolFilter<"Recurrence"> | boolean
    autoConfirm?: BoolFilter<"Recurrence"> | boolean
    notifyBefore?: IntFilter<"Recurrence"> | number
    createdAt?: DateTimeFilter<"Recurrence"> | Date | string
    updatedAt?: DateTimeFilter<"Recurrence"> | Date | string
  }, "id">

  export type RecurrenceOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    accountId?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    type?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    frequency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    nextOccurrence?: SortOrder
    isActive?: SortOrder
    autoConfirm?: SortOrder
    notifyBefore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RecurrenceCountOrderByAggregateInput
    _avg?: RecurrenceAvgOrderByAggregateInput
    _max?: RecurrenceMaxOrderByAggregateInput
    _min?: RecurrenceMinOrderByAggregateInput
    _sum?: RecurrenceSumOrderByAggregateInput
  }

  export type RecurrenceScalarWhereWithAggregatesInput = {
    AND?: RecurrenceScalarWhereWithAggregatesInput | RecurrenceScalarWhereWithAggregatesInput[]
    OR?: RecurrenceScalarWhereWithAggregatesInput[]
    NOT?: RecurrenceScalarWhereWithAggregatesInput | RecurrenceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Recurrence"> | string
    workspaceId?: StringWithAggregatesFilter<"Recurrence"> | string
    accountId?: StringWithAggregatesFilter<"Recurrence"> | string
    categoryId?: StringNullableWithAggregatesFilter<"Recurrence"> | string | null
    type?: StringWithAggregatesFilter<"Recurrence"> | string
    description?: StringWithAggregatesFilter<"Recurrence"> | string
    amount?: FloatWithAggregatesFilter<"Recurrence"> | number
    frequency?: StringWithAggregatesFilter<"Recurrence"> | string
    startDate?: DateTimeWithAggregatesFilter<"Recurrence"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"Recurrence"> | Date | string | null
    nextOccurrence?: DateTimeWithAggregatesFilter<"Recurrence"> | Date | string
    isActive?: BoolWithAggregatesFilter<"Recurrence"> | boolean
    autoConfirm?: BoolWithAggregatesFilter<"Recurrence"> | boolean
    notifyBefore?: IntWithAggregatesFilter<"Recurrence"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Recurrence"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Recurrence"> | Date | string
  }

  export type TransferWhereInput = {
    AND?: TransferWhereInput | TransferWhereInput[]
    OR?: TransferWhereInput[]
    NOT?: TransferWhereInput | TransferWhereInput[]
    id?: StringFilter<"Transfer"> | string
    workspaceId?: StringFilter<"Transfer"> | string
    fromAccountId?: StringFilter<"Transfer"> | string
    toAccountId?: StringFilter<"Transfer"> | string
    description?: StringFilter<"Transfer"> | string
    amount?: FloatFilter<"Transfer"> | number
    fee?: FloatNullableFilter<"Transfer"> | number | null
    transferDate?: DateTimeFilter<"Transfer"> | Date | string
    createdAt?: DateTimeFilter<"Transfer"> | Date | string
    fromAccount?: XOR<AccountRelationFilter, AccountWhereInput>
    toAccount?: XOR<AccountRelationFilter, AccountWhereInput>
  }

  export type TransferOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    fromAccountId?: SortOrder
    toAccountId?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    fee?: SortOrderInput | SortOrder
    transferDate?: SortOrder
    createdAt?: SortOrder
    fromAccount?: AccountOrderByWithRelationInput
    toAccount?: AccountOrderByWithRelationInput
  }

  export type TransferWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransferWhereInput | TransferWhereInput[]
    OR?: TransferWhereInput[]
    NOT?: TransferWhereInput | TransferWhereInput[]
    workspaceId?: StringFilter<"Transfer"> | string
    fromAccountId?: StringFilter<"Transfer"> | string
    toAccountId?: StringFilter<"Transfer"> | string
    description?: StringFilter<"Transfer"> | string
    amount?: FloatFilter<"Transfer"> | number
    fee?: FloatNullableFilter<"Transfer"> | number | null
    transferDate?: DateTimeFilter<"Transfer"> | Date | string
    createdAt?: DateTimeFilter<"Transfer"> | Date | string
    fromAccount?: XOR<AccountRelationFilter, AccountWhereInput>
    toAccount?: XOR<AccountRelationFilter, AccountWhereInput>
  }, "id">

  export type TransferOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    fromAccountId?: SortOrder
    toAccountId?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    fee?: SortOrderInput | SortOrder
    transferDate?: SortOrder
    createdAt?: SortOrder
    _count?: TransferCountOrderByAggregateInput
    _avg?: TransferAvgOrderByAggregateInput
    _max?: TransferMaxOrderByAggregateInput
    _min?: TransferMinOrderByAggregateInput
    _sum?: TransferSumOrderByAggregateInput
  }

  export type TransferScalarWhereWithAggregatesInput = {
    AND?: TransferScalarWhereWithAggregatesInput | TransferScalarWhereWithAggregatesInput[]
    OR?: TransferScalarWhereWithAggregatesInput[]
    NOT?: TransferScalarWhereWithAggregatesInput | TransferScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transfer"> | string
    workspaceId?: StringWithAggregatesFilter<"Transfer"> | string
    fromAccountId?: StringWithAggregatesFilter<"Transfer"> | string
    toAccountId?: StringWithAggregatesFilter<"Transfer"> | string
    description?: StringWithAggregatesFilter<"Transfer"> | string
    amount?: FloatWithAggregatesFilter<"Transfer"> | number
    fee?: FloatNullableWithAggregatesFilter<"Transfer"> | number | null
    transferDate?: DateTimeWithAggregatesFilter<"Transfer"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Transfer"> | Date | string
  }

  export type BudgetWhereInput = {
    AND?: BudgetWhereInput | BudgetWhereInput[]
    OR?: BudgetWhereInput[]
    NOT?: BudgetWhereInput | BudgetWhereInput[]
    id?: StringFilter<"Budget"> | string
    workspaceId?: StringFilter<"Budget"> | string
    name?: StringFilter<"Budget"> | string
    description?: StringNullableFilter<"Budget"> | string | null
    startDate?: DateTimeFilter<"Budget"> | Date | string
    endDate?: DateTimeFilter<"Budget"> | Date | string
    totalBudgeted?: FloatFilter<"Budget"> | number
    totalSpent?: FloatFilter<"Budget"> | number
    isActive?: BoolFilter<"Budget"> | boolean
    alertThreshold?: IntFilter<"Budget"> | number
    alertSent?: BoolFilter<"Budget"> | boolean
    createdAt?: DateTimeFilter<"Budget"> | Date | string
    updatedAt?: DateTimeFilter<"Budget"> | Date | string
    categories?: BudgetCategoryListRelationFilter
    Workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
  }

  export type BudgetOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    totalBudgeted?: SortOrder
    totalSpent?: SortOrder
    isActive?: SortOrder
    alertThreshold?: SortOrder
    alertSent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    categories?: BudgetCategoryOrderByRelationAggregateInput
    Workspace?: WorkspaceOrderByWithRelationInput
  }

  export type BudgetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BudgetWhereInput | BudgetWhereInput[]
    OR?: BudgetWhereInput[]
    NOT?: BudgetWhereInput | BudgetWhereInput[]
    workspaceId?: StringFilter<"Budget"> | string
    name?: StringFilter<"Budget"> | string
    description?: StringNullableFilter<"Budget"> | string | null
    startDate?: DateTimeFilter<"Budget"> | Date | string
    endDate?: DateTimeFilter<"Budget"> | Date | string
    totalBudgeted?: FloatFilter<"Budget"> | number
    totalSpent?: FloatFilter<"Budget"> | number
    isActive?: BoolFilter<"Budget"> | boolean
    alertThreshold?: IntFilter<"Budget"> | number
    alertSent?: BoolFilter<"Budget"> | boolean
    createdAt?: DateTimeFilter<"Budget"> | Date | string
    updatedAt?: DateTimeFilter<"Budget"> | Date | string
    categories?: BudgetCategoryListRelationFilter
    Workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
  }, "id">

  export type BudgetOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    totalBudgeted?: SortOrder
    totalSpent?: SortOrder
    isActive?: SortOrder
    alertThreshold?: SortOrder
    alertSent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BudgetCountOrderByAggregateInput
    _avg?: BudgetAvgOrderByAggregateInput
    _max?: BudgetMaxOrderByAggregateInput
    _min?: BudgetMinOrderByAggregateInput
    _sum?: BudgetSumOrderByAggregateInput
  }

  export type BudgetScalarWhereWithAggregatesInput = {
    AND?: BudgetScalarWhereWithAggregatesInput | BudgetScalarWhereWithAggregatesInput[]
    OR?: BudgetScalarWhereWithAggregatesInput[]
    NOT?: BudgetScalarWhereWithAggregatesInput | BudgetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Budget"> | string
    workspaceId?: StringWithAggregatesFilter<"Budget"> | string
    name?: StringWithAggregatesFilter<"Budget"> | string
    description?: StringNullableWithAggregatesFilter<"Budget"> | string | null
    startDate?: DateTimeWithAggregatesFilter<"Budget"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Budget"> | Date | string
    totalBudgeted?: FloatWithAggregatesFilter<"Budget"> | number
    totalSpent?: FloatWithAggregatesFilter<"Budget"> | number
    isActive?: BoolWithAggregatesFilter<"Budget"> | boolean
    alertThreshold?: IntWithAggregatesFilter<"Budget"> | number
    alertSent?: BoolWithAggregatesFilter<"Budget"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Budget"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Budget"> | Date | string
  }

  export type BudgetCategoryWhereInput = {
    AND?: BudgetCategoryWhereInput | BudgetCategoryWhereInput[]
    OR?: BudgetCategoryWhereInput[]
    NOT?: BudgetCategoryWhereInput | BudgetCategoryWhereInput[]
    id?: StringFilter<"BudgetCategory"> | string
    budgetId?: StringFilter<"BudgetCategory"> | string
    categoryId?: StringFilter<"BudgetCategory"> | string
    budgeted?: FloatFilter<"BudgetCategory"> | number
    spent?: FloatFilter<"BudgetCategory"> | number
    budget?: XOR<BudgetRelationFilter, BudgetWhereInput>
    category?: XOR<CategoryRelationFilter, CategoryWhereInput>
  }

  export type BudgetCategoryOrderByWithRelationInput = {
    id?: SortOrder
    budgetId?: SortOrder
    categoryId?: SortOrder
    budgeted?: SortOrder
    spent?: SortOrder
    budget?: BudgetOrderByWithRelationInput
    category?: CategoryOrderByWithRelationInput
  }

  export type BudgetCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    budgetId_categoryId?: BudgetCategoryBudgetIdCategoryIdCompoundUniqueInput
    AND?: BudgetCategoryWhereInput | BudgetCategoryWhereInput[]
    OR?: BudgetCategoryWhereInput[]
    NOT?: BudgetCategoryWhereInput | BudgetCategoryWhereInput[]
    budgetId?: StringFilter<"BudgetCategory"> | string
    categoryId?: StringFilter<"BudgetCategory"> | string
    budgeted?: FloatFilter<"BudgetCategory"> | number
    spent?: FloatFilter<"BudgetCategory"> | number
    budget?: XOR<BudgetRelationFilter, BudgetWhereInput>
    category?: XOR<CategoryRelationFilter, CategoryWhereInput>
  }, "id" | "budgetId_categoryId">

  export type BudgetCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    budgetId?: SortOrder
    categoryId?: SortOrder
    budgeted?: SortOrder
    spent?: SortOrder
    _count?: BudgetCategoryCountOrderByAggregateInput
    _avg?: BudgetCategoryAvgOrderByAggregateInput
    _max?: BudgetCategoryMaxOrderByAggregateInput
    _min?: BudgetCategoryMinOrderByAggregateInput
    _sum?: BudgetCategorySumOrderByAggregateInput
  }

  export type BudgetCategoryScalarWhereWithAggregatesInput = {
    AND?: BudgetCategoryScalarWhereWithAggregatesInput | BudgetCategoryScalarWhereWithAggregatesInput[]
    OR?: BudgetCategoryScalarWhereWithAggregatesInput[]
    NOT?: BudgetCategoryScalarWhereWithAggregatesInput | BudgetCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BudgetCategory"> | string
    budgetId?: StringWithAggregatesFilter<"BudgetCategory"> | string
    categoryId?: StringWithAggregatesFilter<"BudgetCategory"> | string
    budgeted?: FloatWithAggregatesFilter<"BudgetCategory"> | number
    spent?: FloatWithAggregatesFilter<"BudgetCategory"> | number
  }

  export type GoalWhereInput = {
    AND?: GoalWhereInput | GoalWhereInput[]
    OR?: GoalWhereInput[]
    NOT?: GoalWhereInput | GoalWhereInput[]
    id?: StringFilter<"Goal"> | string
    workspaceId?: StringFilter<"Goal"> | string
    name?: StringFilter<"Goal"> | string
    description?: StringNullableFilter<"Goal"> | string | null
    type?: StringFilter<"Goal"> | string
    targetAmount?: FloatFilter<"Goal"> | number
    currentAmount?: FloatFilter<"Goal"> | number
    startDate?: DateTimeFilter<"Goal"> | Date | string
    targetDate?: DateTimeNullableFilter<"Goal"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Goal"> | Date | string | null
    status?: StringFilter<"Goal"> | string
    icon?: StringFilter<"Goal"> | string
    color?: StringFilter<"Goal"> | string
    autoAllocate?: BoolFilter<"Goal"> | boolean
    allocationPercentage?: FloatNullableFilter<"Goal"> | number | null
    createdAt?: DateTimeFilter<"Goal"> | Date | string
    updatedAt?: DateTimeFilter<"Goal"> | Date | string
    contributions?: GoalContributionListRelationFilter
    Workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
  }

  export type GoalOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    targetAmount?: SortOrder
    currentAmount?: SortOrder
    startDate?: SortOrder
    targetDate?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    autoAllocate?: SortOrder
    allocationPercentage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contributions?: GoalContributionOrderByRelationAggregateInput
    Workspace?: WorkspaceOrderByWithRelationInput
  }

  export type GoalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GoalWhereInput | GoalWhereInput[]
    OR?: GoalWhereInput[]
    NOT?: GoalWhereInput | GoalWhereInput[]
    workspaceId?: StringFilter<"Goal"> | string
    name?: StringFilter<"Goal"> | string
    description?: StringNullableFilter<"Goal"> | string | null
    type?: StringFilter<"Goal"> | string
    targetAmount?: FloatFilter<"Goal"> | number
    currentAmount?: FloatFilter<"Goal"> | number
    startDate?: DateTimeFilter<"Goal"> | Date | string
    targetDate?: DateTimeNullableFilter<"Goal"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Goal"> | Date | string | null
    status?: StringFilter<"Goal"> | string
    icon?: StringFilter<"Goal"> | string
    color?: StringFilter<"Goal"> | string
    autoAllocate?: BoolFilter<"Goal"> | boolean
    allocationPercentage?: FloatNullableFilter<"Goal"> | number | null
    createdAt?: DateTimeFilter<"Goal"> | Date | string
    updatedAt?: DateTimeFilter<"Goal"> | Date | string
    contributions?: GoalContributionListRelationFilter
    Workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
  }, "id">

  export type GoalOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    targetAmount?: SortOrder
    currentAmount?: SortOrder
    startDate?: SortOrder
    targetDate?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    autoAllocate?: SortOrder
    allocationPercentage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GoalCountOrderByAggregateInput
    _avg?: GoalAvgOrderByAggregateInput
    _max?: GoalMaxOrderByAggregateInput
    _min?: GoalMinOrderByAggregateInput
    _sum?: GoalSumOrderByAggregateInput
  }

  export type GoalScalarWhereWithAggregatesInput = {
    AND?: GoalScalarWhereWithAggregatesInput | GoalScalarWhereWithAggregatesInput[]
    OR?: GoalScalarWhereWithAggregatesInput[]
    NOT?: GoalScalarWhereWithAggregatesInput | GoalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Goal"> | string
    workspaceId?: StringWithAggregatesFilter<"Goal"> | string
    name?: StringWithAggregatesFilter<"Goal"> | string
    description?: StringNullableWithAggregatesFilter<"Goal"> | string | null
    type?: StringWithAggregatesFilter<"Goal"> | string
    targetAmount?: FloatWithAggregatesFilter<"Goal"> | number
    currentAmount?: FloatWithAggregatesFilter<"Goal"> | number
    startDate?: DateTimeWithAggregatesFilter<"Goal"> | Date | string
    targetDate?: DateTimeNullableWithAggregatesFilter<"Goal"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"Goal"> | Date | string | null
    status?: StringWithAggregatesFilter<"Goal"> | string
    icon?: StringWithAggregatesFilter<"Goal"> | string
    color?: StringWithAggregatesFilter<"Goal"> | string
    autoAllocate?: BoolWithAggregatesFilter<"Goal"> | boolean
    allocationPercentage?: FloatNullableWithAggregatesFilter<"Goal"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Goal"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Goal"> | Date | string
  }

  export type GoalContributionWhereInput = {
    AND?: GoalContributionWhereInput | GoalContributionWhereInput[]
    OR?: GoalContributionWhereInput[]
    NOT?: GoalContributionWhereInput | GoalContributionWhereInput[]
    id?: StringFilter<"GoalContribution"> | string
    goalId?: StringFilter<"GoalContribution"> | string
    amount?: FloatFilter<"GoalContribution"> | number
    description?: StringNullableFilter<"GoalContribution"> | string | null
    contributedAt?: DateTimeFilter<"GoalContribution"> | Date | string
    goal?: XOR<GoalRelationFilter, GoalWhereInput>
  }

  export type GoalContributionOrderByWithRelationInput = {
    id?: SortOrder
    goalId?: SortOrder
    amount?: SortOrder
    description?: SortOrderInput | SortOrder
    contributedAt?: SortOrder
    goal?: GoalOrderByWithRelationInput
  }

  export type GoalContributionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GoalContributionWhereInput | GoalContributionWhereInput[]
    OR?: GoalContributionWhereInput[]
    NOT?: GoalContributionWhereInput | GoalContributionWhereInput[]
    goalId?: StringFilter<"GoalContribution"> | string
    amount?: FloatFilter<"GoalContribution"> | number
    description?: StringNullableFilter<"GoalContribution"> | string | null
    contributedAt?: DateTimeFilter<"GoalContribution"> | Date | string
    goal?: XOR<GoalRelationFilter, GoalWhereInput>
  }, "id">

  export type GoalContributionOrderByWithAggregationInput = {
    id?: SortOrder
    goalId?: SortOrder
    amount?: SortOrder
    description?: SortOrderInput | SortOrder
    contributedAt?: SortOrder
    _count?: GoalContributionCountOrderByAggregateInput
    _avg?: GoalContributionAvgOrderByAggregateInput
    _max?: GoalContributionMaxOrderByAggregateInput
    _min?: GoalContributionMinOrderByAggregateInput
    _sum?: GoalContributionSumOrderByAggregateInput
  }

  export type GoalContributionScalarWhereWithAggregatesInput = {
    AND?: GoalContributionScalarWhereWithAggregatesInput | GoalContributionScalarWhereWithAggregatesInput[]
    OR?: GoalContributionScalarWhereWithAggregatesInput[]
    NOT?: GoalContributionScalarWhereWithAggregatesInput | GoalContributionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GoalContribution"> | string
    goalId?: StringWithAggregatesFilter<"GoalContribution"> | string
    amount?: FloatWithAggregatesFilter<"GoalContribution"> | number
    description?: StringNullableWithAggregatesFilter<"GoalContribution"> | string | null
    contributedAt?: DateTimeWithAggregatesFilter<"GoalContribution"> | Date | string
  }

  export type ImportJobWhereInput = {
    AND?: ImportJobWhereInput | ImportJobWhereInput[]
    OR?: ImportJobWhereInput[]
    NOT?: ImportJobWhereInput | ImportJobWhereInput[]
    id?: StringFilter<"ImportJob"> | string
    workspaceId?: StringFilter<"ImportJob"> | string
    accountId?: StringFilter<"ImportJob"> | string
    format?: StringFilter<"ImportJob"> | string
    fileName?: StringFilter<"ImportJob"> | string
    fileSize?: IntFilter<"ImportJob"> | number
    fileUrl?: StringNullableFilter<"ImportJob"> | string | null
    status?: StringFilter<"ImportJob"> | string
    progress?: IntFilter<"ImportJob"> | number
    totalRows?: IntFilter<"ImportJob"> | number
    processedRows?: IntFilter<"ImportJob"> | number
    importedRows?: IntFilter<"ImportJob"> | number
    errorLog?: StringNullableFilter<"ImportJob"> | string | null
    mappingConfig?: StringNullableFilter<"ImportJob"> | string | null
    startedAt?: DateTimeNullableFilter<"ImportJob"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"ImportJob"> | Date | string | null
    createdAt?: DateTimeFilter<"ImportJob"> | Date | string
    Workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
  }

  export type ImportJobOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    accountId?: SortOrder
    format?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    fileUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    progress?: SortOrder
    totalRows?: SortOrder
    processedRows?: SortOrder
    importedRows?: SortOrder
    errorLog?: SortOrderInput | SortOrder
    mappingConfig?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    Workspace?: WorkspaceOrderByWithRelationInput
  }

  export type ImportJobWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ImportJobWhereInput | ImportJobWhereInput[]
    OR?: ImportJobWhereInput[]
    NOT?: ImportJobWhereInput | ImportJobWhereInput[]
    workspaceId?: StringFilter<"ImportJob"> | string
    accountId?: StringFilter<"ImportJob"> | string
    format?: StringFilter<"ImportJob"> | string
    fileName?: StringFilter<"ImportJob"> | string
    fileSize?: IntFilter<"ImportJob"> | number
    fileUrl?: StringNullableFilter<"ImportJob"> | string | null
    status?: StringFilter<"ImportJob"> | string
    progress?: IntFilter<"ImportJob"> | number
    totalRows?: IntFilter<"ImportJob"> | number
    processedRows?: IntFilter<"ImportJob"> | number
    importedRows?: IntFilter<"ImportJob"> | number
    errorLog?: StringNullableFilter<"ImportJob"> | string | null
    mappingConfig?: StringNullableFilter<"ImportJob"> | string | null
    startedAt?: DateTimeNullableFilter<"ImportJob"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"ImportJob"> | Date | string | null
    createdAt?: DateTimeFilter<"ImportJob"> | Date | string
    Workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
  }, "id">

  export type ImportJobOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    accountId?: SortOrder
    format?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    fileUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    progress?: SortOrder
    totalRows?: SortOrder
    processedRows?: SortOrder
    importedRows?: SortOrder
    errorLog?: SortOrderInput | SortOrder
    mappingConfig?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ImportJobCountOrderByAggregateInput
    _avg?: ImportJobAvgOrderByAggregateInput
    _max?: ImportJobMaxOrderByAggregateInput
    _min?: ImportJobMinOrderByAggregateInput
    _sum?: ImportJobSumOrderByAggregateInput
  }

  export type ImportJobScalarWhereWithAggregatesInput = {
    AND?: ImportJobScalarWhereWithAggregatesInput | ImportJobScalarWhereWithAggregatesInput[]
    OR?: ImportJobScalarWhereWithAggregatesInput[]
    NOT?: ImportJobScalarWhereWithAggregatesInput | ImportJobScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ImportJob"> | string
    workspaceId?: StringWithAggregatesFilter<"ImportJob"> | string
    accountId?: StringWithAggregatesFilter<"ImportJob"> | string
    format?: StringWithAggregatesFilter<"ImportJob"> | string
    fileName?: StringWithAggregatesFilter<"ImportJob"> | string
    fileSize?: IntWithAggregatesFilter<"ImportJob"> | number
    fileUrl?: StringNullableWithAggregatesFilter<"ImportJob"> | string | null
    status?: StringWithAggregatesFilter<"ImportJob"> | string
    progress?: IntWithAggregatesFilter<"ImportJob"> | number
    totalRows?: IntWithAggregatesFilter<"ImportJob"> | number
    processedRows?: IntWithAggregatesFilter<"ImportJob"> | number
    importedRows?: IntWithAggregatesFilter<"ImportJob"> | number
    errorLog?: StringNullableWithAggregatesFilter<"ImportJob"> | string | null
    mappingConfig?: StringNullableWithAggregatesFilter<"ImportJob"> | string | null
    startedAt?: DateTimeNullableWithAggregatesFilter<"ImportJob"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"ImportJob"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ImportJob"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    workspaceId?: StringNullableFilter<"Notification"> | string | null
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    data?: StringNullableFilter<"Notification"> | string | null
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrderInput | SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    data?: SortOrderInput | SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    workspaceId?: StringNullableFilter<"Notification"> | string | null
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    data?: StringNullableFilter<"Notification"> | string | null
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrderInput | SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    data?: SortOrderInput | SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    workspaceId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    type?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    data?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    readAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    workspaceId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    oldData?: StringNullableFilter<"AuditLog"> | string | null
    newData?: StringNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    Workspace?: XOR<WorkspaceNullableRelationFilter, WorkspaceWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    workspaceId?: SortOrderInput | SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrderInput | SortOrder
    oldData?: SortOrderInput | SortOrder
    newData?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    Workspace?: WorkspaceOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: StringNullableFilter<"AuditLog"> | string | null
    workspaceId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    oldData?: StringNullableFilter<"AuditLog"> | string | null
    newData?: StringNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    Workspace?: XOR<WorkspaceNullableRelationFilter, WorkspaceWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    workspaceId?: SortOrderInput | SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrderInput | SortOrder
    oldData?: SortOrderInput | SortOrder
    newData?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    workspaceId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    entityType?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    oldData?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    newData?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type UserGamificationWhereInput = {
    AND?: UserGamificationWhereInput | UserGamificationWhereInput[]
    OR?: UserGamificationWhereInput[]
    NOT?: UserGamificationWhereInput | UserGamificationWhereInput[]
    id?: StringFilter<"UserGamification"> | string
    userId?: StringFilter<"UserGamification"> | string
    tier?: StringFilter<"UserGamification"> | string
    totalXP?: IntFilter<"UserGamification"> | number
    currentLevel?: IntFilter<"UserGamification"> | number
    xpToNextLevel?: IntFilter<"UserGamification"> | number
    loginStreak?: IntFilter<"UserGamification"> | number
    longestLoginStreak?: IntFilter<"UserGamification"> | number
    transactionStreak?: IntFilter<"UserGamification"> | number
    transactionsLogged?: IntFilter<"UserGamification"> | number
    budgetsMet?: IntFilter<"UserGamification"> | number
    goalsAchieved?: IntFilter<"UserGamification"> | number
    lastLoginDate?: DateTimeNullableFilter<"UserGamification"> | Date | string | null
    createdAt?: DateTimeFilter<"UserGamification"> | Date | string
    updatedAt?: DateTimeFilter<"UserGamification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    achievements?: UserAchievementListRelationFilter
  }

  export type UserGamificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    tier?: SortOrder
    totalXP?: SortOrder
    currentLevel?: SortOrder
    xpToNextLevel?: SortOrder
    loginStreak?: SortOrder
    longestLoginStreak?: SortOrder
    transactionStreak?: SortOrder
    transactionsLogged?: SortOrder
    budgetsMet?: SortOrder
    goalsAchieved?: SortOrder
    lastLoginDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    achievements?: UserAchievementOrderByRelationAggregateInput
  }

  export type UserGamificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserGamificationWhereInput | UserGamificationWhereInput[]
    OR?: UserGamificationWhereInput[]
    NOT?: UserGamificationWhereInput | UserGamificationWhereInput[]
    tier?: StringFilter<"UserGamification"> | string
    totalXP?: IntFilter<"UserGamification"> | number
    currentLevel?: IntFilter<"UserGamification"> | number
    xpToNextLevel?: IntFilter<"UserGamification"> | number
    loginStreak?: IntFilter<"UserGamification"> | number
    longestLoginStreak?: IntFilter<"UserGamification"> | number
    transactionStreak?: IntFilter<"UserGamification"> | number
    transactionsLogged?: IntFilter<"UserGamification"> | number
    budgetsMet?: IntFilter<"UserGamification"> | number
    goalsAchieved?: IntFilter<"UserGamification"> | number
    lastLoginDate?: DateTimeNullableFilter<"UserGamification"> | Date | string | null
    createdAt?: DateTimeFilter<"UserGamification"> | Date | string
    updatedAt?: DateTimeFilter<"UserGamification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    achievements?: UserAchievementListRelationFilter
  }, "id" | "userId">

  export type UserGamificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    tier?: SortOrder
    totalXP?: SortOrder
    currentLevel?: SortOrder
    xpToNextLevel?: SortOrder
    loginStreak?: SortOrder
    longestLoginStreak?: SortOrder
    transactionStreak?: SortOrder
    transactionsLogged?: SortOrder
    budgetsMet?: SortOrder
    goalsAchieved?: SortOrder
    lastLoginDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserGamificationCountOrderByAggregateInput
    _avg?: UserGamificationAvgOrderByAggregateInput
    _max?: UserGamificationMaxOrderByAggregateInput
    _min?: UserGamificationMinOrderByAggregateInput
    _sum?: UserGamificationSumOrderByAggregateInput
  }

  export type UserGamificationScalarWhereWithAggregatesInput = {
    AND?: UserGamificationScalarWhereWithAggregatesInput | UserGamificationScalarWhereWithAggregatesInput[]
    OR?: UserGamificationScalarWhereWithAggregatesInput[]
    NOT?: UserGamificationScalarWhereWithAggregatesInput | UserGamificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserGamification"> | string
    userId?: StringWithAggregatesFilter<"UserGamification"> | string
    tier?: StringWithAggregatesFilter<"UserGamification"> | string
    totalXP?: IntWithAggregatesFilter<"UserGamification"> | number
    currentLevel?: IntWithAggregatesFilter<"UserGamification"> | number
    xpToNextLevel?: IntWithAggregatesFilter<"UserGamification"> | number
    loginStreak?: IntWithAggregatesFilter<"UserGamification"> | number
    longestLoginStreak?: IntWithAggregatesFilter<"UserGamification"> | number
    transactionStreak?: IntWithAggregatesFilter<"UserGamification"> | number
    transactionsLogged?: IntWithAggregatesFilter<"UserGamification"> | number
    budgetsMet?: IntWithAggregatesFilter<"UserGamification"> | number
    goalsAchieved?: IntWithAggregatesFilter<"UserGamification"> | number
    lastLoginDate?: DateTimeNullableWithAggregatesFilter<"UserGamification"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserGamification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserGamification"> | Date | string
  }

  export type AchievementWhereInput = {
    AND?: AchievementWhereInput | AchievementWhereInput[]
    OR?: AchievementWhereInput[]
    NOT?: AchievementWhereInput | AchievementWhereInput[]
    id?: StringFilter<"Achievement"> | string
    type?: StringFilter<"Achievement"> | string
    name?: StringFilter<"Achievement"> | string
    description?: StringFilter<"Achievement"> | string
    icon?: StringFilter<"Achievement"> | string
    color?: StringFilter<"Achievement"> | string
    xpReward?: IntFilter<"Achievement"> | number
    requirementType?: StringFilter<"Achievement"> | string
    requirementValue?: IntFilter<"Achievement"> | number
    createdAt?: DateTimeFilter<"Achievement"> | Date | string
  }

  export type AchievementOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    xpReward?: SortOrder
    requirementType?: SortOrder
    requirementValue?: SortOrder
    createdAt?: SortOrder
  }

  export type AchievementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    type?: string
    AND?: AchievementWhereInput | AchievementWhereInput[]
    OR?: AchievementWhereInput[]
    NOT?: AchievementWhereInput | AchievementWhereInput[]
    name?: StringFilter<"Achievement"> | string
    description?: StringFilter<"Achievement"> | string
    icon?: StringFilter<"Achievement"> | string
    color?: StringFilter<"Achievement"> | string
    xpReward?: IntFilter<"Achievement"> | number
    requirementType?: StringFilter<"Achievement"> | string
    requirementValue?: IntFilter<"Achievement"> | number
    createdAt?: DateTimeFilter<"Achievement"> | Date | string
  }, "id" | "type">

  export type AchievementOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    xpReward?: SortOrder
    requirementType?: SortOrder
    requirementValue?: SortOrder
    createdAt?: SortOrder
    _count?: AchievementCountOrderByAggregateInput
    _avg?: AchievementAvgOrderByAggregateInput
    _max?: AchievementMaxOrderByAggregateInput
    _min?: AchievementMinOrderByAggregateInput
    _sum?: AchievementSumOrderByAggregateInput
  }

  export type AchievementScalarWhereWithAggregatesInput = {
    AND?: AchievementScalarWhereWithAggregatesInput | AchievementScalarWhereWithAggregatesInput[]
    OR?: AchievementScalarWhereWithAggregatesInput[]
    NOT?: AchievementScalarWhereWithAggregatesInput | AchievementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Achievement"> | string
    type?: StringWithAggregatesFilter<"Achievement"> | string
    name?: StringWithAggregatesFilter<"Achievement"> | string
    description?: StringWithAggregatesFilter<"Achievement"> | string
    icon?: StringWithAggregatesFilter<"Achievement"> | string
    color?: StringWithAggregatesFilter<"Achievement"> | string
    xpReward?: IntWithAggregatesFilter<"Achievement"> | number
    requirementType?: StringWithAggregatesFilter<"Achievement"> | string
    requirementValue?: IntWithAggregatesFilter<"Achievement"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Achievement"> | Date | string
  }

  export type UserAchievementWhereInput = {
    AND?: UserAchievementWhereInput | UserAchievementWhereInput[]
    OR?: UserAchievementWhereInput[]
    NOT?: UserAchievementWhereInput | UserAchievementWhereInput[]
    id?: StringFilter<"UserAchievement"> | string
    userGamificationId?: StringFilter<"UserAchievement"> | string
    achievementId?: StringFilter<"UserAchievement"> | string
    unlockedAt?: DateTimeFilter<"UserAchievement"> | Date | string
    UserGamification?: XOR<UserGamificationRelationFilter, UserGamificationWhereInput>
  }

  export type UserAchievementOrderByWithRelationInput = {
    id?: SortOrder
    userGamificationId?: SortOrder
    achievementId?: SortOrder
    unlockedAt?: SortOrder
    UserGamification?: UserGamificationOrderByWithRelationInput
  }

  export type UserAchievementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userGamificationId_achievementId?: UserAchievementUserGamificationIdAchievementIdCompoundUniqueInput
    AND?: UserAchievementWhereInput | UserAchievementWhereInput[]
    OR?: UserAchievementWhereInput[]
    NOT?: UserAchievementWhereInput | UserAchievementWhereInput[]
    userGamificationId?: StringFilter<"UserAchievement"> | string
    achievementId?: StringFilter<"UserAchievement"> | string
    unlockedAt?: DateTimeFilter<"UserAchievement"> | Date | string
    UserGamification?: XOR<UserGamificationRelationFilter, UserGamificationWhereInput>
  }, "id" | "userGamificationId_achievementId">

  export type UserAchievementOrderByWithAggregationInput = {
    id?: SortOrder
    userGamificationId?: SortOrder
    achievementId?: SortOrder
    unlockedAt?: SortOrder
    _count?: UserAchievementCountOrderByAggregateInput
    _max?: UserAchievementMaxOrderByAggregateInput
    _min?: UserAchievementMinOrderByAggregateInput
  }

  export type UserAchievementScalarWhereWithAggregatesInput = {
    AND?: UserAchievementScalarWhereWithAggregatesInput | UserAchievementScalarWhereWithAggregatesInput[]
    OR?: UserAchievementScalarWhereWithAggregatesInput[]
    NOT?: UserAchievementScalarWhereWithAggregatesInput | UserAchievementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserAchievement"> | string
    userGamificationId?: StringWithAggregatesFilter<"UserAchievement"> | string
    achievementId?: StringWithAggregatesFilter<"UserAchievement"> | string
    unlockedAt?: DateTimeWithAggregatesFilter<"UserAchievement"> | Date | string
  }

  export type EnvelopeWhereInput = {
    AND?: EnvelopeWhereInput | EnvelopeWhereInput[]
    OR?: EnvelopeWhereInput[]
    NOT?: EnvelopeWhereInput | EnvelopeWhereInput[]
    id?: StringFilter<"Envelope"> | string
    workspaceId?: StringFilter<"Envelope"> | string
    categoryId?: StringNullableFilter<"Envelope"> | string | null
    name?: StringFilter<"Envelope"> | string
    description?: StringNullableFilter<"Envelope"> | string | null
    color?: StringFilter<"Envelope"> | string
    budgetedAmount?: FloatFilter<"Envelope"> | number
    availableAmount?: FloatFilter<"Envelope"> | number
    spentAmount?: FloatFilter<"Envelope"> | number
    month?: IntFilter<"Envelope"> | number
    year?: IntFilter<"Envelope"> | number
    isActive?: BoolFilter<"Envelope"> | boolean
    createdAt?: DateTimeFilter<"Envelope"> | Date | string
    updatedAt?: DateTimeFilter<"Envelope"> | Date | string
    Workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
    Category?: XOR<CategoryNullableRelationFilter, CategoryWhereInput> | null
  }

  export type EnvelopeOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrder
    budgetedAmount?: SortOrder
    availableAmount?: SortOrder
    spentAmount?: SortOrder
    month?: SortOrder
    year?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Workspace?: WorkspaceOrderByWithRelationInput
    Category?: CategoryOrderByWithRelationInput
  }

  export type EnvelopeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    workspaceId_categoryId_month_year?: EnvelopeWorkspaceIdCategoryIdMonthYearCompoundUniqueInput
    AND?: EnvelopeWhereInput | EnvelopeWhereInput[]
    OR?: EnvelopeWhereInput[]
    NOT?: EnvelopeWhereInput | EnvelopeWhereInput[]
    workspaceId?: StringFilter<"Envelope"> | string
    categoryId?: StringNullableFilter<"Envelope"> | string | null
    name?: StringFilter<"Envelope"> | string
    description?: StringNullableFilter<"Envelope"> | string | null
    color?: StringFilter<"Envelope"> | string
    budgetedAmount?: FloatFilter<"Envelope"> | number
    availableAmount?: FloatFilter<"Envelope"> | number
    spentAmount?: FloatFilter<"Envelope"> | number
    month?: IntFilter<"Envelope"> | number
    year?: IntFilter<"Envelope"> | number
    isActive?: BoolFilter<"Envelope"> | boolean
    createdAt?: DateTimeFilter<"Envelope"> | Date | string
    updatedAt?: DateTimeFilter<"Envelope"> | Date | string
    Workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
    Category?: XOR<CategoryNullableRelationFilter, CategoryWhereInput> | null
  }, "id" | "workspaceId_categoryId_month_year">

  export type EnvelopeOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrder
    budgetedAmount?: SortOrder
    availableAmount?: SortOrder
    spentAmount?: SortOrder
    month?: SortOrder
    year?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EnvelopeCountOrderByAggregateInput
    _avg?: EnvelopeAvgOrderByAggregateInput
    _max?: EnvelopeMaxOrderByAggregateInput
    _min?: EnvelopeMinOrderByAggregateInput
    _sum?: EnvelopeSumOrderByAggregateInput
  }

  export type EnvelopeScalarWhereWithAggregatesInput = {
    AND?: EnvelopeScalarWhereWithAggregatesInput | EnvelopeScalarWhereWithAggregatesInput[]
    OR?: EnvelopeScalarWhereWithAggregatesInput[]
    NOT?: EnvelopeScalarWhereWithAggregatesInput | EnvelopeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Envelope"> | string
    workspaceId?: StringWithAggregatesFilter<"Envelope"> | string
    categoryId?: StringNullableWithAggregatesFilter<"Envelope"> | string | null
    name?: StringWithAggregatesFilter<"Envelope"> | string
    description?: StringNullableWithAggregatesFilter<"Envelope"> | string | null
    color?: StringWithAggregatesFilter<"Envelope"> | string
    budgetedAmount?: FloatWithAggregatesFilter<"Envelope"> | number
    availableAmount?: FloatWithAggregatesFilter<"Envelope"> | number
    spentAmount?: FloatWithAggregatesFilter<"Envelope"> | number
    month?: IntWithAggregatesFilter<"Envelope"> | number
    year?: IntWithAggregatesFilter<"Envelope"> | number
    isActive?: BoolWithAggregatesFilter<"Envelope"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Envelope"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Envelope"> | Date | string
  }

  export type AssetWhereInput = {
    AND?: AssetWhereInput | AssetWhereInput[]
    OR?: AssetWhereInput[]
    NOT?: AssetWhereInput | AssetWhereInput[]
    id?: StringFilter<"Asset"> | string
    workspaceId?: StringFilter<"Asset"> | string
    name?: StringFilter<"Asset"> | string
    type?: StringFilter<"Asset"> | string
    description?: StringNullableFilter<"Asset"> | string | null
    currentValue?: FloatFilter<"Asset"> | number
    purchaseValue?: FloatNullableFilter<"Asset"> | number | null
    purchaseDate?: DateTimeNullableFilter<"Asset"> | Date | string | null
    isActive?: BoolFilter<"Asset"> | boolean
    createdAt?: DateTimeFilter<"Asset"> | Date | string
    updatedAt?: DateTimeFilter<"Asset"> | Date | string
    Workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
  }

  export type AssetOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    currentValue?: SortOrder
    purchaseValue?: SortOrderInput | SortOrder
    purchaseDate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Workspace?: WorkspaceOrderByWithRelationInput
  }

  export type AssetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AssetWhereInput | AssetWhereInput[]
    OR?: AssetWhereInput[]
    NOT?: AssetWhereInput | AssetWhereInput[]
    workspaceId?: StringFilter<"Asset"> | string
    name?: StringFilter<"Asset"> | string
    type?: StringFilter<"Asset"> | string
    description?: StringNullableFilter<"Asset"> | string | null
    currentValue?: FloatFilter<"Asset"> | number
    purchaseValue?: FloatNullableFilter<"Asset"> | number | null
    purchaseDate?: DateTimeNullableFilter<"Asset"> | Date | string | null
    isActive?: BoolFilter<"Asset"> | boolean
    createdAt?: DateTimeFilter<"Asset"> | Date | string
    updatedAt?: DateTimeFilter<"Asset"> | Date | string
    Workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
  }, "id">

  export type AssetOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    currentValue?: SortOrder
    purchaseValue?: SortOrderInput | SortOrder
    purchaseDate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AssetCountOrderByAggregateInput
    _avg?: AssetAvgOrderByAggregateInput
    _max?: AssetMaxOrderByAggregateInput
    _min?: AssetMinOrderByAggregateInput
    _sum?: AssetSumOrderByAggregateInput
  }

  export type AssetScalarWhereWithAggregatesInput = {
    AND?: AssetScalarWhereWithAggregatesInput | AssetScalarWhereWithAggregatesInput[]
    OR?: AssetScalarWhereWithAggregatesInput[]
    NOT?: AssetScalarWhereWithAggregatesInput | AssetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Asset"> | string
    workspaceId?: StringWithAggregatesFilter<"Asset"> | string
    name?: StringWithAggregatesFilter<"Asset"> | string
    type?: StringWithAggregatesFilter<"Asset"> | string
    description?: StringNullableWithAggregatesFilter<"Asset"> | string | null
    currentValue?: FloatWithAggregatesFilter<"Asset"> | number
    purchaseValue?: FloatNullableWithAggregatesFilter<"Asset"> | number | null
    purchaseDate?: DateTimeNullableWithAggregatesFilter<"Asset"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"Asset"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Asset"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Asset"> | Date | string
  }

  export type LiabilityWhereInput = {
    AND?: LiabilityWhereInput | LiabilityWhereInput[]
    OR?: LiabilityWhereInput[]
    NOT?: LiabilityWhereInput | LiabilityWhereInput[]
    id?: StringFilter<"Liability"> | string
    workspaceId?: StringFilter<"Liability"> | string
    name?: StringFilter<"Liability"> | string
    type?: StringFilter<"Liability"> | string
    description?: StringNullableFilter<"Liability"> | string | null
    currentBalance?: FloatFilter<"Liability"> | number
    originalAmount?: FloatFilter<"Liability"> | number
    interestRate?: FloatNullableFilter<"Liability"> | number | null
    startDate?: DateTimeFilter<"Liability"> | Date | string
    endDate?: DateTimeNullableFilter<"Liability"> | Date | string | null
    isActive?: BoolFilter<"Liability"> | boolean
    createdAt?: DateTimeFilter<"Liability"> | Date | string
    updatedAt?: DateTimeFilter<"Liability"> | Date | string
    Workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
  }

  export type LiabilityOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    currentBalance?: SortOrder
    originalAmount?: SortOrder
    interestRate?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Workspace?: WorkspaceOrderByWithRelationInput
  }

  export type LiabilityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LiabilityWhereInput | LiabilityWhereInput[]
    OR?: LiabilityWhereInput[]
    NOT?: LiabilityWhereInput | LiabilityWhereInput[]
    workspaceId?: StringFilter<"Liability"> | string
    name?: StringFilter<"Liability"> | string
    type?: StringFilter<"Liability"> | string
    description?: StringNullableFilter<"Liability"> | string | null
    currentBalance?: FloatFilter<"Liability"> | number
    originalAmount?: FloatFilter<"Liability"> | number
    interestRate?: FloatNullableFilter<"Liability"> | number | null
    startDate?: DateTimeFilter<"Liability"> | Date | string
    endDate?: DateTimeNullableFilter<"Liability"> | Date | string | null
    isActive?: BoolFilter<"Liability"> | boolean
    createdAt?: DateTimeFilter<"Liability"> | Date | string
    updatedAt?: DateTimeFilter<"Liability"> | Date | string
    Workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
  }, "id">

  export type LiabilityOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    currentBalance?: SortOrder
    originalAmount?: SortOrder
    interestRate?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LiabilityCountOrderByAggregateInput
    _avg?: LiabilityAvgOrderByAggregateInput
    _max?: LiabilityMaxOrderByAggregateInput
    _min?: LiabilityMinOrderByAggregateInput
    _sum?: LiabilitySumOrderByAggregateInput
  }

  export type LiabilityScalarWhereWithAggregatesInput = {
    AND?: LiabilityScalarWhereWithAggregatesInput | LiabilityScalarWhereWithAggregatesInput[]
    OR?: LiabilityScalarWhereWithAggregatesInput[]
    NOT?: LiabilityScalarWhereWithAggregatesInput | LiabilityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Liability"> | string
    workspaceId?: StringWithAggregatesFilter<"Liability"> | string
    name?: StringWithAggregatesFilter<"Liability"> | string
    type?: StringWithAggregatesFilter<"Liability"> | string
    description?: StringNullableWithAggregatesFilter<"Liability"> | string | null
    currentBalance?: FloatWithAggregatesFilter<"Liability"> | number
    originalAmount?: FloatWithAggregatesFilter<"Liability"> | number
    interestRate?: FloatNullableWithAggregatesFilter<"Liability"> | number | null
    startDate?: DateTimeWithAggregatesFilter<"Liability"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"Liability"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"Liability"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Liability"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Liability"> | Date | string
  }

  export type AIInsightWhereInput = {
    AND?: AIInsightWhereInput | AIInsightWhereInput[]
    OR?: AIInsightWhereInput[]
    NOT?: AIInsightWhereInput | AIInsightWhereInput[]
    id?: StringFilter<"AIInsight"> | string
    workspaceId?: StringFilter<"AIInsight"> | string
    userId?: StringFilter<"AIInsight"> | string
    type?: StringFilter<"AIInsight"> | string
    title?: StringFilter<"AIInsight"> | string
    description?: StringFilter<"AIInsight"> | string
    severity?: StringFilter<"AIInsight"> | string
    suggestedAction?: StringNullableFilter<"AIInsight"> | string | null
    actionTaken?: BoolFilter<"AIInsight"> | boolean
    confidenceScore?: FloatNullableFilter<"AIInsight"> | number | null
    dismissedAt?: DateTimeNullableFilter<"AIInsight"> | Date | string | null
    createdAt?: DateTimeFilter<"AIInsight"> | Date | string
    User?: XOR<UserRelationFilter, UserWhereInput>
    Workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
  }

  export type AIInsightOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    severity?: SortOrder
    suggestedAction?: SortOrderInput | SortOrder
    actionTaken?: SortOrder
    confidenceScore?: SortOrderInput | SortOrder
    dismissedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    User?: UserOrderByWithRelationInput
    Workspace?: WorkspaceOrderByWithRelationInput
  }

  export type AIInsightWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AIInsightWhereInput | AIInsightWhereInput[]
    OR?: AIInsightWhereInput[]
    NOT?: AIInsightWhereInput | AIInsightWhereInput[]
    workspaceId?: StringFilter<"AIInsight"> | string
    userId?: StringFilter<"AIInsight"> | string
    type?: StringFilter<"AIInsight"> | string
    title?: StringFilter<"AIInsight"> | string
    description?: StringFilter<"AIInsight"> | string
    severity?: StringFilter<"AIInsight"> | string
    suggestedAction?: StringNullableFilter<"AIInsight"> | string | null
    actionTaken?: BoolFilter<"AIInsight"> | boolean
    confidenceScore?: FloatNullableFilter<"AIInsight"> | number | null
    dismissedAt?: DateTimeNullableFilter<"AIInsight"> | Date | string | null
    createdAt?: DateTimeFilter<"AIInsight"> | Date | string
    User?: XOR<UserRelationFilter, UserWhereInput>
    Workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
  }, "id">

  export type AIInsightOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    severity?: SortOrder
    suggestedAction?: SortOrderInput | SortOrder
    actionTaken?: SortOrder
    confidenceScore?: SortOrderInput | SortOrder
    dismissedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AIInsightCountOrderByAggregateInput
    _avg?: AIInsightAvgOrderByAggregateInput
    _max?: AIInsightMaxOrderByAggregateInput
    _min?: AIInsightMinOrderByAggregateInput
    _sum?: AIInsightSumOrderByAggregateInput
  }

  export type AIInsightScalarWhereWithAggregatesInput = {
    AND?: AIInsightScalarWhereWithAggregatesInput | AIInsightScalarWhereWithAggregatesInput[]
    OR?: AIInsightScalarWhereWithAggregatesInput[]
    NOT?: AIInsightScalarWhereWithAggregatesInput | AIInsightScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AIInsight"> | string
    workspaceId?: StringWithAggregatesFilter<"AIInsight"> | string
    userId?: StringWithAggregatesFilter<"AIInsight"> | string
    type?: StringWithAggregatesFilter<"AIInsight"> | string
    title?: StringWithAggregatesFilter<"AIInsight"> | string
    description?: StringWithAggregatesFilter<"AIInsight"> | string
    severity?: StringWithAggregatesFilter<"AIInsight"> | string
    suggestedAction?: StringNullableWithAggregatesFilter<"AIInsight"> | string | null
    actionTaken?: BoolWithAggregatesFilter<"AIInsight"> | boolean
    confidenceScore?: FloatNullableWithAggregatesFilter<"AIInsight"> | number | null
    dismissedAt?: DateTimeNullableWithAggregatesFilter<"AIInsight"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AIInsight"> | Date | string
  }

  export type ScenarioWhereInput = {
    AND?: ScenarioWhereInput | ScenarioWhereInput[]
    OR?: ScenarioWhereInput[]
    NOT?: ScenarioWhereInput | ScenarioWhereInput[]
    id?: StringFilter<"Scenario"> | string
    workspaceId?: StringFilter<"Scenario"> | string
    userId?: StringFilter<"Scenario"> | string
    name?: StringFilter<"Scenario"> | string
    description?: StringNullableFilter<"Scenario"> | string | null
    type?: StringFilter<"Scenario"> | string
    parameters?: StringFilter<"Scenario"> | string
    isFavorite?: BoolFilter<"Scenario"> | boolean
    isActive?: BoolFilter<"Scenario"> | boolean
    createdAt?: DateTimeFilter<"Scenario"> | Date | string
    updatedAt?: DateTimeFilter<"Scenario"> | Date | string
    User?: XOR<UserRelationFilter, UserWhereInput>
    Workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
  }

  export type ScenarioOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    parameters?: SortOrder
    isFavorite?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    User?: UserOrderByWithRelationInput
    Workspace?: WorkspaceOrderByWithRelationInput
  }

  export type ScenarioWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ScenarioWhereInput | ScenarioWhereInput[]
    OR?: ScenarioWhereInput[]
    NOT?: ScenarioWhereInput | ScenarioWhereInput[]
    workspaceId?: StringFilter<"Scenario"> | string
    userId?: StringFilter<"Scenario"> | string
    name?: StringFilter<"Scenario"> | string
    description?: StringNullableFilter<"Scenario"> | string | null
    type?: StringFilter<"Scenario"> | string
    parameters?: StringFilter<"Scenario"> | string
    isFavorite?: BoolFilter<"Scenario"> | boolean
    isActive?: BoolFilter<"Scenario"> | boolean
    createdAt?: DateTimeFilter<"Scenario"> | Date | string
    updatedAt?: DateTimeFilter<"Scenario"> | Date | string
    User?: XOR<UserRelationFilter, UserWhereInput>
    Workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
  }, "id">

  export type ScenarioOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    parameters?: SortOrder
    isFavorite?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ScenarioCountOrderByAggregateInput
    _max?: ScenarioMaxOrderByAggregateInput
    _min?: ScenarioMinOrderByAggregateInput
  }

  export type ScenarioScalarWhereWithAggregatesInput = {
    AND?: ScenarioScalarWhereWithAggregatesInput | ScenarioScalarWhereWithAggregatesInput[]
    OR?: ScenarioScalarWhereWithAggregatesInput[]
    NOT?: ScenarioScalarWhereWithAggregatesInput | ScenarioScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Scenario"> | string
    workspaceId?: StringWithAggregatesFilter<"Scenario"> | string
    userId?: StringWithAggregatesFilter<"Scenario"> | string
    name?: StringWithAggregatesFilter<"Scenario"> | string
    description?: StringNullableWithAggregatesFilter<"Scenario"> | string | null
    type?: StringWithAggregatesFilter<"Scenario"> | string
    parameters?: StringWithAggregatesFilter<"Scenario"> | string
    isFavorite?: BoolWithAggregatesFilter<"Scenario"> | boolean
    isActive?: BoolWithAggregatesFilter<"Scenario"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Scenario"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Scenario"> | Date | string
  }

  export type BankConnectionWhereInput = {
    AND?: BankConnectionWhereInput | BankConnectionWhereInput[]
    OR?: BankConnectionWhereInput[]
    NOT?: BankConnectionWhereInput | BankConnectionWhereInput[]
    id?: StringFilter<"BankConnection"> | string
    workspaceId?: StringFilter<"BankConnection"> | string
    accountId?: StringFilter<"BankConnection"> | string
    bankName?: StringFilter<"BankConnection"> | string
    bankCode?: StringFilter<"BankConnection"> | string
    accessToken?: StringFilter<"BankConnection"> | string
    status?: StringFilter<"BankConnection"> | string
    lastSyncAt?: DateTimeNullableFilter<"BankConnection"> | Date | string | null
    lastSyncError?: StringNullableFilter<"BankConnection"> | string | null
    isActive?: BoolFilter<"BankConnection"> | boolean
    createdAt?: DateTimeFilter<"BankConnection"> | Date | string
    updatedAt?: DateTimeFilter<"BankConnection"> | Date | string
    Workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
    Account?: XOR<AccountRelationFilter, AccountWhereInput>
  }

  export type BankConnectionOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    accountId?: SortOrder
    bankName?: SortOrder
    bankCode?: SortOrder
    accessToken?: SortOrder
    status?: SortOrder
    lastSyncAt?: SortOrderInput | SortOrder
    lastSyncError?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Workspace?: WorkspaceOrderByWithRelationInput
    Account?: AccountOrderByWithRelationInput
  }

  export type BankConnectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BankConnectionWhereInput | BankConnectionWhereInput[]
    OR?: BankConnectionWhereInput[]
    NOT?: BankConnectionWhereInput | BankConnectionWhereInput[]
    workspaceId?: StringFilter<"BankConnection"> | string
    accountId?: StringFilter<"BankConnection"> | string
    bankName?: StringFilter<"BankConnection"> | string
    bankCode?: StringFilter<"BankConnection"> | string
    accessToken?: StringFilter<"BankConnection"> | string
    status?: StringFilter<"BankConnection"> | string
    lastSyncAt?: DateTimeNullableFilter<"BankConnection"> | Date | string | null
    lastSyncError?: StringNullableFilter<"BankConnection"> | string | null
    isActive?: BoolFilter<"BankConnection"> | boolean
    createdAt?: DateTimeFilter<"BankConnection"> | Date | string
    updatedAt?: DateTimeFilter<"BankConnection"> | Date | string
    Workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
    Account?: XOR<AccountRelationFilter, AccountWhereInput>
  }, "id">

  export type BankConnectionOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    accountId?: SortOrder
    bankName?: SortOrder
    bankCode?: SortOrder
    accessToken?: SortOrder
    status?: SortOrder
    lastSyncAt?: SortOrderInput | SortOrder
    lastSyncError?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BankConnectionCountOrderByAggregateInput
    _max?: BankConnectionMaxOrderByAggregateInput
    _min?: BankConnectionMinOrderByAggregateInput
  }

  export type BankConnectionScalarWhereWithAggregatesInput = {
    AND?: BankConnectionScalarWhereWithAggregatesInput | BankConnectionScalarWhereWithAggregatesInput[]
    OR?: BankConnectionScalarWhereWithAggregatesInput[]
    NOT?: BankConnectionScalarWhereWithAggregatesInput | BankConnectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BankConnection"> | string
    workspaceId?: StringWithAggregatesFilter<"BankConnection"> | string
    accountId?: StringWithAggregatesFilter<"BankConnection"> | string
    bankName?: StringWithAggregatesFilter<"BankConnection"> | string
    bankCode?: StringWithAggregatesFilter<"BankConnection"> | string
    accessToken?: StringWithAggregatesFilter<"BankConnection"> | string
    status?: StringWithAggregatesFilter<"BankConnection"> | string
    lastSyncAt?: DateTimeNullableWithAggregatesFilter<"BankConnection"> | Date | string | null
    lastSyncError?: StringNullableWithAggregatesFilter<"BankConnection"> | string | null
    isActive?: BoolWithAggregatesFilter<"BankConnection"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"BankConnection"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BankConnection"> | Date | string
  }

  export type AutoRuleWhereInput = {
    AND?: AutoRuleWhereInput | AutoRuleWhereInput[]
    OR?: AutoRuleWhereInput[]
    NOT?: AutoRuleWhereInput | AutoRuleWhereInput[]
    id?: StringFilter<"AutoRule"> | string
    workspaceId?: StringFilter<"AutoRule"> | string
    userId?: StringFilter<"AutoRule"> | string
    name?: StringFilter<"AutoRule"> | string
    description?: StringNullableFilter<"AutoRule"> | string | null
    isActive?: BoolFilter<"AutoRule"> | boolean
    priority?: IntFilter<"AutoRule"> | number
    conditions?: StringFilter<"AutoRule"> | string
    actions?: StringFilter<"AutoRule"> | string
    timesApplied?: IntFilter<"AutoRule"> | number
    createdAt?: DateTimeFilter<"AutoRule"> | Date | string
    updatedAt?: DateTimeFilter<"AutoRule"> | Date | string
    User?: XOR<UserRelationFilter, UserWhereInput>
    Workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
  }

  export type AutoRuleOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    priority?: SortOrder
    conditions?: SortOrder
    actions?: SortOrder
    timesApplied?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    User?: UserOrderByWithRelationInput
    Workspace?: WorkspaceOrderByWithRelationInput
  }

  export type AutoRuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AutoRuleWhereInput | AutoRuleWhereInput[]
    OR?: AutoRuleWhereInput[]
    NOT?: AutoRuleWhereInput | AutoRuleWhereInput[]
    workspaceId?: StringFilter<"AutoRule"> | string
    userId?: StringFilter<"AutoRule"> | string
    name?: StringFilter<"AutoRule"> | string
    description?: StringNullableFilter<"AutoRule"> | string | null
    isActive?: BoolFilter<"AutoRule"> | boolean
    priority?: IntFilter<"AutoRule"> | number
    conditions?: StringFilter<"AutoRule"> | string
    actions?: StringFilter<"AutoRule"> | string
    timesApplied?: IntFilter<"AutoRule"> | number
    createdAt?: DateTimeFilter<"AutoRule"> | Date | string
    updatedAt?: DateTimeFilter<"AutoRule"> | Date | string
    User?: XOR<UserRelationFilter, UserWhereInput>
    Workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
  }, "id">

  export type AutoRuleOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    priority?: SortOrder
    conditions?: SortOrder
    actions?: SortOrder
    timesApplied?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AutoRuleCountOrderByAggregateInput
    _avg?: AutoRuleAvgOrderByAggregateInput
    _max?: AutoRuleMaxOrderByAggregateInput
    _min?: AutoRuleMinOrderByAggregateInput
    _sum?: AutoRuleSumOrderByAggregateInput
  }

  export type AutoRuleScalarWhereWithAggregatesInput = {
    AND?: AutoRuleScalarWhereWithAggregatesInput | AutoRuleScalarWhereWithAggregatesInput[]
    OR?: AutoRuleScalarWhereWithAggregatesInput[]
    NOT?: AutoRuleScalarWhereWithAggregatesInput | AutoRuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AutoRule"> | string
    workspaceId?: StringWithAggregatesFilter<"AutoRule"> | string
    userId?: StringWithAggregatesFilter<"AutoRule"> | string
    name?: StringWithAggregatesFilter<"AutoRule"> | string
    description?: StringNullableWithAggregatesFilter<"AutoRule"> | string | null
    isActive?: BoolWithAggregatesFilter<"AutoRule"> | boolean
    priority?: IntWithAggregatesFilter<"AutoRule"> | number
    conditions?: StringWithAggregatesFilter<"AutoRule"> | string
    actions?: StringWithAggregatesFilter<"AutoRule"> | string
    timesApplied?: IntWithAggregatesFilter<"AutoRule"> | number
    createdAt?: DateTimeWithAggregatesFilter<"AutoRule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AutoRule"> | Date | string
  }

  export type CashFlowProjectionWhereInput = {
    AND?: CashFlowProjectionWhereInput | CashFlowProjectionWhereInput[]
    OR?: CashFlowProjectionWhereInput[]
    NOT?: CashFlowProjectionWhereInput | CashFlowProjectionWhereInput[]
    id?: StringFilter<"CashFlowProjection"> | string
    workspaceId?: StringFilter<"CashFlowProjection"> | string
    month?: IntFilter<"CashFlowProjection"> | number
    year?: IntFilter<"CashFlowProjection"> | number
    projectedIncome?: FloatFilter<"CashFlowProjection"> | number
    projectedExpense?: FloatFilter<"CashFlowProjection"> | number
    projectedBalance?: FloatFilter<"CashFlowProjection"> | number
    generatedAt?: DateTimeFilter<"CashFlowProjection"> | Date | string
    updatedAt?: DateTimeFilter<"CashFlowProjection"> | Date | string
    Workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
  }

  export type CashFlowProjectionOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    projectedIncome?: SortOrder
    projectedExpense?: SortOrder
    projectedBalance?: SortOrder
    generatedAt?: SortOrder
    updatedAt?: SortOrder
    Workspace?: WorkspaceOrderByWithRelationInput
  }

  export type CashFlowProjectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    workspaceId_month_year?: CashFlowProjectionWorkspaceIdMonthYearCompoundUniqueInput
    AND?: CashFlowProjectionWhereInput | CashFlowProjectionWhereInput[]
    OR?: CashFlowProjectionWhereInput[]
    NOT?: CashFlowProjectionWhereInput | CashFlowProjectionWhereInput[]
    workspaceId?: StringFilter<"CashFlowProjection"> | string
    month?: IntFilter<"CashFlowProjection"> | number
    year?: IntFilter<"CashFlowProjection"> | number
    projectedIncome?: FloatFilter<"CashFlowProjection"> | number
    projectedExpense?: FloatFilter<"CashFlowProjection"> | number
    projectedBalance?: FloatFilter<"CashFlowProjection"> | number
    generatedAt?: DateTimeFilter<"CashFlowProjection"> | Date | string
    updatedAt?: DateTimeFilter<"CashFlowProjection"> | Date | string
    Workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
  }, "id" | "workspaceId_month_year">

  export type CashFlowProjectionOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    projectedIncome?: SortOrder
    projectedExpense?: SortOrder
    projectedBalance?: SortOrder
    generatedAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CashFlowProjectionCountOrderByAggregateInput
    _avg?: CashFlowProjectionAvgOrderByAggregateInput
    _max?: CashFlowProjectionMaxOrderByAggregateInput
    _min?: CashFlowProjectionMinOrderByAggregateInput
    _sum?: CashFlowProjectionSumOrderByAggregateInput
  }

  export type CashFlowProjectionScalarWhereWithAggregatesInput = {
    AND?: CashFlowProjectionScalarWhereWithAggregatesInput | CashFlowProjectionScalarWhereWithAggregatesInput[]
    OR?: CashFlowProjectionScalarWhereWithAggregatesInput[]
    NOT?: CashFlowProjectionScalarWhereWithAggregatesInput | CashFlowProjectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CashFlowProjection"> | string
    workspaceId?: StringWithAggregatesFilter<"CashFlowProjection"> | string
    month?: IntWithAggregatesFilter<"CashFlowProjection"> | number
    year?: IntWithAggregatesFilter<"CashFlowProjection"> | number
    projectedIncome?: FloatWithAggregatesFilter<"CashFlowProjection"> | number
    projectedExpense?: FloatWithAggregatesFilter<"CashFlowProjection"> | number
    projectedBalance?: FloatWithAggregatesFilter<"CashFlowProjection"> | number
    generatedAt?: DateTimeWithAggregatesFilter<"CashFlowProjection"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CashFlowProjection"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    avatarUrl?: string | null
    phone?: string | null
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    workspaces?: WorkspaceMemberCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    gamification?: UserGamificationCreateNestedOneWithoutUserInput
    aiInsights?: AIInsightCreateNestedManyWithoutUserInput
    scenarios?: ScenarioCreateNestedManyWithoutUserInput
    autoRules?: AutoRuleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    avatarUrl?: string | null
    phone?: string | null
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    workspaces?: WorkspaceMemberUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    gamification?: UserGamificationUncheckedCreateNestedOneWithoutUserInput
    aiInsights?: AIInsightUncheckedCreateNestedManyWithoutUserInput
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutUserInput
    autoRules?: AutoRuleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workspaces?: WorkspaceMemberUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    gamification?: UserGamificationUpdateOneWithoutUserNestedInput
    aiInsights?: AIInsightUpdateManyWithoutUserNestedInput
    scenarios?: ScenarioUpdateManyWithoutUserNestedInput
    autoRules?: AutoRuleUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workspaces?: WorkspaceMemberUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    gamification?: UserGamificationUncheckedUpdateOneWithoutUserNestedInput
    aiInsights?: AIInsightUncheckedUpdateManyWithoutUserNestedInput
    scenarios?: ScenarioUncheckedUpdateManyWithoutUserNestedInput
    autoRules?: AutoRuleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    avatarUrl?: string | null
    phone?: string | null
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SessionCreateInput = {
    id?: string
    token: string
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    userId: string
    token: string
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    userId: string
    token: string
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    revokedAt?: Date | string | null
    user: UserCreateNestedOneWithoutRefreshTokensInput
  }

  export type RefreshTokenUncheckedCreateInput = {
    id?: string
    userId: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    revokedAt?: Date | string | null
  }

  export type RefreshTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutRefreshTokensNestedInput
  }

  export type RefreshTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefreshTokenCreateManyInput = {
    id?: string
    userId: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    revokedAt?: Date | string | null
  }

  export type RefreshTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefreshTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PasswordResetCreateInput = {
    id?: string
    token: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPasswordResetsInput
  }

  export type PasswordResetUncheckedCreateInput = {
    id?: string
    userId: string
    token: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PasswordResetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPasswordResetsNestedInput
  }

  export type PasswordResetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetCreateManyInput = {
    id?: string
    userId: string
    token: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PasswordResetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    type: string
    currency?: string
    timezone?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberCreateNestedManyWithoutWorkspaceInput
    accounts?: AccountCreateNestedManyWithoutWorkspaceInput
    categories?: CategoryCreateNestedManyWithoutWorkspaceInput
    goals?: GoalCreateNestedManyWithoutWorkspaceInput
    budgets?: BudgetCreateNestedManyWithoutWorkspaceInput
    imports?: ImportJobCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogCreateNestedManyWithoutWorkspaceInput
    envelopes?: EnvelopeCreateNestedManyWithoutWorkspaceInput
    assets?: AssetCreateNestedManyWithoutWorkspaceInput
    liabilities?: LiabilityCreateNestedManyWithoutWorkspaceInput
    aiInsights?: AIInsightCreateNestedManyWithoutWorkspaceInput
    scenarios?: ScenarioCreateNestedManyWithoutWorkspaceInput
    bankConnections?: BankConnectionCreateNestedManyWithoutWorkspaceInput
    autoRules?: AutoRuleCreateNestedManyWithoutWorkspaceInput
    cashFlowProjections?: CashFlowProjectionCreateNestedManyWithoutWorkspaceInput
    Transaction?: TransactionCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    type: string
    currency?: string
    timezone?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberUncheckedCreateNestedManyWithoutWorkspaceInput
    accounts?: AccountUncheckedCreateNestedManyWithoutWorkspaceInput
    categories?: CategoryUncheckedCreateNestedManyWithoutWorkspaceInput
    goals?: GoalUncheckedCreateNestedManyWithoutWorkspaceInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutWorkspaceInput
    imports?: ImportJobUncheckedCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutWorkspaceInput
    envelopes?: EnvelopeUncheckedCreateNestedManyWithoutWorkspaceInput
    assets?: AssetUncheckedCreateNestedManyWithoutWorkspaceInput
    liabilities?: LiabilityUncheckedCreateNestedManyWithoutWorkspaceInput
    aiInsights?: AIInsightUncheckedCreateNestedManyWithoutWorkspaceInput
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutWorkspaceInput
    bankConnections?: BankConnectionUncheckedCreateNestedManyWithoutWorkspaceInput
    autoRules?: AutoRuleUncheckedCreateNestedManyWithoutWorkspaceInput
    cashFlowProjections?: CashFlowProjectionUncheckedCreateNestedManyWithoutWorkspaceInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUpdateManyWithoutWorkspaceNestedInput
    accounts?: AccountUpdateManyWithoutWorkspaceNestedInput
    categories?: CategoryUpdateManyWithoutWorkspaceNestedInput
    goals?: GoalUpdateManyWithoutWorkspaceNestedInput
    budgets?: BudgetUpdateManyWithoutWorkspaceNestedInput
    imports?: ImportJobUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUpdateManyWithoutWorkspaceNestedInput
    envelopes?: EnvelopeUpdateManyWithoutWorkspaceNestedInput
    assets?: AssetUpdateManyWithoutWorkspaceNestedInput
    liabilities?: LiabilityUpdateManyWithoutWorkspaceNestedInput
    aiInsights?: AIInsightUpdateManyWithoutWorkspaceNestedInput
    scenarios?: ScenarioUpdateManyWithoutWorkspaceNestedInput
    bankConnections?: BankConnectionUpdateManyWithoutWorkspaceNestedInput
    autoRules?: AutoRuleUpdateManyWithoutWorkspaceNestedInput
    cashFlowProjections?: CashFlowProjectionUpdateManyWithoutWorkspaceNestedInput
    Transaction?: TransactionUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUncheckedUpdateManyWithoutWorkspaceNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutWorkspaceNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutWorkspaceNestedInput
    goals?: GoalUncheckedUpdateManyWithoutWorkspaceNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutWorkspaceNestedInput
    imports?: ImportJobUncheckedUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutWorkspaceNestedInput
    envelopes?: EnvelopeUncheckedUpdateManyWithoutWorkspaceNestedInput
    assets?: AssetUncheckedUpdateManyWithoutWorkspaceNestedInput
    liabilities?: LiabilityUncheckedUpdateManyWithoutWorkspaceNestedInput
    aiInsights?: AIInsightUncheckedUpdateManyWithoutWorkspaceNestedInput
    scenarios?: ScenarioUncheckedUpdateManyWithoutWorkspaceNestedInput
    bankConnections?: BankConnectionUncheckedUpdateManyWithoutWorkspaceNestedInput
    autoRules?: AutoRuleUncheckedUpdateManyWithoutWorkspaceNestedInput
    cashFlowProjections?: CashFlowProjectionUncheckedUpdateManyWithoutWorkspaceNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceCreateManyInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    type: string
    currency?: string
    timezone?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkspaceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceMemberCreateInput = {
    id?: string
    role: string
    joinedAt?: Date | string
    invitedBy?: string | null
    workspace: WorkspaceCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutWorkspacesInput
  }

  export type WorkspaceMemberUncheckedCreateInput = {
    id?: string
    workspaceId: string
    userId: string
    role: string
    joinedAt?: Date | string
    invitedBy?: string | null
  }

  export type WorkspaceMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    workspace?: WorkspaceUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutWorkspacesNestedInput
  }

  export type WorkspaceMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkspaceMemberCreateManyInput = {
    id?: string
    workspaceId: string
    userId: string
    role: string
    joinedAt?: Date | string
    invitedBy?: string | null
  }

  export type WorkspaceMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkspaceMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateInput = {
    id?: string
    name: string
    type: string
    description?: string | null
    bankName?: string | null
    bankCode?: string | null
    agency?: string | null
    accountNumber?: string | null
    initialBalance?: number
    currentBalance?: number
    creditLimit?: number | null
    closingDay?: number | null
    dueDay?: number | null
    color?: string
    icon?: string
    isActive?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutAccountsInput
    transactions?: TransactionCreateNestedManyWithoutAccountInput
    fromTransfers?: TransferCreateNestedManyWithoutFromAccountInput
    toTransfers?: TransferCreateNestedManyWithoutToAccountInput
    bankConnections?: BankConnectionCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    workspaceId: string
    name: string
    type: string
    description?: string | null
    bankName?: string | null
    bankCode?: string | null
    agency?: string | null
    accountNumber?: string | null
    initialBalance?: number
    currentBalance?: number
    creditLimit?: number | null
    closingDay?: number | null
    dueDay?: number | null
    color?: string
    icon?: string
    isActive?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutAccountInput
    fromTransfers?: TransferUncheckedCreateNestedManyWithoutFromAccountInput
    toTransfers?: TransferUncheckedCreateNestedManyWithoutToAccountInput
    bankConnections?: BankConnectionUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankCode?: NullableStringFieldUpdateOperationsInput | string | null
    agency?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initialBalance?: FloatFieldUpdateOperationsInput | number
    currentBalance?: FloatFieldUpdateOperationsInput | number
    creditLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    closingDay?: NullableIntFieldUpdateOperationsInput | number | null
    dueDay?: NullableIntFieldUpdateOperationsInput | number | null
    color?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutAccountsNestedInput
    transactions?: TransactionUpdateManyWithoutAccountNestedInput
    fromTransfers?: TransferUpdateManyWithoutFromAccountNestedInput
    toTransfers?: TransferUpdateManyWithoutToAccountNestedInput
    bankConnections?: BankConnectionUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankCode?: NullableStringFieldUpdateOperationsInput | string | null
    agency?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initialBalance?: FloatFieldUpdateOperationsInput | number
    currentBalance?: FloatFieldUpdateOperationsInput | number
    creditLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    closingDay?: NullableIntFieldUpdateOperationsInput | number | null
    dueDay?: NullableIntFieldUpdateOperationsInput | number | null
    color?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutAccountNestedInput
    fromTransfers?: TransferUncheckedUpdateManyWithoutFromAccountNestedInput
    toTransfers?: TransferUncheckedUpdateManyWithoutToAccountNestedInput
    bankConnections?: BankConnectionUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AccountCreateManyInput = {
    id?: string
    workspaceId: string
    name: string
    type: string
    description?: string | null
    bankName?: string | null
    bankCode?: string | null
    agency?: string | null
    accountNumber?: string | null
    initialBalance?: number
    currentBalance?: number
    creditLimit?: number | null
    closingDay?: number | null
    dueDay?: number | null
    color?: string
    icon?: string
    isActive?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankCode?: NullableStringFieldUpdateOperationsInput | string | null
    agency?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initialBalance?: FloatFieldUpdateOperationsInput | number
    currentBalance?: FloatFieldUpdateOperationsInput | number
    creditLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    closingDay?: NullableIntFieldUpdateOperationsInput | number | null
    dueDay?: NullableIntFieldUpdateOperationsInput | number | null
    color?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankCode?: NullableStringFieldUpdateOperationsInput | string | null
    agency?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initialBalance?: FloatFieldUpdateOperationsInput | number
    currentBalance?: FloatFieldUpdateOperationsInput | number
    creditLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    closingDay?: NullableIntFieldUpdateOperationsInput | number | null
    dueDay?: NullableIntFieldUpdateOperationsInput | number | null
    color?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateInput = {
    id?: string
    name: string
    type: string
    color?: string
    icon?: string
    description?: string | null
    keywords: string
    isSystem?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutCategoriesInput
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    children?: CategoryCreateNestedManyWithoutParentInput
    transactions?: TransactionCreateNestedManyWithoutCategoryInput
    budgets?: BudgetCategoryCreateNestedManyWithoutCategoryInput
    envelopes?: EnvelopeCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    workspaceId: string
    parentId?: string | null
    name: string
    type: string
    color?: string
    icon?: string
    description?: string | null
    keywords: string
    isSystem?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCategoryInput
    budgets?: BudgetCategoryUncheckedCreateNestedManyWithoutCategoryInput
    envelopes?: EnvelopeUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: StringFieldUpdateOperationsInput | string
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutCategoriesNestedInput
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    children?: CategoryUpdateManyWithoutParentNestedInput
    transactions?: TransactionUpdateManyWithoutCategoryNestedInput
    budgets?: BudgetCategoryUpdateManyWithoutCategoryNestedInput
    envelopes?: EnvelopeUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: StringFieldUpdateOperationsInput | string
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCategoryNestedInput
    budgets?: BudgetCategoryUncheckedUpdateManyWithoutCategoryNestedInput
    envelopes?: EnvelopeUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    workspaceId: string
    parentId?: string | null
    name: string
    type: string
    color?: string
    icon?: string
    description?: string | null
    keywords: string
    isSystem?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: StringFieldUpdateOperationsInput | string
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: StringFieldUpdateOperationsInput | string
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateInput = {
    id?: string
    creditCardId?: string | null
    type: string
    description: string
    amount: number
    currency?: string
    status: string
    transactionDate: Date | string
    confirmedAt?: Date | string | null
    recurrenceId?: string | null
    notes?: string | null
    tags: string
    attachmentUrl?: string | null
    location?: string | null
    importId?: string | null
    rawData?: string | null
    aiConfidence?: number | null
    aiCategory?: string | null
    aiCategorizedAt?: Date | string | null
    aiModelVersion?: string | null
    autoRuleId?: string | null
    bankConnectionId?: string | null
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutTransactionInput
    account: AccountCreateNestedOneWithoutTransactionsInput
    category?: CategoryCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: string
    workspaceId: string
    accountId: string
    categoryId?: string | null
    creditCardId?: string | null
    type: string
    description: string
    amount: number
    currency?: string
    status: string
    transactionDate: Date | string
    confirmedAt?: Date | string | null
    recurrenceId?: string | null
    notes?: string | null
    tags: string
    attachmentUrl?: string | null
    location?: string | null
    importId?: string | null
    rawData?: string | null
    aiConfidence?: number | null
    aiCategory?: string | null
    aiCategorizedAt?: Date | string | null
    aiModelVersion?: string | null
    autoRuleId?: string | null
    bankConnectionId?: string | null
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditCardId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recurrenceId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: StringFieldUpdateOperationsInput | string
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    importId?: NullableStringFieldUpdateOperationsInput | string | null
    rawData?: NullableStringFieldUpdateOperationsInput | string | null
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiCategory?: NullableStringFieldUpdateOperationsInput | string | null
    aiCategorizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiModelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    autoRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    bankConnectionId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutTransactionNestedInput
    account?: AccountUpdateOneRequiredWithoutTransactionsNestedInput
    category?: CategoryUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    creditCardId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recurrenceId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: StringFieldUpdateOperationsInput | string
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    importId?: NullableStringFieldUpdateOperationsInput | string | null
    rawData?: NullableStringFieldUpdateOperationsInput | string | null
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiCategory?: NullableStringFieldUpdateOperationsInput | string | null
    aiCategorizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiModelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    autoRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    bankConnectionId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyInput = {
    id?: string
    workspaceId: string
    accountId: string
    categoryId?: string | null
    creditCardId?: string | null
    type: string
    description: string
    amount: number
    currency?: string
    status: string
    transactionDate: Date | string
    confirmedAt?: Date | string | null
    recurrenceId?: string | null
    notes?: string | null
    tags: string
    attachmentUrl?: string | null
    location?: string | null
    importId?: string | null
    rawData?: string | null
    aiConfidence?: number | null
    aiCategory?: string | null
    aiCategorizedAt?: Date | string | null
    aiModelVersion?: string | null
    autoRuleId?: string | null
    bankConnectionId?: string | null
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditCardId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recurrenceId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: StringFieldUpdateOperationsInput | string
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    importId?: NullableStringFieldUpdateOperationsInput | string | null
    rawData?: NullableStringFieldUpdateOperationsInput | string | null
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiCategory?: NullableStringFieldUpdateOperationsInput | string | null
    aiCategorizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiModelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    autoRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    bankConnectionId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    creditCardId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recurrenceId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: StringFieldUpdateOperationsInput | string
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    importId?: NullableStringFieldUpdateOperationsInput | string | null
    rawData?: NullableStringFieldUpdateOperationsInput | string | null
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiCategory?: NullableStringFieldUpdateOperationsInput | string | null
    aiCategorizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiModelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    autoRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    bankConnectionId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurrenceCreateInput = {
    id?: string
    workspaceId: string
    accountId: string
    categoryId?: string | null
    type: string
    description: string
    amount: number
    frequency: string
    startDate: Date | string
    endDate?: Date | string | null
    nextOccurrence: Date | string
    isActive?: boolean
    autoConfirm?: boolean
    notifyBefore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecurrenceUncheckedCreateInput = {
    id?: string
    workspaceId: string
    accountId: string
    categoryId?: string | null
    type: string
    description: string
    amount: number
    frequency: string
    startDate: Date | string
    endDate?: Date | string | null
    nextOccurrence: Date | string
    isActive?: boolean
    autoConfirm?: boolean
    notifyBefore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecurrenceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    frequency?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextOccurrence?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    autoConfirm?: BoolFieldUpdateOperationsInput | boolean
    notifyBefore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurrenceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    frequency?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextOccurrence?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    autoConfirm?: BoolFieldUpdateOperationsInput | boolean
    notifyBefore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurrenceCreateManyInput = {
    id?: string
    workspaceId: string
    accountId: string
    categoryId?: string | null
    type: string
    description: string
    amount: number
    frequency: string
    startDate: Date | string
    endDate?: Date | string | null
    nextOccurrence: Date | string
    isActive?: boolean
    autoConfirm?: boolean
    notifyBefore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecurrenceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    frequency?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextOccurrence?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    autoConfirm?: BoolFieldUpdateOperationsInput | boolean
    notifyBefore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurrenceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    frequency?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextOccurrence?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    autoConfirm?: BoolFieldUpdateOperationsInput | boolean
    notifyBefore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferCreateInput = {
    id?: string
    workspaceId: string
    description: string
    amount: number
    fee?: number | null
    transferDate: Date | string
    createdAt?: Date | string
    fromAccount: AccountCreateNestedOneWithoutFromTransfersInput
    toAccount: AccountCreateNestedOneWithoutToTransfersInput
  }

  export type TransferUncheckedCreateInput = {
    id?: string
    workspaceId: string
    fromAccountId: string
    toAccountId: string
    description: string
    amount: number
    fee?: number | null
    transferDate: Date | string
    createdAt?: Date | string
  }

  export type TransferUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromAccount?: AccountUpdateOneRequiredWithoutFromTransfersNestedInput
    toAccount?: AccountUpdateOneRequiredWithoutToTransfersNestedInput
  }

  export type TransferUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    fromAccountId?: StringFieldUpdateOperationsInput | string
    toAccountId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferCreateManyInput = {
    id?: string
    workspaceId: string
    fromAccountId: string
    toAccountId: string
    description: string
    amount: number
    fee?: number | null
    transferDate: Date | string
    createdAt?: Date | string
  }

  export type TransferUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    fromAccountId?: StringFieldUpdateOperationsInput | string
    toAccountId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetCreateInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    totalBudgeted: number
    totalSpent?: number
    isActive?: boolean
    alertThreshold?: number
    alertSent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: BudgetCategoryCreateNestedManyWithoutBudgetInput
    Workspace: WorkspaceCreateNestedOneWithoutBudgetsInput
  }

  export type BudgetUncheckedCreateInput = {
    id?: string
    workspaceId: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    totalBudgeted: number
    totalSpent?: number
    isActive?: boolean
    alertThreshold?: number
    alertSent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: BudgetCategoryUncheckedCreateNestedManyWithoutBudgetInput
  }

  export type BudgetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalBudgeted?: FloatFieldUpdateOperationsInput | number
    totalSpent?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    alertThreshold?: IntFieldUpdateOperationsInput | number
    alertSent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: BudgetCategoryUpdateManyWithoutBudgetNestedInput
    Workspace?: WorkspaceUpdateOneRequiredWithoutBudgetsNestedInput
  }

  export type BudgetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalBudgeted?: FloatFieldUpdateOperationsInput | number
    totalSpent?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    alertThreshold?: IntFieldUpdateOperationsInput | number
    alertSent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: BudgetCategoryUncheckedUpdateManyWithoutBudgetNestedInput
  }

  export type BudgetCreateManyInput = {
    id?: string
    workspaceId: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    totalBudgeted: number
    totalSpent?: number
    isActive?: boolean
    alertThreshold?: number
    alertSent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BudgetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalBudgeted?: FloatFieldUpdateOperationsInput | number
    totalSpent?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    alertThreshold?: IntFieldUpdateOperationsInput | number
    alertSent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalBudgeted?: FloatFieldUpdateOperationsInput | number
    totalSpent?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    alertThreshold?: IntFieldUpdateOperationsInput | number
    alertSent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetCategoryCreateInput = {
    id?: string
    budgeted: number
    spent?: number
    budget: BudgetCreateNestedOneWithoutCategoriesInput
    category: CategoryCreateNestedOneWithoutBudgetsInput
  }

  export type BudgetCategoryUncheckedCreateInput = {
    id?: string
    budgetId: string
    categoryId: string
    budgeted: number
    spent?: number
  }

  export type BudgetCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgeted?: FloatFieldUpdateOperationsInput | number
    spent?: FloatFieldUpdateOperationsInput | number
    budget?: BudgetUpdateOneRequiredWithoutCategoriesNestedInput
    category?: CategoryUpdateOneRequiredWithoutBudgetsNestedInput
  }

  export type BudgetCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    budgeted?: FloatFieldUpdateOperationsInput | number
    spent?: FloatFieldUpdateOperationsInput | number
  }

  export type BudgetCategoryCreateManyInput = {
    id?: string
    budgetId: string
    categoryId: string
    budgeted: number
    spent?: number
  }

  export type BudgetCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgeted?: FloatFieldUpdateOperationsInput | number
    spent?: FloatFieldUpdateOperationsInput | number
  }

  export type BudgetCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    budgeted?: FloatFieldUpdateOperationsInput | number
    spent?: FloatFieldUpdateOperationsInput | number
  }

  export type GoalCreateInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    targetAmount: number
    currentAmount?: number
    startDate: Date | string
    targetDate?: Date | string | null
    completedAt?: Date | string | null
    status: string
    icon?: string
    color?: string
    autoAllocate?: boolean
    allocationPercentage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contributions?: GoalContributionCreateNestedManyWithoutGoalInput
    Workspace: WorkspaceCreateNestedOneWithoutGoalsInput
  }

  export type GoalUncheckedCreateInput = {
    id?: string
    workspaceId: string
    name: string
    description?: string | null
    type: string
    targetAmount: number
    currentAmount?: number
    startDate: Date | string
    targetDate?: Date | string | null
    completedAt?: Date | string | null
    status: string
    icon?: string
    color?: string
    autoAllocate?: boolean
    allocationPercentage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contributions?: GoalContributionUncheckedCreateNestedManyWithoutGoalInput
  }

  export type GoalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    targetAmount?: FloatFieldUpdateOperationsInput | number
    currentAmount?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    autoAllocate?: BoolFieldUpdateOperationsInput | boolean
    allocationPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contributions?: GoalContributionUpdateManyWithoutGoalNestedInput
    Workspace?: WorkspaceUpdateOneRequiredWithoutGoalsNestedInput
  }

  export type GoalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    targetAmount?: FloatFieldUpdateOperationsInput | number
    currentAmount?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    autoAllocate?: BoolFieldUpdateOperationsInput | boolean
    allocationPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contributions?: GoalContributionUncheckedUpdateManyWithoutGoalNestedInput
  }

  export type GoalCreateManyInput = {
    id?: string
    workspaceId: string
    name: string
    description?: string | null
    type: string
    targetAmount: number
    currentAmount?: number
    startDate: Date | string
    targetDate?: Date | string | null
    completedAt?: Date | string | null
    status: string
    icon?: string
    color?: string
    autoAllocate?: boolean
    allocationPercentage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GoalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    targetAmount?: FloatFieldUpdateOperationsInput | number
    currentAmount?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    autoAllocate?: BoolFieldUpdateOperationsInput | boolean
    allocationPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    targetAmount?: FloatFieldUpdateOperationsInput | number
    currentAmount?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    autoAllocate?: BoolFieldUpdateOperationsInput | boolean
    allocationPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoalContributionCreateInput = {
    id?: string
    amount: number
    description?: string | null
    contributedAt?: Date | string
    goal: GoalCreateNestedOneWithoutContributionsInput
  }

  export type GoalContributionUncheckedCreateInput = {
    id?: string
    goalId: string
    amount: number
    description?: string | null
    contributedAt?: Date | string
  }

  export type GoalContributionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contributedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goal?: GoalUpdateOneRequiredWithoutContributionsNestedInput
  }

  export type GoalContributionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contributedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoalContributionCreateManyInput = {
    id?: string
    goalId: string
    amount: number
    description?: string | null
    contributedAt?: Date | string
  }

  export type GoalContributionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contributedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoalContributionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contributedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImportJobCreateInput = {
    id?: string
    accountId: string
    format: string
    fileName: string
    fileSize: number
    fileUrl?: string | null
    status: string
    progress?: number
    totalRows?: number
    processedRows?: number
    importedRows?: number
    errorLog?: string | null
    mappingConfig?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    Workspace: WorkspaceCreateNestedOneWithoutImportsInput
  }

  export type ImportJobUncheckedCreateInput = {
    id?: string
    workspaceId: string
    accountId: string
    format: string
    fileName: string
    fileSize: number
    fileUrl?: string | null
    status: string
    progress?: number
    totalRows?: number
    processedRows?: number
    importedRows?: number
    errorLog?: string | null
    mappingConfig?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ImportJobUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    totalRows?: IntFieldUpdateOperationsInput | number
    processedRows?: IntFieldUpdateOperationsInput | number
    importedRows?: IntFieldUpdateOperationsInput | number
    errorLog?: NullableStringFieldUpdateOperationsInput | string | null
    mappingConfig?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Workspace?: WorkspaceUpdateOneRequiredWithoutImportsNestedInput
  }

  export type ImportJobUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    totalRows?: IntFieldUpdateOperationsInput | number
    processedRows?: IntFieldUpdateOperationsInput | number
    importedRows?: IntFieldUpdateOperationsInput | number
    errorLog?: NullableStringFieldUpdateOperationsInput | string | null
    mappingConfig?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImportJobCreateManyInput = {
    id?: string
    workspaceId: string
    accountId: string
    format: string
    fileName: string
    fileSize: number
    fileUrl?: string | null
    status: string
    progress?: number
    totalRows?: number
    processedRows?: number
    importedRows?: number
    errorLog?: string | null
    mappingConfig?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ImportJobUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    totalRows?: IntFieldUpdateOperationsInput | number
    processedRows?: IntFieldUpdateOperationsInput | number
    importedRows?: IntFieldUpdateOperationsInput | number
    errorLog?: NullableStringFieldUpdateOperationsInput | string | null
    mappingConfig?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImportJobUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    totalRows?: IntFieldUpdateOperationsInput | number
    processedRows?: IntFieldUpdateOperationsInput | number
    importedRows?: IntFieldUpdateOperationsInput | number
    errorLog?: NullableStringFieldUpdateOperationsInput | string | null
    mappingConfig?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    workspaceId?: string | null
    type: string
    title: string
    message: string
    data?: string | null
    readAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    workspaceId?: string | null
    type: string
    title: string
    message: string
    data?: string | null
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    workspaceId?: string | null
    type: string
    title: string
    message: string
    data?: string | null
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    entityType: string
    entityId?: string | null
    oldData?: string | null
    newData?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutAuditLogsInput
    Workspace?: WorkspaceCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId?: string | null
    workspaceId?: string | null
    action: string
    entityType: string
    entityId?: string | null
    oldData?: string | null
    newData?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldData?: NullableStringFieldUpdateOperationsInput | string | null
    newData?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAuditLogsNestedInput
    Workspace?: WorkspaceUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldData?: NullableStringFieldUpdateOperationsInput | string | null
    newData?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId?: string | null
    workspaceId?: string | null
    action: string
    entityType: string
    entityId?: string | null
    oldData?: string | null
    newData?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldData?: NullableStringFieldUpdateOperationsInput | string | null
    newData?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldData?: NullableStringFieldUpdateOperationsInput | string | null
    newData?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserGamificationCreateInput = {
    id?: string
    tier: string
    totalXP?: number
    currentLevel?: number
    xpToNextLevel?: number
    loginStreak?: number
    longestLoginStreak?: number
    transactionStreak?: number
    transactionsLogged?: number
    budgetsMet?: number
    goalsAchieved?: number
    lastLoginDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutGamificationInput
    achievements?: UserAchievementCreateNestedManyWithoutUserGamificationInput
  }

  export type UserGamificationUncheckedCreateInput = {
    id?: string
    userId: string
    tier: string
    totalXP?: number
    currentLevel?: number
    xpToNextLevel?: number
    loginStreak?: number
    longestLoginStreak?: number
    transactionStreak?: number
    transactionsLogged?: number
    budgetsMet?: number
    goalsAchieved?: number
    lastLoginDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserGamificationInput
  }

  export type UserGamificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    totalXP?: IntFieldUpdateOperationsInput | number
    currentLevel?: IntFieldUpdateOperationsInput | number
    xpToNextLevel?: IntFieldUpdateOperationsInput | number
    loginStreak?: IntFieldUpdateOperationsInput | number
    longestLoginStreak?: IntFieldUpdateOperationsInput | number
    transactionStreak?: IntFieldUpdateOperationsInput | number
    transactionsLogged?: IntFieldUpdateOperationsInput | number
    budgetsMet?: IntFieldUpdateOperationsInput | number
    goalsAchieved?: IntFieldUpdateOperationsInput | number
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutGamificationNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserGamificationNestedInput
  }

  export type UserGamificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    totalXP?: IntFieldUpdateOperationsInput | number
    currentLevel?: IntFieldUpdateOperationsInput | number
    xpToNextLevel?: IntFieldUpdateOperationsInput | number
    loginStreak?: IntFieldUpdateOperationsInput | number
    longestLoginStreak?: IntFieldUpdateOperationsInput | number
    transactionStreak?: IntFieldUpdateOperationsInput | number
    transactionsLogged?: IntFieldUpdateOperationsInput | number
    budgetsMet?: IntFieldUpdateOperationsInput | number
    goalsAchieved?: IntFieldUpdateOperationsInput | number
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserGamificationNestedInput
  }

  export type UserGamificationCreateManyInput = {
    id?: string
    userId: string
    tier: string
    totalXP?: number
    currentLevel?: number
    xpToNextLevel?: number
    loginStreak?: number
    longestLoginStreak?: number
    transactionStreak?: number
    transactionsLogged?: number
    budgetsMet?: number
    goalsAchieved?: number
    lastLoginDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserGamificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    totalXP?: IntFieldUpdateOperationsInput | number
    currentLevel?: IntFieldUpdateOperationsInput | number
    xpToNextLevel?: IntFieldUpdateOperationsInput | number
    loginStreak?: IntFieldUpdateOperationsInput | number
    longestLoginStreak?: IntFieldUpdateOperationsInput | number
    transactionStreak?: IntFieldUpdateOperationsInput | number
    transactionsLogged?: IntFieldUpdateOperationsInput | number
    budgetsMet?: IntFieldUpdateOperationsInput | number
    goalsAchieved?: IntFieldUpdateOperationsInput | number
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserGamificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    totalXP?: IntFieldUpdateOperationsInput | number
    currentLevel?: IntFieldUpdateOperationsInput | number
    xpToNextLevel?: IntFieldUpdateOperationsInput | number
    loginStreak?: IntFieldUpdateOperationsInput | number
    longestLoginStreak?: IntFieldUpdateOperationsInput | number
    transactionStreak?: IntFieldUpdateOperationsInput | number
    transactionsLogged?: IntFieldUpdateOperationsInput | number
    budgetsMet?: IntFieldUpdateOperationsInput | number
    goalsAchieved?: IntFieldUpdateOperationsInput | number
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementCreateInput = {
    id?: string
    type: string
    name: string
    description: string
    icon: string
    color: string
    xpReward: number
    requirementType: string
    requirementValue: number
    createdAt?: Date | string
  }

  export type AchievementUncheckedCreateInput = {
    id?: string
    type: string
    name: string
    description: string
    icon: string
    color: string
    xpReward: number
    requirementType: string
    requirementValue: number
    createdAt?: Date | string
  }

  export type AchievementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    xpReward?: IntFieldUpdateOperationsInput | number
    requirementType?: StringFieldUpdateOperationsInput | string
    requirementValue?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    xpReward?: IntFieldUpdateOperationsInput | number
    requirementType?: StringFieldUpdateOperationsInput | string
    requirementValue?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementCreateManyInput = {
    id?: string
    type: string
    name: string
    description: string
    icon: string
    color: string
    xpReward: number
    requirementType: string
    requirementValue: number
    createdAt?: Date | string
  }

  export type AchievementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    xpReward?: IntFieldUpdateOperationsInput | number
    requirementType?: StringFieldUpdateOperationsInput | string
    requirementValue?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    xpReward?: IntFieldUpdateOperationsInput | number
    requirementType?: StringFieldUpdateOperationsInput | string
    requirementValue?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementCreateInput = {
    id?: string
    achievementId: string
    unlockedAt?: Date | string
    UserGamification: UserGamificationCreateNestedOneWithoutAchievementsInput
  }

  export type UserAchievementUncheckedCreateInput = {
    id?: string
    userGamificationId: string
    achievementId: string
    unlockedAt?: Date | string
  }

  export type UserAchievementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserGamification?: UserGamificationUpdateOneRequiredWithoutAchievementsNestedInput
  }

  export type UserAchievementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userGamificationId?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementCreateManyInput = {
    id?: string
    userGamificationId: string
    achievementId: string
    unlockedAt?: Date | string
  }

  export type UserAchievementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userGamificationId?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnvelopeCreateInput = {
    id?: string
    name: string
    description?: string | null
    color?: string
    budgetedAmount: number
    availableAmount?: number
    spentAmount?: number
    month: number
    year: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Workspace: WorkspaceCreateNestedOneWithoutEnvelopesInput
    Category?: CategoryCreateNestedOneWithoutEnvelopesInput
  }

  export type EnvelopeUncheckedCreateInput = {
    id?: string
    workspaceId: string
    categoryId?: string | null
    name: string
    description?: string | null
    color?: string
    budgetedAmount: number
    availableAmount?: number
    spentAmount?: number
    month: number
    year: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EnvelopeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    budgetedAmount?: FloatFieldUpdateOperationsInput | number
    availableAmount?: FloatFieldUpdateOperationsInput | number
    spentAmount?: FloatFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Workspace?: WorkspaceUpdateOneRequiredWithoutEnvelopesNestedInput
    Category?: CategoryUpdateOneWithoutEnvelopesNestedInput
  }

  export type EnvelopeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    budgetedAmount?: FloatFieldUpdateOperationsInput | number
    availableAmount?: FloatFieldUpdateOperationsInput | number
    spentAmount?: FloatFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnvelopeCreateManyInput = {
    id?: string
    workspaceId: string
    categoryId?: string | null
    name: string
    description?: string | null
    color?: string
    budgetedAmount: number
    availableAmount?: number
    spentAmount?: number
    month: number
    year: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EnvelopeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    budgetedAmount?: FloatFieldUpdateOperationsInput | number
    availableAmount?: FloatFieldUpdateOperationsInput | number
    spentAmount?: FloatFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnvelopeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    budgetedAmount?: FloatFieldUpdateOperationsInput | number
    availableAmount?: FloatFieldUpdateOperationsInput | number
    spentAmount?: FloatFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetCreateInput = {
    id?: string
    name: string
    type: string
    description?: string | null
    currentValue: number
    purchaseValue?: number | null
    purchaseDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Workspace: WorkspaceCreateNestedOneWithoutAssetsInput
  }

  export type AssetUncheckedCreateInput = {
    id?: string
    workspaceId: string
    name: string
    type: string
    description?: string | null
    currentValue: number
    purchaseValue?: number | null
    purchaseDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currentValue?: FloatFieldUpdateOperationsInput | number
    purchaseValue?: NullableFloatFieldUpdateOperationsInput | number | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Workspace?: WorkspaceUpdateOneRequiredWithoutAssetsNestedInput
  }

  export type AssetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currentValue?: FloatFieldUpdateOperationsInput | number
    purchaseValue?: NullableFloatFieldUpdateOperationsInput | number | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetCreateManyInput = {
    id?: string
    workspaceId: string
    name: string
    type: string
    description?: string | null
    currentValue: number
    purchaseValue?: number | null
    purchaseDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currentValue?: FloatFieldUpdateOperationsInput | number
    purchaseValue?: NullableFloatFieldUpdateOperationsInput | number | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currentValue?: FloatFieldUpdateOperationsInput | number
    purchaseValue?: NullableFloatFieldUpdateOperationsInput | number | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LiabilityCreateInput = {
    id?: string
    name: string
    type: string
    description?: string | null
    currentBalance: number
    originalAmount: number
    interestRate?: number | null
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Workspace: WorkspaceCreateNestedOneWithoutLiabilitiesInput
  }

  export type LiabilityUncheckedCreateInput = {
    id?: string
    workspaceId: string
    name: string
    type: string
    description?: string | null
    currentBalance: number
    originalAmount: number
    interestRate?: number | null
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LiabilityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currentBalance?: FloatFieldUpdateOperationsInput | number
    originalAmount?: FloatFieldUpdateOperationsInput | number
    interestRate?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Workspace?: WorkspaceUpdateOneRequiredWithoutLiabilitiesNestedInput
  }

  export type LiabilityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currentBalance?: FloatFieldUpdateOperationsInput | number
    originalAmount?: FloatFieldUpdateOperationsInput | number
    interestRate?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LiabilityCreateManyInput = {
    id?: string
    workspaceId: string
    name: string
    type: string
    description?: string | null
    currentBalance: number
    originalAmount: number
    interestRate?: number | null
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LiabilityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currentBalance?: FloatFieldUpdateOperationsInput | number
    originalAmount?: FloatFieldUpdateOperationsInput | number
    interestRate?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LiabilityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currentBalance?: FloatFieldUpdateOperationsInput | number
    originalAmount?: FloatFieldUpdateOperationsInput | number
    interestRate?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIInsightCreateInput = {
    id?: string
    type: string
    title: string
    description: string
    severity: string
    suggestedAction?: string | null
    actionTaken?: boolean
    confidenceScore?: number | null
    dismissedAt?: Date | string | null
    createdAt?: Date | string
    User: UserCreateNestedOneWithoutAiInsightsInput
    Workspace: WorkspaceCreateNestedOneWithoutAiInsightsInput
  }

  export type AIInsightUncheckedCreateInput = {
    id?: string
    workspaceId: string
    userId: string
    type: string
    title: string
    description: string
    severity: string
    suggestedAction?: string | null
    actionTaken?: boolean
    confidenceScore?: number | null
    dismissedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AIInsightUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    suggestedAction?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: BoolFieldUpdateOperationsInput | boolean
    confidenceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutAiInsightsNestedInput
    Workspace?: WorkspaceUpdateOneRequiredWithoutAiInsightsNestedInput
  }

  export type AIInsightUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    suggestedAction?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: BoolFieldUpdateOperationsInput | boolean
    confidenceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIInsightCreateManyInput = {
    id?: string
    workspaceId: string
    userId: string
    type: string
    title: string
    description: string
    severity: string
    suggestedAction?: string | null
    actionTaken?: boolean
    confidenceScore?: number | null
    dismissedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AIInsightUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    suggestedAction?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: BoolFieldUpdateOperationsInput | boolean
    confidenceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIInsightUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    suggestedAction?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: BoolFieldUpdateOperationsInput | boolean
    confidenceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScenarioCreateInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    parameters: string
    isFavorite?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    User: UserCreateNestedOneWithoutScenariosInput
    Workspace: WorkspaceCreateNestedOneWithoutScenariosInput
  }

  export type ScenarioUncheckedCreateInput = {
    id?: string
    workspaceId: string
    userId: string
    name: string
    description?: string | null
    type: string
    parameters: string
    isFavorite?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScenarioUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    parameters?: StringFieldUpdateOperationsInput | string
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutScenariosNestedInput
    Workspace?: WorkspaceUpdateOneRequiredWithoutScenariosNestedInput
  }

  export type ScenarioUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    parameters?: StringFieldUpdateOperationsInput | string
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScenarioCreateManyInput = {
    id?: string
    workspaceId: string
    userId: string
    name: string
    description?: string | null
    type: string
    parameters: string
    isFavorite?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScenarioUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    parameters?: StringFieldUpdateOperationsInput | string
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScenarioUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    parameters?: StringFieldUpdateOperationsInput | string
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankConnectionCreateInput = {
    id?: string
    bankName: string
    bankCode: string
    accessToken: string
    status: string
    lastSyncAt?: Date | string | null
    lastSyncError?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Workspace: WorkspaceCreateNestedOneWithoutBankConnectionsInput
    Account: AccountCreateNestedOneWithoutBankConnectionsInput
  }

  export type BankConnectionUncheckedCreateInput = {
    id?: string
    workspaceId: string
    accountId: string
    bankName: string
    bankCode: string
    accessToken: string
    status: string
    lastSyncAt?: Date | string | null
    lastSyncError?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankConnectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    bankCode?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSyncError?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Workspace?: WorkspaceUpdateOneRequiredWithoutBankConnectionsNestedInput
    Account?: AccountUpdateOneRequiredWithoutBankConnectionsNestedInput
  }

  export type BankConnectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    bankCode?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSyncError?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankConnectionCreateManyInput = {
    id?: string
    workspaceId: string
    accountId: string
    bankName: string
    bankCode: string
    accessToken: string
    status: string
    lastSyncAt?: Date | string | null
    lastSyncError?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankConnectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    bankCode?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSyncError?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankConnectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    bankCode?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSyncError?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutoRuleCreateInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    priority?: number
    conditions: string
    actions: string
    timesApplied?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    User: UserCreateNestedOneWithoutAutoRulesInput
    Workspace: WorkspaceCreateNestedOneWithoutAutoRulesInput
  }

  export type AutoRuleUncheckedCreateInput = {
    id?: string
    workspaceId: string
    userId: string
    name: string
    description?: string | null
    isActive?: boolean
    priority?: number
    conditions: string
    actions: string
    timesApplied?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AutoRuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    conditions?: StringFieldUpdateOperationsInput | string
    actions?: StringFieldUpdateOperationsInput | string
    timesApplied?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutAutoRulesNestedInput
    Workspace?: WorkspaceUpdateOneRequiredWithoutAutoRulesNestedInput
  }

  export type AutoRuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    conditions?: StringFieldUpdateOperationsInput | string
    actions?: StringFieldUpdateOperationsInput | string
    timesApplied?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutoRuleCreateManyInput = {
    id?: string
    workspaceId: string
    userId: string
    name: string
    description?: string | null
    isActive?: boolean
    priority?: number
    conditions: string
    actions: string
    timesApplied?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AutoRuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    conditions?: StringFieldUpdateOperationsInput | string
    actions?: StringFieldUpdateOperationsInput | string
    timesApplied?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutoRuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    conditions?: StringFieldUpdateOperationsInput | string
    actions?: StringFieldUpdateOperationsInput | string
    timesApplied?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashFlowProjectionCreateInput = {
    id?: string
    month: number
    year: number
    projectedIncome: number
    projectedExpense: number
    projectedBalance: number
    generatedAt?: Date | string
    updatedAt?: Date | string
    Workspace: WorkspaceCreateNestedOneWithoutCashFlowProjectionsInput
  }

  export type CashFlowProjectionUncheckedCreateInput = {
    id?: string
    workspaceId: string
    month: number
    year: number
    projectedIncome: number
    projectedExpense: number
    projectedBalance: number
    generatedAt?: Date | string
    updatedAt?: Date | string
  }

  export type CashFlowProjectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    projectedIncome?: FloatFieldUpdateOperationsInput | number
    projectedExpense?: FloatFieldUpdateOperationsInput | number
    projectedBalance?: FloatFieldUpdateOperationsInput | number
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Workspace?: WorkspaceUpdateOneRequiredWithoutCashFlowProjectionsNestedInput
  }

  export type CashFlowProjectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    projectedIncome?: FloatFieldUpdateOperationsInput | number
    projectedExpense?: FloatFieldUpdateOperationsInput | number
    projectedBalance?: FloatFieldUpdateOperationsInput | number
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashFlowProjectionCreateManyInput = {
    id?: string
    workspaceId: string
    month: number
    year: number
    projectedIncome: number
    projectedExpense: number
    projectedBalance: number
    generatedAt?: Date | string
    updatedAt?: Date | string
  }

  export type CashFlowProjectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    projectedIncome?: FloatFieldUpdateOperationsInput | number
    projectedExpense?: FloatFieldUpdateOperationsInput | number
    projectedBalance?: FloatFieldUpdateOperationsInput | number
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashFlowProjectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    projectedIncome?: FloatFieldUpdateOperationsInput | number
    projectedExpense?: FloatFieldUpdateOperationsInput | number
    projectedBalance?: FloatFieldUpdateOperationsInput | number
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type WorkspaceMemberListRelationFilter = {
    every?: WorkspaceMemberWhereInput
    some?: WorkspaceMemberWhereInput
    none?: WorkspaceMemberWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type PasswordResetListRelationFilter = {
    every?: PasswordResetWhereInput
    some?: PasswordResetWhereInput
    none?: PasswordResetWhereInput
  }

  export type RefreshTokenListRelationFilter = {
    every?: RefreshTokenWhereInput
    some?: RefreshTokenWhereInput
    none?: RefreshTokenWhereInput
  }

  export type UserGamificationNullableRelationFilter = {
    is?: UserGamificationWhereInput | null
    isNot?: UserGamificationWhereInput | null
  }

  export type AIInsightListRelationFilter = {
    every?: AIInsightWhereInput
    some?: AIInsightWhereInput
    none?: AIInsightWhereInput
  }

  export type ScenarioListRelationFilter = {
    every?: ScenarioWhereInput
    some?: ScenarioWhereInput
    none?: ScenarioWhereInput
  }

  export type AutoRuleListRelationFilter = {
    every?: AutoRuleWhereInput
    some?: AutoRuleWhereInput
    none?: AutoRuleWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type WorkspaceMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PasswordResetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RefreshTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AIInsightOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScenarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AutoRuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    avatarUrl?: SortOrder
    phone?: SortOrder
    emailVerified?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    avatarUrl?: SortOrder
    phone?: SortOrder
    emailVerified?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    avatarUrl?: SortOrder
    phone?: SortOrder
    emailVerified?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type RefreshTokenCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    revokedAt?: SortOrder
  }

  export type RefreshTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    revokedAt?: SortOrder
  }

  export type RefreshTokenMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    revokedAt?: SortOrder
  }

  export type PasswordResetCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type CategoryListRelationFilter = {
    every?: CategoryWhereInput
    some?: CategoryWhereInput
    none?: CategoryWhereInput
  }

  export type GoalListRelationFilter = {
    every?: GoalWhereInput
    some?: GoalWhereInput
    none?: GoalWhereInput
  }

  export type BudgetListRelationFilter = {
    every?: BudgetWhereInput
    some?: BudgetWhereInput
    none?: BudgetWhereInput
  }

  export type ImportJobListRelationFilter = {
    every?: ImportJobWhereInput
    some?: ImportJobWhereInput
    none?: ImportJobWhereInput
  }

  export type EnvelopeListRelationFilter = {
    every?: EnvelopeWhereInput
    some?: EnvelopeWhereInput
    none?: EnvelopeWhereInput
  }

  export type AssetListRelationFilter = {
    every?: AssetWhereInput
    some?: AssetWhereInput
    none?: AssetWhereInput
  }

  export type LiabilityListRelationFilter = {
    every?: LiabilityWhereInput
    some?: LiabilityWhereInput
    none?: LiabilityWhereInput
  }

  export type BankConnectionListRelationFilter = {
    every?: BankConnectionWhereInput
    some?: BankConnectionWhereInput
    none?: BankConnectionWhereInput
  }

  export type CashFlowProjectionListRelationFilter = {
    every?: CashFlowProjectionWhereInput
    some?: CashFlowProjectionWhereInput
    none?: CashFlowProjectionWhereInput
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GoalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BudgetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ImportJobOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EnvelopeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LiabilityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BankConnectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CashFlowProjectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkspaceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    type?: SortOrder
    currency?: SortOrder
    timezone?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkspaceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    type?: SortOrder
    currency?: SortOrder
    timezone?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkspaceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    type?: SortOrder
    currency?: SortOrder
    timezone?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkspaceRelationFilter = {
    is?: WorkspaceWhereInput
    isNot?: WorkspaceWhereInput
  }

  export type WorkspaceMemberWorkspaceIdUserIdCompoundUniqueInput = {
    workspaceId: string
    userId: string
  }

  export type WorkspaceMemberCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    invitedBy?: SortOrder
  }

  export type WorkspaceMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    invitedBy?: SortOrder
  }

  export type WorkspaceMemberMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    invitedBy?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type TransferListRelationFilter = {
    every?: TransferWhereInput
    some?: TransferWhereInput
    none?: TransferWhereInput
  }

  export type TransferOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    bankName?: SortOrder
    bankCode?: SortOrder
    agency?: SortOrder
    accountNumber?: SortOrder
    initialBalance?: SortOrder
    currentBalance?: SortOrder
    creditLimit?: SortOrder
    closingDay?: SortOrder
    dueDay?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    isActive?: SortOrder
    archivedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    initialBalance?: SortOrder
    currentBalance?: SortOrder
    creditLimit?: SortOrder
    closingDay?: SortOrder
    dueDay?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    bankName?: SortOrder
    bankCode?: SortOrder
    agency?: SortOrder
    accountNumber?: SortOrder
    initialBalance?: SortOrder
    currentBalance?: SortOrder
    creditLimit?: SortOrder
    closingDay?: SortOrder
    dueDay?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    isActive?: SortOrder
    archivedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    bankName?: SortOrder
    bankCode?: SortOrder
    agency?: SortOrder
    accountNumber?: SortOrder
    initialBalance?: SortOrder
    currentBalance?: SortOrder
    creditLimit?: SortOrder
    closingDay?: SortOrder
    dueDay?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    isActive?: SortOrder
    archivedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    initialBalance?: SortOrder
    currentBalance?: SortOrder
    creditLimit?: SortOrder
    closingDay?: SortOrder
    dueDay?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type CategoryNullableRelationFilter = {
    is?: CategoryWhereInput | null
    isNot?: CategoryWhereInput | null
  }

  export type BudgetCategoryListRelationFilter = {
    every?: BudgetCategoryWhereInput
    some?: BudgetCategoryWhereInput
    none?: BudgetCategoryWhereInput
  }

  export type BudgetCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    parentId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    description?: SortOrder
    keywords?: SortOrder
    isSystem?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    parentId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    description?: SortOrder
    keywords?: SortOrder
    isSystem?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    parentId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    description?: SortOrder
    keywords?: SortOrder
    isSystem?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountRelationFilter = {
    is?: AccountWhereInput
    isNot?: AccountWhereInput
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    accountId?: SortOrder
    categoryId?: SortOrder
    creditCardId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    transactionDate?: SortOrder
    confirmedAt?: SortOrder
    recurrenceId?: SortOrder
    notes?: SortOrder
    tags?: SortOrder
    attachmentUrl?: SortOrder
    location?: SortOrder
    importId?: SortOrder
    rawData?: SortOrder
    aiConfidence?: SortOrder
    aiCategory?: SortOrder
    aiCategorizedAt?: SortOrder
    aiModelVersion?: SortOrder
    autoRuleId?: SortOrder
    bankConnectionId?: SortOrder
    externalId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
    aiConfidence?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    accountId?: SortOrder
    categoryId?: SortOrder
    creditCardId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    transactionDate?: SortOrder
    confirmedAt?: SortOrder
    recurrenceId?: SortOrder
    notes?: SortOrder
    tags?: SortOrder
    attachmentUrl?: SortOrder
    location?: SortOrder
    importId?: SortOrder
    rawData?: SortOrder
    aiConfidence?: SortOrder
    aiCategory?: SortOrder
    aiCategorizedAt?: SortOrder
    aiModelVersion?: SortOrder
    autoRuleId?: SortOrder
    bankConnectionId?: SortOrder
    externalId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    accountId?: SortOrder
    categoryId?: SortOrder
    creditCardId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    transactionDate?: SortOrder
    confirmedAt?: SortOrder
    recurrenceId?: SortOrder
    notes?: SortOrder
    tags?: SortOrder
    attachmentUrl?: SortOrder
    location?: SortOrder
    importId?: SortOrder
    rawData?: SortOrder
    aiConfidence?: SortOrder
    aiCategory?: SortOrder
    aiCategorizedAt?: SortOrder
    aiModelVersion?: SortOrder
    autoRuleId?: SortOrder
    bankConnectionId?: SortOrder
    externalId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    amount?: SortOrder
    aiConfidence?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type RecurrenceCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    accountId?: SortOrder
    categoryId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    frequency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    nextOccurrence?: SortOrder
    isActive?: SortOrder
    autoConfirm?: SortOrder
    notifyBefore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecurrenceAvgOrderByAggregateInput = {
    amount?: SortOrder
    notifyBefore?: SortOrder
  }

  export type RecurrenceMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    accountId?: SortOrder
    categoryId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    frequency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    nextOccurrence?: SortOrder
    isActive?: SortOrder
    autoConfirm?: SortOrder
    notifyBefore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecurrenceMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    accountId?: SortOrder
    categoryId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    frequency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    nextOccurrence?: SortOrder
    isActive?: SortOrder
    autoConfirm?: SortOrder
    notifyBefore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecurrenceSumOrderByAggregateInput = {
    amount?: SortOrder
    notifyBefore?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type TransferCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    fromAccountId?: SortOrder
    toAccountId?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    fee?: SortOrder
    transferDate?: SortOrder
    createdAt?: SortOrder
  }

  export type TransferAvgOrderByAggregateInput = {
    amount?: SortOrder
    fee?: SortOrder
  }

  export type TransferMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    fromAccountId?: SortOrder
    toAccountId?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    fee?: SortOrder
    transferDate?: SortOrder
    createdAt?: SortOrder
  }

  export type TransferMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    fromAccountId?: SortOrder
    toAccountId?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    fee?: SortOrder
    transferDate?: SortOrder
    createdAt?: SortOrder
  }

  export type TransferSumOrderByAggregateInput = {
    amount?: SortOrder
    fee?: SortOrder
  }

  export type BudgetCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    totalBudgeted?: SortOrder
    totalSpent?: SortOrder
    isActive?: SortOrder
    alertThreshold?: SortOrder
    alertSent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BudgetAvgOrderByAggregateInput = {
    totalBudgeted?: SortOrder
    totalSpent?: SortOrder
    alertThreshold?: SortOrder
  }

  export type BudgetMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    totalBudgeted?: SortOrder
    totalSpent?: SortOrder
    isActive?: SortOrder
    alertThreshold?: SortOrder
    alertSent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BudgetMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    totalBudgeted?: SortOrder
    totalSpent?: SortOrder
    isActive?: SortOrder
    alertThreshold?: SortOrder
    alertSent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BudgetSumOrderByAggregateInput = {
    totalBudgeted?: SortOrder
    totalSpent?: SortOrder
    alertThreshold?: SortOrder
  }

  export type BudgetRelationFilter = {
    is?: BudgetWhereInput
    isNot?: BudgetWhereInput
  }

  export type CategoryRelationFilter = {
    is?: CategoryWhereInput
    isNot?: CategoryWhereInput
  }

  export type BudgetCategoryBudgetIdCategoryIdCompoundUniqueInput = {
    budgetId: string
    categoryId: string
  }

  export type BudgetCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    budgetId?: SortOrder
    categoryId?: SortOrder
    budgeted?: SortOrder
    spent?: SortOrder
  }

  export type BudgetCategoryAvgOrderByAggregateInput = {
    budgeted?: SortOrder
    spent?: SortOrder
  }

  export type BudgetCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    budgetId?: SortOrder
    categoryId?: SortOrder
    budgeted?: SortOrder
    spent?: SortOrder
  }

  export type BudgetCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    budgetId?: SortOrder
    categoryId?: SortOrder
    budgeted?: SortOrder
    spent?: SortOrder
  }

  export type BudgetCategorySumOrderByAggregateInput = {
    budgeted?: SortOrder
    spent?: SortOrder
  }

  export type GoalContributionListRelationFilter = {
    every?: GoalContributionWhereInput
    some?: GoalContributionWhereInput
    none?: GoalContributionWhereInput
  }

  export type GoalContributionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GoalCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    targetAmount?: SortOrder
    currentAmount?: SortOrder
    startDate?: SortOrder
    targetDate?: SortOrder
    completedAt?: SortOrder
    status?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    autoAllocate?: SortOrder
    allocationPercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GoalAvgOrderByAggregateInput = {
    targetAmount?: SortOrder
    currentAmount?: SortOrder
    allocationPercentage?: SortOrder
  }

  export type GoalMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    targetAmount?: SortOrder
    currentAmount?: SortOrder
    startDate?: SortOrder
    targetDate?: SortOrder
    completedAt?: SortOrder
    status?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    autoAllocate?: SortOrder
    allocationPercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GoalMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    targetAmount?: SortOrder
    currentAmount?: SortOrder
    startDate?: SortOrder
    targetDate?: SortOrder
    completedAt?: SortOrder
    status?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    autoAllocate?: SortOrder
    allocationPercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GoalSumOrderByAggregateInput = {
    targetAmount?: SortOrder
    currentAmount?: SortOrder
    allocationPercentage?: SortOrder
  }

  export type GoalRelationFilter = {
    is?: GoalWhereInput
    isNot?: GoalWhereInput
  }

  export type GoalContributionCountOrderByAggregateInput = {
    id?: SortOrder
    goalId?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    contributedAt?: SortOrder
  }

  export type GoalContributionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type GoalContributionMaxOrderByAggregateInput = {
    id?: SortOrder
    goalId?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    contributedAt?: SortOrder
  }

  export type GoalContributionMinOrderByAggregateInput = {
    id?: SortOrder
    goalId?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    contributedAt?: SortOrder
  }

  export type GoalContributionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type ImportJobCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    accountId?: SortOrder
    format?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    fileUrl?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    totalRows?: SortOrder
    processedRows?: SortOrder
    importedRows?: SortOrder
    errorLog?: SortOrder
    mappingConfig?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ImportJobAvgOrderByAggregateInput = {
    fileSize?: SortOrder
    progress?: SortOrder
    totalRows?: SortOrder
    processedRows?: SortOrder
    importedRows?: SortOrder
  }

  export type ImportJobMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    accountId?: SortOrder
    format?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    fileUrl?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    totalRows?: SortOrder
    processedRows?: SortOrder
    importedRows?: SortOrder
    errorLog?: SortOrder
    mappingConfig?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ImportJobMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    accountId?: SortOrder
    format?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    fileUrl?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    totalRows?: SortOrder
    processedRows?: SortOrder
    importedRows?: SortOrder
    errorLog?: SortOrder
    mappingConfig?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ImportJobSumOrderByAggregateInput = {
    fileSize?: SortOrder
    progress?: SortOrder
    totalRows?: SortOrder
    processedRows?: SortOrder
    importedRows?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    data?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    data?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    data?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type WorkspaceNullableRelationFilter = {
    is?: WorkspaceWhereInput | null
    isNot?: WorkspaceWhereInput | null
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    oldData?: SortOrder
    newData?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    oldData?: SortOrder
    newData?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    oldData?: SortOrder
    newData?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type UserAchievementListRelationFilter = {
    every?: UserAchievementWhereInput
    some?: UserAchievementWhereInput
    none?: UserAchievementWhereInput
  }

  export type UserAchievementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserGamificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tier?: SortOrder
    totalXP?: SortOrder
    currentLevel?: SortOrder
    xpToNextLevel?: SortOrder
    loginStreak?: SortOrder
    longestLoginStreak?: SortOrder
    transactionStreak?: SortOrder
    transactionsLogged?: SortOrder
    budgetsMet?: SortOrder
    goalsAchieved?: SortOrder
    lastLoginDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserGamificationAvgOrderByAggregateInput = {
    totalXP?: SortOrder
    currentLevel?: SortOrder
    xpToNextLevel?: SortOrder
    loginStreak?: SortOrder
    longestLoginStreak?: SortOrder
    transactionStreak?: SortOrder
    transactionsLogged?: SortOrder
    budgetsMet?: SortOrder
    goalsAchieved?: SortOrder
  }

  export type UserGamificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tier?: SortOrder
    totalXP?: SortOrder
    currentLevel?: SortOrder
    xpToNextLevel?: SortOrder
    loginStreak?: SortOrder
    longestLoginStreak?: SortOrder
    transactionStreak?: SortOrder
    transactionsLogged?: SortOrder
    budgetsMet?: SortOrder
    goalsAchieved?: SortOrder
    lastLoginDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserGamificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tier?: SortOrder
    totalXP?: SortOrder
    currentLevel?: SortOrder
    xpToNextLevel?: SortOrder
    loginStreak?: SortOrder
    longestLoginStreak?: SortOrder
    transactionStreak?: SortOrder
    transactionsLogged?: SortOrder
    budgetsMet?: SortOrder
    goalsAchieved?: SortOrder
    lastLoginDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserGamificationSumOrderByAggregateInput = {
    totalXP?: SortOrder
    currentLevel?: SortOrder
    xpToNextLevel?: SortOrder
    loginStreak?: SortOrder
    longestLoginStreak?: SortOrder
    transactionStreak?: SortOrder
    transactionsLogged?: SortOrder
    budgetsMet?: SortOrder
    goalsAchieved?: SortOrder
  }

  export type AchievementCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    xpReward?: SortOrder
    requirementType?: SortOrder
    requirementValue?: SortOrder
    createdAt?: SortOrder
  }

  export type AchievementAvgOrderByAggregateInput = {
    xpReward?: SortOrder
    requirementValue?: SortOrder
  }

  export type AchievementMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    xpReward?: SortOrder
    requirementType?: SortOrder
    requirementValue?: SortOrder
    createdAt?: SortOrder
  }

  export type AchievementMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    xpReward?: SortOrder
    requirementType?: SortOrder
    requirementValue?: SortOrder
    createdAt?: SortOrder
  }

  export type AchievementSumOrderByAggregateInput = {
    xpReward?: SortOrder
    requirementValue?: SortOrder
  }

  export type UserGamificationRelationFilter = {
    is?: UserGamificationWhereInput
    isNot?: UserGamificationWhereInput
  }

  export type UserAchievementUserGamificationIdAchievementIdCompoundUniqueInput = {
    userGamificationId: string
    achievementId: string
  }

  export type UserAchievementCountOrderByAggregateInput = {
    id?: SortOrder
    userGamificationId?: SortOrder
    achievementId?: SortOrder
    unlockedAt?: SortOrder
  }

  export type UserAchievementMaxOrderByAggregateInput = {
    id?: SortOrder
    userGamificationId?: SortOrder
    achievementId?: SortOrder
    unlockedAt?: SortOrder
  }

  export type UserAchievementMinOrderByAggregateInput = {
    id?: SortOrder
    userGamificationId?: SortOrder
    achievementId?: SortOrder
    unlockedAt?: SortOrder
  }

  export type EnvelopeWorkspaceIdCategoryIdMonthYearCompoundUniqueInput = {
    workspaceId: string
    categoryId: string
    month: number
    year: number
  }

  export type EnvelopeCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    budgetedAmount?: SortOrder
    availableAmount?: SortOrder
    spentAmount?: SortOrder
    month?: SortOrder
    year?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnvelopeAvgOrderByAggregateInput = {
    budgetedAmount?: SortOrder
    availableAmount?: SortOrder
    spentAmount?: SortOrder
    month?: SortOrder
    year?: SortOrder
  }

  export type EnvelopeMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    budgetedAmount?: SortOrder
    availableAmount?: SortOrder
    spentAmount?: SortOrder
    month?: SortOrder
    year?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnvelopeMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    budgetedAmount?: SortOrder
    availableAmount?: SortOrder
    spentAmount?: SortOrder
    month?: SortOrder
    year?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnvelopeSumOrderByAggregateInput = {
    budgetedAmount?: SortOrder
    availableAmount?: SortOrder
    spentAmount?: SortOrder
    month?: SortOrder
    year?: SortOrder
  }

  export type AssetCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    currentValue?: SortOrder
    purchaseValue?: SortOrder
    purchaseDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssetAvgOrderByAggregateInput = {
    currentValue?: SortOrder
    purchaseValue?: SortOrder
  }

  export type AssetMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    currentValue?: SortOrder
    purchaseValue?: SortOrder
    purchaseDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssetMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    currentValue?: SortOrder
    purchaseValue?: SortOrder
    purchaseDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssetSumOrderByAggregateInput = {
    currentValue?: SortOrder
    purchaseValue?: SortOrder
  }

  export type LiabilityCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    currentBalance?: SortOrder
    originalAmount?: SortOrder
    interestRate?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LiabilityAvgOrderByAggregateInput = {
    currentBalance?: SortOrder
    originalAmount?: SortOrder
    interestRate?: SortOrder
  }

  export type LiabilityMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    currentBalance?: SortOrder
    originalAmount?: SortOrder
    interestRate?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LiabilityMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    currentBalance?: SortOrder
    originalAmount?: SortOrder
    interestRate?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LiabilitySumOrderByAggregateInput = {
    currentBalance?: SortOrder
    originalAmount?: SortOrder
    interestRate?: SortOrder
  }

  export type AIInsightCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    severity?: SortOrder
    suggestedAction?: SortOrder
    actionTaken?: SortOrder
    confidenceScore?: SortOrder
    dismissedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AIInsightAvgOrderByAggregateInput = {
    confidenceScore?: SortOrder
  }

  export type AIInsightMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    severity?: SortOrder
    suggestedAction?: SortOrder
    actionTaken?: SortOrder
    confidenceScore?: SortOrder
    dismissedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AIInsightMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    severity?: SortOrder
    suggestedAction?: SortOrder
    actionTaken?: SortOrder
    confidenceScore?: SortOrder
    dismissedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AIInsightSumOrderByAggregateInput = {
    confidenceScore?: SortOrder
  }

  export type ScenarioCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    parameters?: SortOrder
    isFavorite?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScenarioMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    parameters?: SortOrder
    isFavorite?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScenarioMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    parameters?: SortOrder
    isFavorite?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankConnectionCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    accountId?: SortOrder
    bankName?: SortOrder
    bankCode?: SortOrder
    accessToken?: SortOrder
    status?: SortOrder
    lastSyncAt?: SortOrder
    lastSyncError?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankConnectionMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    accountId?: SortOrder
    bankName?: SortOrder
    bankCode?: SortOrder
    accessToken?: SortOrder
    status?: SortOrder
    lastSyncAt?: SortOrder
    lastSyncError?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankConnectionMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    accountId?: SortOrder
    bankName?: SortOrder
    bankCode?: SortOrder
    accessToken?: SortOrder
    status?: SortOrder
    lastSyncAt?: SortOrder
    lastSyncError?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AutoRuleCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    priority?: SortOrder
    conditions?: SortOrder
    actions?: SortOrder
    timesApplied?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AutoRuleAvgOrderByAggregateInput = {
    priority?: SortOrder
    timesApplied?: SortOrder
  }

  export type AutoRuleMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    priority?: SortOrder
    conditions?: SortOrder
    actions?: SortOrder
    timesApplied?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AutoRuleMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    priority?: SortOrder
    conditions?: SortOrder
    actions?: SortOrder
    timesApplied?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AutoRuleSumOrderByAggregateInput = {
    priority?: SortOrder
    timesApplied?: SortOrder
  }

  export type CashFlowProjectionWorkspaceIdMonthYearCompoundUniqueInput = {
    workspaceId: string
    month: number
    year: number
  }

  export type CashFlowProjectionCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    projectedIncome?: SortOrder
    projectedExpense?: SortOrder
    projectedBalance?: SortOrder
    generatedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CashFlowProjectionAvgOrderByAggregateInput = {
    month?: SortOrder
    year?: SortOrder
    projectedIncome?: SortOrder
    projectedExpense?: SortOrder
    projectedBalance?: SortOrder
  }

  export type CashFlowProjectionMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    projectedIncome?: SortOrder
    projectedExpense?: SortOrder
    projectedBalance?: SortOrder
    generatedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CashFlowProjectionMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    projectedIncome?: SortOrder
    projectedExpense?: SortOrder
    projectedBalance?: SortOrder
    generatedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CashFlowProjectionSumOrderByAggregateInput = {
    month?: SortOrder
    year?: SortOrder
    projectedIncome?: SortOrder
    projectedExpense?: SortOrder
    projectedBalance?: SortOrder
  }

  export type WorkspaceMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<WorkspaceMemberCreateWithoutUserInput, WorkspaceMemberUncheckedCreateWithoutUserInput> | WorkspaceMemberCreateWithoutUserInput[] | WorkspaceMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkspaceMemberCreateOrConnectWithoutUserInput | WorkspaceMemberCreateOrConnectWithoutUserInput[]
    createMany?: WorkspaceMemberCreateManyUserInputEnvelope
    connect?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type PasswordResetCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordResetCreateWithoutUserInput, PasswordResetUncheckedCreateWithoutUserInput> | PasswordResetCreateWithoutUserInput[] | PasswordResetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetCreateOrConnectWithoutUserInput | PasswordResetCreateOrConnectWithoutUserInput[]
    createMany?: PasswordResetCreateManyUserInputEnvelope
    connect?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
  }

  export type RefreshTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type UserGamificationCreateNestedOneWithoutUserInput = {
    create?: XOR<UserGamificationCreateWithoutUserInput, UserGamificationUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserGamificationCreateOrConnectWithoutUserInput
    connect?: UserGamificationWhereUniqueInput
  }

  export type AIInsightCreateNestedManyWithoutUserInput = {
    create?: XOR<AIInsightCreateWithoutUserInput, AIInsightUncheckedCreateWithoutUserInput> | AIInsightCreateWithoutUserInput[] | AIInsightUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIInsightCreateOrConnectWithoutUserInput | AIInsightCreateOrConnectWithoutUserInput[]
    createMany?: AIInsightCreateManyUserInputEnvelope
    connect?: AIInsightWhereUniqueInput | AIInsightWhereUniqueInput[]
  }

  export type ScenarioCreateNestedManyWithoutUserInput = {
    create?: XOR<ScenarioCreateWithoutUserInput, ScenarioUncheckedCreateWithoutUserInput> | ScenarioCreateWithoutUserInput[] | ScenarioUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ScenarioCreateOrConnectWithoutUserInput | ScenarioCreateOrConnectWithoutUserInput[]
    createMany?: ScenarioCreateManyUserInputEnvelope
    connect?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
  }

  export type AutoRuleCreateNestedManyWithoutUserInput = {
    create?: XOR<AutoRuleCreateWithoutUserInput, AutoRuleUncheckedCreateWithoutUserInput> | AutoRuleCreateWithoutUserInput[] | AutoRuleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AutoRuleCreateOrConnectWithoutUserInput | AutoRuleCreateOrConnectWithoutUserInput[]
    createMany?: AutoRuleCreateManyUserInputEnvelope
    connect?: AutoRuleWhereUniqueInput | AutoRuleWhereUniqueInput[]
  }

  export type WorkspaceMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WorkspaceMemberCreateWithoutUserInput, WorkspaceMemberUncheckedCreateWithoutUserInput> | WorkspaceMemberCreateWithoutUserInput[] | WorkspaceMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkspaceMemberCreateOrConnectWithoutUserInput | WorkspaceMemberCreateOrConnectWithoutUserInput[]
    createMany?: WorkspaceMemberCreateManyUserInputEnvelope
    connect?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type PasswordResetUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordResetCreateWithoutUserInput, PasswordResetUncheckedCreateWithoutUserInput> | PasswordResetCreateWithoutUserInput[] | PasswordResetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetCreateOrConnectWithoutUserInput | PasswordResetCreateOrConnectWithoutUserInput[]
    createMany?: PasswordResetCreateManyUserInputEnvelope
    connect?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
  }

  export type RefreshTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type UserGamificationUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserGamificationCreateWithoutUserInput, UserGamificationUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserGamificationCreateOrConnectWithoutUserInput
    connect?: UserGamificationWhereUniqueInput
  }

  export type AIInsightUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AIInsightCreateWithoutUserInput, AIInsightUncheckedCreateWithoutUserInput> | AIInsightCreateWithoutUserInput[] | AIInsightUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIInsightCreateOrConnectWithoutUserInput | AIInsightCreateOrConnectWithoutUserInput[]
    createMany?: AIInsightCreateManyUserInputEnvelope
    connect?: AIInsightWhereUniqueInput | AIInsightWhereUniqueInput[]
  }

  export type ScenarioUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ScenarioCreateWithoutUserInput, ScenarioUncheckedCreateWithoutUserInput> | ScenarioCreateWithoutUserInput[] | ScenarioUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ScenarioCreateOrConnectWithoutUserInput | ScenarioCreateOrConnectWithoutUserInput[]
    createMany?: ScenarioCreateManyUserInputEnvelope
    connect?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
  }

  export type AutoRuleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AutoRuleCreateWithoutUserInput, AutoRuleUncheckedCreateWithoutUserInput> | AutoRuleCreateWithoutUserInput[] | AutoRuleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AutoRuleCreateOrConnectWithoutUserInput | AutoRuleCreateOrConnectWithoutUserInput[]
    createMany?: AutoRuleCreateManyUserInputEnvelope
    connect?: AutoRuleWhereUniqueInput | AutoRuleWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type WorkspaceMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<WorkspaceMemberCreateWithoutUserInput, WorkspaceMemberUncheckedCreateWithoutUserInput> | WorkspaceMemberCreateWithoutUserInput[] | WorkspaceMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkspaceMemberCreateOrConnectWithoutUserInput | WorkspaceMemberCreateOrConnectWithoutUserInput[]
    upsert?: WorkspaceMemberUpsertWithWhereUniqueWithoutUserInput | WorkspaceMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WorkspaceMemberCreateManyUserInputEnvelope
    set?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
    disconnect?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
    delete?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
    connect?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
    update?: WorkspaceMemberUpdateWithWhereUniqueWithoutUserInput | WorkspaceMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WorkspaceMemberUpdateManyWithWhereWithoutUserInput | WorkspaceMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WorkspaceMemberScalarWhereInput | WorkspaceMemberScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type PasswordResetUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordResetCreateWithoutUserInput, PasswordResetUncheckedCreateWithoutUserInput> | PasswordResetCreateWithoutUserInput[] | PasswordResetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetCreateOrConnectWithoutUserInput | PasswordResetCreateOrConnectWithoutUserInput[]
    upsert?: PasswordResetUpsertWithWhereUniqueWithoutUserInput | PasswordResetUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordResetCreateManyUserInputEnvelope
    set?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
    disconnect?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
    delete?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
    connect?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
    update?: PasswordResetUpdateWithWhereUniqueWithoutUserInput | PasswordResetUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordResetUpdateManyWithWhereWithoutUserInput | PasswordResetUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordResetScalarWhereInput | PasswordResetScalarWhereInput[]
  }

  export type RefreshTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type UserGamificationUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserGamificationCreateWithoutUserInput, UserGamificationUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserGamificationCreateOrConnectWithoutUserInput
    upsert?: UserGamificationUpsertWithoutUserInput
    disconnect?: UserGamificationWhereInput | boolean
    delete?: UserGamificationWhereInput | boolean
    connect?: UserGamificationWhereUniqueInput
    update?: XOR<XOR<UserGamificationUpdateToOneWithWhereWithoutUserInput, UserGamificationUpdateWithoutUserInput>, UserGamificationUncheckedUpdateWithoutUserInput>
  }

  export type AIInsightUpdateManyWithoutUserNestedInput = {
    create?: XOR<AIInsightCreateWithoutUserInput, AIInsightUncheckedCreateWithoutUserInput> | AIInsightCreateWithoutUserInput[] | AIInsightUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIInsightCreateOrConnectWithoutUserInput | AIInsightCreateOrConnectWithoutUserInput[]
    upsert?: AIInsightUpsertWithWhereUniqueWithoutUserInput | AIInsightUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AIInsightCreateManyUserInputEnvelope
    set?: AIInsightWhereUniqueInput | AIInsightWhereUniqueInput[]
    disconnect?: AIInsightWhereUniqueInput | AIInsightWhereUniqueInput[]
    delete?: AIInsightWhereUniqueInput | AIInsightWhereUniqueInput[]
    connect?: AIInsightWhereUniqueInput | AIInsightWhereUniqueInput[]
    update?: AIInsightUpdateWithWhereUniqueWithoutUserInput | AIInsightUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AIInsightUpdateManyWithWhereWithoutUserInput | AIInsightUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AIInsightScalarWhereInput | AIInsightScalarWhereInput[]
  }

  export type ScenarioUpdateManyWithoutUserNestedInput = {
    create?: XOR<ScenarioCreateWithoutUserInput, ScenarioUncheckedCreateWithoutUserInput> | ScenarioCreateWithoutUserInput[] | ScenarioUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ScenarioCreateOrConnectWithoutUserInput | ScenarioCreateOrConnectWithoutUserInput[]
    upsert?: ScenarioUpsertWithWhereUniqueWithoutUserInput | ScenarioUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ScenarioCreateManyUserInputEnvelope
    set?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
    disconnect?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
    delete?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
    connect?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
    update?: ScenarioUpdateWithWhereUniqueWithoutUserInput | ScenarioUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ScenarioUpdateManyWithWhereWithoutUserInput | ScenarioUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ScenarioScalarWhereInput | ScenarioScalarWhereInput[]
  }

  export type AutoRuleUpdateManyWithoutUserNestedInput = {
    create?: XOR<AutoRuleCreateWithoutUserInput, AutoRuleUncheckedCreateWithoutUserInput> | AutoRuleCreateWithoutUserInput[] | AutoRuleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AutoRuleCreateOrConnectWithoutUserInput | AutoRuleCreateOrConnectWithoutUserInput[]
    upsert?: AutoRuleUpsertWithWhereUniqueWithoutUserInput | AutoRuleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AutoRuleCreateManyUserInputEnvelope
    set?: AutoRuleWhereUniqueInput | AutoRuleWhereUniqueInput[]
    disconnect?: AutoRuleWhereUniqueInput | AutoRuleWhereUniqueInput[]
    delete?: AutoRuleWhereUniqueInput | AutoRuleWhereUniqueInput[]
    connect?: AutoRuleWhereUniqueInput | AutoRuleWhereUniqueInput[]
    update?: AutoRuleUpdateWithWhereUniqueWithoutUserInput | AutoRuleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AutoRuleUpdateManyWithWhereWithoutUserInput | AutoRuleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AutoRuleScalarWhereInput | AutoRuleScalarWhereInput[]
  }

  export type WorkspaceMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WorkspaceMemberCreateWithoutUserInput, WorkspaceMemberUncheckedCreateWithoutUserInput> | WorkspaceMemberCreateWithoutUserInput[] | WorkspaceMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkspaceMemberCreateOrConnectWithoutUserInput | WorkspaceMemberCreateOrConnectWithoutUserInput[]
    upsert?: WorkspaceMemberUpsertWithWhereUniqueWithoutUserInput | WorkspaceMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WorkspaceMemberCreateManyUserInputEnvelope
    set?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
    disconnect?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
    delete?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
    connect?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
    update?: WorkspaceMemberUpdateWithWhereUniqueWithoutUserInput | WorkspaceMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WorkspaceMemberUpdateManyWithWhereWithoutUserInput | WorkspaceMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WorkspaceMemberScalarWhereInput | WorkspaceMemberScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type PasswordResetUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordResetCreateWithoutUserInput, PasswordResetUncheckedCreateWithoutUserInput> | PasswordResetCreateWithoutUserInput[] | PasswordResetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetCreateOrConnectWithoutUserInput | PasswordResetCreateOrConnectWithoutUserInput[]
    upsert?: PasswordResetUpsertWithWhereUniqueWithoutUserInput | PasswordResetUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordResetCreateManyUserInputEnvelope
    set?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
    disconnect?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
    delete?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
    connect?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
    update?: PasswordResetUpdateWithWhereUniqueWithoutUserInput | PasswordResetUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordResetUpdateManyWithWhereWithoutUserInput | PasswordResetUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordResetScalarWhereInput | PasswordResetScalarWhereInput[]
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type UserGamificationUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserGamificationCreateWithoutUserInput, UserGamificationUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserGamificationCreateOrConnectWithoutUserInput
    upsert?: UserGamificationUpsertWithoutUserInput
    disconnect?: UserGamificationWhereInput | boolean
    delete?: UserGamificationWhereInput | boolean
    connect?: UserGamificationWhereUniqueInput
    update?: XOR<XOR<UserGamificationUpdateToOneWithWhereWithoutUserInput, UserGamificationUpdateWithoutUserInput>, UserGamificationUncheckedUpdateWithoutUserInput>
  }

  export type AIInsightUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AIInsightCreateWithoutUserInput, AIInsightUncheckedCreateWithoutUserInput> | AIInsightCreateWithoutUserInput[] | AIInsightUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIInsightCreateOrConnectWithoutUserInput | AIInsightCreateOrConnectWithoutUserInput[]
    upsert?: AIInsightUpsertWithWhereUniqueWithoutUserInput | AIInsightUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AIInsightCreateManyUserInputEnvelope
    set?: AIInsightWhereUniqueInput | AIInsightWhereUniqueInput[]
    disconnect?: AIInsightWhereUniqueInput | AIInsightWhereUniqueInput[]
    delete?: AIInsightWhereUniqueInput | AIInsightWhereUniqueInput[]
    connect?: AIInsightWhereUniqueInput | AIInsightWhereUniqueInput[]
    update?: AIInsightUpdateWithWhereUniqueWithoutUserInput | AIInsightUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AIInsightUpdateManyWithWhereWithoutUserInput | AIInsightUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AIInsightScalarWhereInput | AIInsightScalarWhereInput[]
  }

  export type ScenarioUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ScenarioCreateWithoutUserInput, ScenarioUncheckedCreateWithoutUserInput> | ScenarioCreateWithoutUserInput[] | ScenarioUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ScenarioCreateOrConnectWithoutUserInput | ScenarioCreateOrConnectWithoutUserInput[]
    upsert?: ScenarioUpsertWithWhereUniqueWithoutUserInput | ScenarioUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ScenarioCreateManyUserInputEnvelope
    set?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
    disconnect?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
    delete?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
    connect?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
    update?: ScenarioUpdateWithWhereUniqueWithoutUserInput | ScenarioUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ScenarioUpdateManyWithWhereWithoutUserInput | ScenarioUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ScenarioScalarWhereInput | ScenarioScalarWhereInput[]
  }

  export type AutoRuleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AutoRuleCreateWithoutUserInput, AutoRuleUncheckedCreateWithoutUserInput> | AutoRuleCreateWithoutUserInput[] | AutoRuleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AutoRuleCreateOrConnectWithoutUserInput | AutoRuleCreateOrConnectWithoutUserInput[]
    upsert?: AutoRuleUpsertWithWhereUniqueWithoutUserInput | AutoRuleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AutoRuleCreateManyUserInputEnvelope
    set?: AutoRuleWhereUniqueInput | AutoRuleWhereUniqueInput[]
    disconnect?: AutoRuleWhereUniqueInput | AutoRuleWhereUniqueInput[]
    delete?: AutoRuleWhereUniqueInput | AutoRuleWhereUniqueInput[]
    connect?: AutoRuleWhereUniqueInput | AutoRuleWhereUniqueInput[]
    update?: AutoRuleUpdateWithWhereUniqueWithoutUserInput | AutoRuleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AutoRuleUpdateManyWithWhereWithoutUserInput | AutoRuleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AutoRuleScalarWhereInput | AutoRuleScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutRefreshTokensInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRefreshTokensNestedInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    upsert?: UserUpsertWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRefreshTokensInput, UserUpdateWithoutRefreshTokensInput>, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type UserCreateNestedOneWithoutPasswordResetsInput = {
    create?: XOR<UserCreateWithoutPasswordResetsInput, UserUncheckedCreateWithoutPasswordResetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordResetsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPasswordResetsNestedInput = {
    create?: XOR<UserCreateWithoutPasswordResetsInput, UserUncheckedCreateWithoutPasswordResetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordResetsInput
    upsert?: UserUpsertWithoutPasswordResetsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPasswordResetsInput, UserUpdateWithoutPasswordResetsInput>, UserUncheckedUpdateWithoutPasswordResetsInput>
  }

  export type WorkspaceMemberCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<WorkspaceMemberCreateWithoutWorkspaceInput, WorkspaceMemberUncheckedCreateWithoutWorkspaceInput> | WorkspaceMemberCreateWithoutWorkspaceInput[] | WorkspaceMemberUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceMemberCreateOrConnectWithoutWorkspaceInput | WorkspaceMemberCreateOrConnectWithoutWorkspaceInput[]
    createMany?: WorkspaceMemberCreateManyWorkspaceInputEnvelope
    connect?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
  }

  export type AccountCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<AccountCreateWithoutWorkspaceInput, AccountUncheckedCreateWithoutWorkspaceInput> | AccountCreateWithoutWorkspaceInput[] | AccountUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutWorkspaceInput | AccountCreateOrConnectWithoutWorkspaceInput[]
    createMany?: AccountCreateManyWorkspaceInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type CategoryCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<CategoryCreateWithoutWorkspaceInput, CategoryUncheckedCreateWithoutWorkspaceInput> | CategoryCreateWithoutWorkspaceInput[] | CategoryUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutWorkspaceInput | CategoryCreateOrConnectWithoutWorkspaceInput[]
    createMany?: CategoryCreateManyWorkspaceInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type GoalCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<GoalCreateWithoutWorkspaceInput, GoalUncheckedCreateWithoutWorkspaceInput> | GoalCreateWithoutWorkspaceInput[] | GoalUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: GoalCreateOrConnectWithoutWorkspaceInput | GoalCreateOrConnectWithoutWorkspaceInput[]
    createMany?: GoalCreateManyWorkspaceInputEnvelope
    connect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
  }

  export type BudgetCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<BudgetCreateWithoutWorkspaceInput, BudgetUncheckedCreateWithoutWorkspaceInput> | BudgetCreateWithoutWorkspaceInput[] | BudgetUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutWorkspaceInput | BudgetCreateOrConnectWithoutWorkspaceInput[]
    createMany?: BudgetCreateManyWorkspaceInputEnvelope
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
  }

  export type ImportJobCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<ImportJobCreateWithoutWorkspaceInput, ImportJobUncheckedCreateWithoutWorkspaceInput> | ImportJobCreateWithoutWorkspaceInput[] | ImportJobUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ImportJobCreateOrConnectWithoutWorkspaceInput | ImportJobCreateOrConnectWithoutWorkspaceInput[]
    createMany?: ImportJobCreateManyWorkspaceInputEnvelope
    connect?: ImportJobWhereUniqueInput | ImportJobWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<AuditLogCreateWithoutWorkspaceInput, AuditLogUncheckedCreateWithoutWorkspaceInput> | AuditLogCreateWithoutWorkspaceInput[] | AuditLogUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutWorkspaceInput | AuditLogCreateOrConnectWithoutWorkspaceInput[]
    createMany?: AuditLogCreateManyWorkspaceInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type EnvelopeCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<EnvelopeCreateWithoutWorkspaceInput, EnvelopeUncheckedCreateWithoutWorkspaceInput> | EnvelopeCreateWithoutWorkspaceInput[] | EnvelopeUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: EnvelopeCreateOrConnectWithoutWorkspaceInput | EnvelopeCreateOrConnectWithoutWorkspaceInput[]
    createMany?: EnvelopeCreateManyWorkspaceInputEnvelope
    connect?: EnvelopeWhereUniqueInput | EnvelopeWhereUniqueInput[]
  }

  export type AssetCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<AssetCreateWithoutWorkspaceInput, AssetUncheckedCreateWithoutWorkspaceInput> | AssetCreateWithoutWorkspaceInput[] | AssetUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutWorkspaceInput | AssetCreateOrConnectWithoutWorkspaceInput[]
    createMany?: AssetCreateManyWorkspaceInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type LiabilityCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<LiabilityCreateWithoutWorkspaceInput, LiabilityUncheckedCreateWithoutWorkspaceInput> | LiabilityCreateWithoutWorkspaceInput[] | LiabilityUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: LiabilityCreateOrConnectWithoutWorkspaceInput | LiabilityCreateOrConnectWithoutWorkspaceInput[]
    createMany?: LiabilityCreateManyWorkspaceInputEnvelope
    connect?: LiabilityWhereUniqueInput | LiabilityWhereUniqueInput[]
  }

  export type AIInsightCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<AIInsightCreateWithoutWorkspaceInput, AIInsightUncheckedCreateWithoutWorkspaceInput> | AIInsightCreateWithoutWorkspaceInput[] | AIInsightUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AIInsightCreateOrConnectWithoutWorkspaceInput | AIInsightCreateOrConnectWithoutWorkspaceInput[]
    createMany?: AIInsightCreateManyWorkspaceInputEnvelope
    connect?: AIInsightWhereUniqueInput | AIInsightWhereUniqueInput[]
  }

  export type ScenarioCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<ScenarioCreateWithoutWorkspaceInput, ScenarioUncheckedCreateWithoutWorkspaceInput> | ScenarioCreateWithoutWorkspaceInput[] | ScenarioUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ScenarioCreateOrConnectWithoutWorkspaceInput | ScenarioCreateOrConnectWithoutWorkspaceInput[]
    createMany?: ScenarioCreateManyWorkspaceInputEnvelope
    connect?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
  }

  export type BankConnectionCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<BankConnectionCreateWithoutWorkspaceInput, BankConnectionUncheckedCreateWithoutWorkspaceInput> | BankConnectionCreateWithoutWorkspaceInput[] | BankConnectionUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: BankConnectionCreateOrConnectWithoutWorkspaceInput | BankConnectionCreateOrConnectWithoutWorkspaceInput[]
    createMany?: BankConnectionCreateManyWorkspaceInputEnvelope
    connect?: BankConnectionWhereUniqueInput | BankConnectionWhereUniqueInput[]
  }

  export type AutoRuleCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<AutoRuleCreateWithoutWorkspaceInput, AutoRuleUncheckedCreateWithoutWorkspaceInput> | AutoRuleCreateWithoutWorkspaceInput[] | AutoRuleUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AutoRuleCreateOrConnectWithoutWorkspaceInput | AutoRuleCreateOrConnectWithoutWorkspaceInput[]
    createMany?: AutoRuleCreateManyWorkspaceInputEnvelope
    connect?: AutoRuleWhereUniqueInput | AutoRuleWhereUniqueInput[]
  }

  export type CashFlowProjectionCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<CashFlowProjectionCreateWithoutWorkspaceInput, CashFlowProjectionUncheckedCreateWithoutWorkspaceInput> | CashFlowProjectionCreateWithoutWorkspaceInput[] | CashFlowProjectionUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: CashFlowProjectionCreateOrConnectWithoutWorkspaceInput | CashFlowProjectionCreateOrConnectWithoutWorkspaceInput[]
    createMany?: CashFlowProjectionCreateManyWorkspaceInputEnvelope
    connect?: CashFlowProjectionWhereUniqueInput | CashFlowProjectionWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<TransactionCreateWithoutWorkspaceInput, TransactionUncheckedCreateWithoutWorkspaceInput> | TransactionCreateWithoutWorkspaceInput[] | TransactionUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutWorkspaceInput | TransactionCreateOrConnectWithoutWorkspaceInput[]
    createMany?: TransactionCreateManyWorkspaceInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type WorkspaceMemberUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<WorkspaceMemberCreateWithoutWorkspaceInput, WorkspaceMemberUncheckedCreateWithoutWorkspaceInput> | WorkspaceMemberCreateWithoutWorkspaceInput[] | WorkspaceMemberUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceMemberCreateOrConnectWithoutWorkspaceInput | WorkspaceMemberCreateOrConnectWithoutWorkspaceInput[]
    createMany?: WorkspaceMemberCreateManyWorkspaceInputEnvelope
    connect?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<AccountCreateWithoutWorkspaceInput, AccountUncheckedCreateWithoutWorkspaceInput> | AccountCreateWithoutWorkspaceInput[] | AccountUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutWorkspaceInput | AccountCreateOrConnectWithoutWorkspaceInput[]
    createMany?: AccountCreateManyWorkspaceInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type CategoryUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<CategoryCreateWithoutWorkspaceInput, CategoryUncheckedCreateWithoutWorkspaceInput> | CategoryCreateWithoutWorkspaceInput[] | CategoryUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutWorkspaceInput | CategoryCreateOrConnectWithoutWorkspaceInput[]
    createMany?: CategoryCreateManyWorkspaceInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type GoalUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<GoalCreateWithoutWorkspaceInput, GoalUncheckedCreateWithoutWorkspaceInput> | GoalCreateWithoutWorkspaceInput[] | GoalUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: GoalCreateOrConnectWithoutWorkspaceInput | GoalCreateOrConnectWithoutWorkspaceInput[]
    createMany?: GoalCreateManyWorkspaceInputEnvelope
    connect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
  }

  export type BudgetUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<BudgetCreateWithoutWorkspaceInput, BudgetUncheckedCreateWithoutWorkspaceInput> | BudgetCreateWithoutWorkspaceInput[] | BudgetUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutWorkspaceInput | BudgetCreateOrConnectWithoutWorkspaceInput[]
    createMany?: BudgetCreateManyWorkspaceInputEnvelope
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
  }

  export type ImportJobUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<ImportJobCreateWithoutWorkspaceInput, ImportJobUncheckedCreateWithoutWorkspaceInput> | ImportJobCreateWithoutWorkspaceInput[] | ImportJobUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ImportJobCreateOrConnectWithoutWorkspaceInput | ImportJobCreateOrConnectWithoutWorkspaceInput[]
    createMany?: ImportJobCreateManyWorkspaceInputEnvelope
    connect?: ImportJobWhereUniqueInput | ImportJobWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<AuditLogCreateWithoutWorkspaceInput, AuditLogUncheckedCreateWithoutWorkspaceInput> | AuditLogCreateWithoutWorkspaceInput[] | AuditLogUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutWorkspaceInput | AuditLogCreateOrConnectWithoutWorkspaceInput[]
    createMany?: AuditLogCreateManyWorkspaceInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type EnvelopeUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<EnvelopeCreateWithoutWorkspaceInput, EnvelopeUncheckedCreateWithoutWorkspaceInput> | EnvelopeCreateWithoutWorkspaceInput[] | EnvelopeUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: EnvelopeCreateOrConnectWithoutWorkspaceInput | EnvelopeCreateOrConnectWithoutWorkspaceInput[]
    createMany?: EnvelopeCreateManyWorkspaceInputEnvelope
    connect?: EnvelopeWhereUniqueInput | EnvelopeWhereUniqueInput[]
  }

  export type AssetUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<AssetCreateWithoutWorkspaceInput, AssetUncheckedCreateWithoutWorkspaceInput> | AssetCreateWithoutWorkspaceInput[] | AssetUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutWorkspaceInput | AssetCreateOrConnectWithoutWorkspaceInput[]
    createMany?: AssetCreateManyWorkspaceInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type LiabilityUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<LiabilityCreateWithoutWorkspaceInput, LiabilityUncheckedCreateWithoutWorkspaceInput> | LiabilityCreateWithoutWorkspaceInput[] | LiabilityUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: LiabilityCreateOrConnectWithoutWorkspaceInput | LiabilityCreateOrConnectWithoutWorkspaceInput[]
    createMany?: LiabilityCreateManyWorkspaceInputEnvelope
    connect?: LiabilityWhereUniqueInput | LiabilityWhereUniqueInput[]
  }

  export type AIInsightUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<AIInsightCreateWithoutWorkspaceInput, AIInsightUncheckedCreateWithoutWorkspaceInput> | AIInsightCreateWithoutWorkspaceInput[] | AIInsightUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AIInsightCreateOrConnectWithoutWorkspaceInput | AIInsightCreateOrConnectWithoutWorkspaceInput[]
    createMany?: AIInsightCreateManyWorkspaceInputEnvelope
    connect?: AIInsightWhereUniqueInput | AIInsightWhereUniqueInput[]
  }

  export type ScenarioUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<ScenarioCreateWithoutWorkspaceInput, ScenarioUncheckedCreateWithoutWorkspaceInput> | ScenarioCreateWithoutWorkspaceInput[] | ScenarioUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ScenarioCreateOrConnectWithoutWorkspaceInput | ScenarioCreateOrConnectWithoutWorkspaceInput[]
    createMany?: ScenarioCreateManyWorkspaceInputEnvelope
    connect?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
  }

  export type BankConnectionUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<BankConnectionCreateWithoutWorkspaceInput, BankConnectionUncheckedCreateWithoutWorkspaceInput> | BankConnectionCreateWithoutWorkspaceInput[] | BankConnectionUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: BankConnectionCreateOrConnectWithoutWorkspaceInput | BankConnectionCreateOrConnectWithoutWorkspaceInput[]
    createMany?: BankConnectionCreateManyWorkspaceInputEnvelope
    connect?: BankConnectionWhereUniqueInput | BankConnectionWhereUniqueInput[]
  }

  export type AutoRuleUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<AutoRuleCreateWithoutWorkspaceInput, AutoRuleUncheckedCreateWithoutWorkspaceInput> | AutoRuleCreateWithoutWorkspaceInput[] | AutoRuleUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AutoRuleCreateOrConnectWithoutWorkspaceInput | AutoRuleCreateOrConnectWithoutWorkspaceInput[]
    createMany?: AutoRuleCreateManyWorkspaceInputEnvelope
    connect?: AutoRuleWhereUniqueInput | AutoRuleWhereUniqueInput[]
  }

  export type CashFlowProjectionUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<CashFlowProjectionCreateWithoutWorkspaceInput, CashFlowProjectionUncheckedCreateWithoutWorkspaceInput> | CashFlowProjectionCreateWithoutWorkspaceInput[] | CashFlowProjectionUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: CashFlowProjectionCreateOrConnectWithoutWorkspaceInput | CashFlowProjectionCreateOrConnectWithoutWorkspaceInput[]
    createMany?: CashFlowProjectionCreateManyWorkspaceInputEnvelope
    connect?: CashFlowProjectionWhereUniqueInput | CashFlowProjectionWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<TransactionCreateWithoutWorkspaceInput, TransactionUncheckedCreateWithoutWorkspaceInput> | TransactionCreateWithoutWorkspaceInput[] | TransactionUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutWorkspaceInput | TransactionCreateOrConnectWithoutWorkspaceInput[]
    createMany?: TransactionCreateManyWorkspaceInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type WorkspaceMemberUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<WorkspaceMemberCreateWithoutWorkspaceInput, WorkspaceMemberUncheckedCreateWithoutWorkspaceInput> | WorkspaceMemberCreateWithoutWorkspaceInput[] | WorkspaceMemberUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceMemberCreateOrConnectWithoutWorkspaceInput | WorkspaceMemberCreateOrConnectWithoutWorkspaceInput[]
    upsert?: WorkspaceMemberUpsertWithWhereUniqueWithoutWorkspaceInput | WorkspaceMemberUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: WorkspaceMemberCreateManyWorkspaceInputEnvelope
    set?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
    disconnect?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
    delete?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
    connect?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
    update?: WorkspaceMemberUpdateWithWhereUniqueWithoutWorkspaceInput | WorkspaceMemberUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: WorkspaceMemberUpdateManyWithWhereWithoutWorkspaceInput | WorkspaceMemberUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: WorkspaceMemberScalarWhereInput | WorkspaceMemberScalarWhereInput[]
  }

  export type AccountUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<AccountCreateWithoutWorkspaceInput, AccountUncheckedCreateWithoutWorkspaceInput> | AccountCreateWithoutWorkspaceInput[] | AccountUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutWorkspaceInput | AccountCreateOrConnectWithoutWorkspaceInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutWorkspaceInput | AccountUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: AccountCreateManyWorkspaceInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutWorkspaceInput | AccountUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutWorkspaceInput | AccountUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type CategoryUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<CategoryCreateWithoutWorkspaceInput, CategoryUncheckedCreateWithoutWorkspaceInput> | CategoryCreateWithoutWorkspaceInput[] | CategoryUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutWorkspaceInput | CategoryCreateOrConnectWithoutWorkspaceInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutWorkspaceInput | CategoryUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: CategoryCreateManyWorkspaceInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutWorkspaceInput | CategoryUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutWorkspaceInput | CategoryUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type GoalUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<GoalCreateWithoutWorkspaceInput, GoalUncheckedCreateWithoutWorkspaceInput> | GoalCreateWithoutWorkspaceInput[] | GoalUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: GoalCreateOrConnectWithoutWorkspaceInput | GoalCreateOrConnectWithoutWorkspaceInput[]
    upsert?: GoalUpsertWithWhereUniqueWithoutWorkspaceInput | GoalUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: GoalCreateManyWorkspaceInputEnvelope
    set?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    disconnect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    delete?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    connect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    update?: GoalUpdateWithWhereUniqueWithoutWorkspaceInput | GoalUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: GoalUpdateManyWithWhereWithoutWorkspaceInput | GoalUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: GoalScalarWhereInput | GoalScalarWhereInput[]
  }

  export type BudgetUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<BudgetCreateWithoutWorkspaceInput, BudgetUncheckedCreateWithoutWorkspaceInput> | BudgetCreateWithoutWorkspaceInput[] | BudgetUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutWorkspaceInput | BudgetCreateOrConnectWithoutWorkspaceInput[]
    upsert?: BudgetUpsertWithWhereUniqueWithoutWorkspaceInput | BudgetUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: BudgetCreateManyWorkspaceInputEnvelope
    set?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    disconnect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    delete?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    update?: BudgetUpdateWithWhereUniqueWithoutWorkspaceInput | BudgetUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: BudgetUpdateManyWithWhereWithoutWorkspaceInput | BudgetUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: BudgetScalarWhereInput | BudgetScalarWhereInput[]
  }

  export type ImportJobUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<ImportJobCreateWithoutWorkspaceInput, ImportJobUncheckedCreateWithoutWorkspaceInput> | ImportJobCreateWithoutWorkspaceInput[] | ImportJobUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ImportJobCreateOrConnectWithoutWorkspaceInput | ImportJobCreateOrConnectWithoutWorkspaceInput[]
    upsert?: ImportJobUpsertWithWhereUniqueWithoutWorkspaceInput | ImportJobUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: ImportJobCreateManyWorkspaceInputEnvelope
    set?: ImportJobWhereUniqueInput | ImportJobWhereUniqueInput[]
    disconnect?: ImportJobWhereUniqueInput | ImportJobWhereUniqueInput[]
    delete?: ImportJobWhereUniqueInput | ImportJobWhereUniqueInput[]
    connect?: ImportJobWhereUniqueInput | ImportJobWhereUniqueInput[]
    update?: ImportJobUpdateWithWhereUniqueWithoutWorkspaceInput | ImportJobUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: ImportJobUpdateManyWithWhereWithoutWorkspaceInput | ImportJobUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: ImportJobScalarWhereInput | ImportJobScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<AuditLogCreateWithoutWorkspaceInput, AuditLogUncheckedCreateWithoutWorkspaceInput> | AuditLogCreateWithoutWorkspaceInput[] | AuditLogUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutWorkspaceInput | AuditLogCreateOrConnectWithoutWorkspaceInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutWorkspaceInput | AuditLogUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: AuditLogCreateManyWorkspaceInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutWorkspaceInput | AuditLogUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutWorkspaceInput | AuditLogUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type EnvelopeUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<EnvelopeCreateWithoutWorkspaceInput, EnvelopeUncheckedCreateWithoutWorkspaceInput> | EnvelopeCreateWithoutWorkspaceInput[] | EnvelopeUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: EnvelopeCreateOrConnectWithoutWorkspaceInput | EnvelopeCreateOrConnectWithoutWorkspaceInput[]
    upsert?: EnvelopeUpsertWithWhereUniqueWithoutWorkspaceInput | EnvelopeUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: EnvelopeCreateManyWorkspaceInputEnvelope
    set?: EnvelopeWhereUniqueInput | EnvelopeWhereUniqueInput[]
    disconnect?: EnvelopeWhereUniqueInput | EnvelopeWhereUniqueInput[]
    delete?: EnvelopeWhereUniqueInput | EnvelopeWhereUniqueInput[]
    connect?: EnvelopeWhereUniqueInput | EnvelopeWhereUniqueInput[]
    update?: EnvelopeUpdateWithWhereUniqueWithoutWorkspaceInput | EnvelopeUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: EnvelopeUpdateManyWithWhereWithoutWorkspaceInput | EnvelopeUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: EnvelopeScalarWhereInput | EnvelopeScalarWhereInput[]
  }

  export type AssetUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<AssetCreateWithoutWorkspaceInput, AssetUncheckedCreateWithoutWorkspaceInput> | AssetCreateWithoutWorkspaceInput[] | AssetUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutWorkspaceInput | AssetCreateOrConnectWithoutWorkspaceInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutWorkspaceInput | AssetUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: AssetCreateManyWorkspaceInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutWorkspaceInput | AssetUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutWorkspaceInput | AssetUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type LiabilityUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<LiabilityCreateWithoutWorkspaceInput, LiabilityUncheckedCreateWithoutWorkspaceInput> | LiabilityCreateWithoutWorkspaceInput[] | LiabilityUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: LiabilityCreateOrConnectWithoutWorkspaceInput | LiabilityCreateOrConnectWithoutWorkspaceInput[]
    upsert?: LiabilityUpsertWithWhereUniqueWithoutWorkspaceInput | LiabilityUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: LiabilityCreateManyWorkspaceInputEnvelope
    set?: LiabilityWhereUniqueInput | LiabilityWhereUniqueInput[]
    disconnect?: LiabilityWhereUniqueInput | LiabilityWhereUniqueInput[]
    delete?: LiabilityWhereUniqueInput | LiabilityWhereUniqueInput[]
    connect?: LiabilityWhereUniqueInput | LiabilityWhereUniqueInput[]
    update?: LiabilityUpdateWithWhereUniqueWithoutWorkspaceInput | LiabilityUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: LiabilityUpdateManyWithWhereWithoutWorkspaceInput | LiabilityUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: LiabilityScalarWhereInput | LiabilityScalarWhereInput[]
  }

  export type AIInsightUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<AIInsightCreateWithoutWorkspaceInput, AIInsightUncheckedCreateWithoutWorkspaceInput> | AIInsightCreateWithoutWorkspaceInput[] | AIInsightUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AIInsightCreateOrConnectWithoutWorkspaceInput | AIInsightCreateOrConnectWithoutWorkspaceInput[]
    upsert?: AIInsightUpsertWithWhereUniqueWithoutWorkspaceInput | AIInsightUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: AIInsightCreateManyWorkspaceInputEnvelope
    set?: AIInsightWhereUniqueInput | AIInsightWhereUniqueInput[]
    disconnect?: AIInsightWhereUniqueInput | AIInsightWhereUniqueInput[]
    delete?: AIInsightWhereUniqueInput | AIInsightWhereUniqueInput[]
    connect?: AIInsightWhereUniqueInput | AIInsightWhereUniqueInput[]
    update?: AIInsightUpdateWithWhereUniqueWithoutWorkspaceInput | AIInsightUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: AIInsightUpdateManyWithWhereWithoutWorkspaceInput | AIInsightUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: AIInsightScalarWhereInput | AIInsightScalarWhereInput[]
  }

  export type ScenarioUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<ScenarioCreateWithoutWorkspaceInput, ScenarioUncheckedCreateWithoutWorkspaceInput> | ScenarioCreateWithoutWorkspaceInput[] | ScenarioUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ScenarioCreateOrConnectWithoutWorkspaceInput | ScenarioCreateOrConnectWithoutWorkspaceInput[]
    upsert?: ScenarioUpsertWithWhereUniqueWithoutWorkspaceInput | ScenarioUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: ScenarioCreateManyWorkspaceInputEnvelope
    set?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
    disconnect?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
    delete?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
    connect?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
    update?: ScenarioUpdateWithWhereUniqueWithoutWorkspaceInput | ScenarioUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: ScenarioUpdateManyWithWhereWithoutWorkspaceInput | ScenarioUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: ScenarioScalarWhereInput | ScenarioScalarWhereInput[]
  }

  export type BankConnectionUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<BankConnectionCreateWithoutWorkspaceInput, BankConnectionUncheckedCreateWithoutWorkspaceInput> | BankConnectionCreateWithoutWorkspaceInput[] | BankConnectionUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: BankConnectionCreateOrConnectWithoutWorkspaceInput | BankConnectionCreateOrConnectWithoutWorkspaceInput[]
    upsert?: BankConnectionUpsertWithWhereUniqueWithoutWorkspaceInput | BankConnectionUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: BankConnectionCreateManyWorkspaceInputEnvelope
    set?: BankConnectionWhereUniqueInput | BankConnectionWhereUniqueInput[]
    disconnect?: BankConnectionWhereUniqueInput | BankConnectionWhereUniqueInput[]
    delete?: BankConnectionWhereUniqueInput | BankConnectionWhereUniqueInput[]
    connect?: BankConnectionWhereUniqueInput | BankConnectionWhereUniqueInput[]
    update?: BankConnectionUpdateWithWhereUniqueWithoutWorkspaceInput | BankConnectionUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: BankConnectionUpdateManyWithWhereWithoutWorkspaceInput | BankConnectionUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: BankConnectionScalarWhereInput | BankConnectionScalarWhereInput[]
  }

  export type AutoRuleUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<AutoRuleCreateWithoutWorkspaceInput, AutoRuleUncheckedCreateWithoutWorkspaceInput> | AutoRuleCreateWithoutWorkspaceInput[] | AutoRuleUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AutoRuleCreateOrConnectWithoutWorkspaceInput | AutoRuleCreateOrConnectWithoutWorkspaceInput[]
    upsert?: AutoRuleUpsertWithWhereUniqueWithoutWorkspaceInput | AutoRuleUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: AutoRuleCreateManyWorkspaceInputEnvelope
    set?: AutoRuleWhereUniqueInput | AutoRuleWhereUniqueInput[]
    disconnect?: AutoRuleWhereUniqueInput | AutoRuleWhereUniqueInput[]
    delete?: AutoRuleWhereUniqueInput | AutoRuleWhereUniqueInput[]
    connect?: AutoRuleWhereUniqueInput | AutoRuleWhereUniqueInput[]
    update?: AutoRuleUpdateWithWhereUniqueWithoutWorkspaceInput | AutoRuleUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: AutoRuleUpdateManyWithWhereWithoutWorkspaceInput | AutoRuleUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: AutoRuleScalarWhereInput | AutoRuleScalarWhereInput[]
  }

  export type CashFlowProjectionUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<CashFlowProjectionCreateWithoutWorkspaceInput, CashFlowProjectionUncheckedCreateWithoutWorkspaceInput> | CashFlowProjectionCreateWithoutWorkspaceInput[] | CashFlowProjectionUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: CashFlowProjectionCreateOrConnectWithoutWorkspaceInput | CashFlowProjectionCreateOrConnectWithoutWorkspaceInput[]
    upsert?: CashFlowProjectionUpsertWithWhereUniqueWithoutWorkspaceInput | CashFlowProjectionUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: CashFlowProjectionCreateManyWorkspaceInputEnvelope
    set?: CashFlowProjectionWhereUniqueInput | CashFlowProjectionWhereUniqueInput[]
    disconnect?: CashFlowProjectionWhereUniqueInput | CashFlowProjectionWhereUniqueInput[]
    delete?: CashFlowProjectionWhereUniqueInput | CashFlowProjectionWhereUniqueInput[]
    connect?: CashFlowProjectionWhereUniqueInput | CashFlowProjectionWhereUniqueInput[]
    update?: CashFlowProjectionUpdateWithWhereUniqueWithoutWorkspaceInput | CashFlowProjectionUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: CashFlowProjectionUpdateManyWithWhereWithoutWorkspaceInput | CashFlowProjectionUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: CashFlowProjectionScalarWhereInput | CashFlowProjectionScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<TransactionCreateWithoutWorkspaceInput, TransactionUncheckedCreateWithoutWorkspaceInput> | TransactionCreateWithoutWorkspaceInput[] | TransactionUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutWorkspaceInput | TransactionCreateOrConnectWithoutWorkspaceInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutWorkspaceInput | TransactionUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: TransactionCreateManyWorkspaceInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutWorkspaceInput | TransactionUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutWorkspaceInput | TransactionUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type WorkspaceMemberUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<WorkspaceMemberCreateWithoutWorkspaceInput, WorkspaceMemberUncheckedCreateWithoutWorkspaceInput> | WorkspaceMemberCreateWithoutWorkspaceInput[] | WorkspaceMemberUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceMemberCreateOrConnectWithoutWorkspaceInput | WorkspaceMemberCreateOrConnectWithoutWorkspaceInput[]
    upsert?: WorkspaceMemberUpsertWithWhereUniqueWithoutWorkspaceInput | WorkspaceMemberUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: WorkspaceMemberCreateManyWorkspaceInputEnvelope
    set?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
    disconnect?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
    delete?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
    connect?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
    update?: WorkspaceMemberUpdateWithWhereUniqueWithoutWorkspaceInput | WorkspaceMemberUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: WorkspaceMemberUpdateManyWithWhereWithoutWorkspaceInput | WorkspaceMemberUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: WorkspaceMemberScalarWhereInput | WorkspaceMemberScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<AccountCreateWithoutWorkspaceInput, AccountUncheckedCreateWithoutWorkspaceInput> | AccountCreateWithoutWorkspaceInput[] | AccountUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutWorkspaceInput | AccountCreateOrConnectWithoutWorkspaceInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutWorkspaceInput | AccountUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: AccountCreateManyWorkspaceInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutWorkspaceInput | AccountUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutWorkspaceInput | AccountUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type CategoryUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<CategoryCreateWithoutWorkspaceInput, CategoryUncheckedCreateWithoutWorkspaceInput> | CategoryCreateWithoutWorkspaceInput[] | CategoryUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutWorkspaceInput | CategoryCreateOrConnectWithoutWorkspaceInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutWorkspaceInput | CategoryUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: CategoryCreateManyWorkspaceInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutWorkspaceInput | CategoryUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutWorkspaceInput | CategoryUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type GoalUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<GoalCreateWithoutWorkspaceInput, GoalUncheckedCreateWithoutWorkspaceInput> | GoalCreateWithoutWorkspaceInput[] | GoalUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: GoalCreateOrConnectWithoutWorkspaceInput | GoalCreateOrConnectWithoutWorkspaceInput[]
    upsert?: GoalUpsertWithWhereUniqueWithoutWorkspaceInput | GoalUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: GoalCreateManyWorkspaceInputEnvelope
    set?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    disconnect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    delete?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    connect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    update?: GoalUpdateWithWhereUniqueWithoutWorkspaceInput | GoalUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: GoalUpdateManyWithWhereWithoutWorkspaceInput | GoalUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: GoalScalarWhereInput | GoalScalarWhereInput[]
  }

  export type BudgetUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<BudgetCreateWithoutWorkspaceInput, BudgetUncheckedCreateWithoutWorkspaceInput> | BudgetCreateWithoutWorkspaceInput[] | BudgetUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutWorkspaceInput | BudgetCreateOrConnectWithoutWorkspaceInput[]
    upsert?: BudgetUpsertWithWhereUniqueWithoutWorkspaceInput | BudgetUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: BudgetCreateManyWorkspaceInputEnvelope
    set?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    disconnect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    delete?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    update?: BudgetUpdateWithWhereUniqueWithoutWorkspaceInput | BudgetUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: BudgetUpdateManyWithWhereWithoutWorkspaceInput | BudgetUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: BudgetScalarWhereInput | BudgetScalarWhereInput[]
  }

  export type ImportJobUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<ImportJobCreateWithoutWorkspaceInput, ImportJobUncheckedCreateWithoutWorkspaceInput> | ImportJobCreateWithoutWorkspaceInput[] | ImportJobUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ImportJobCreateOrConnectWithoutWorkspaceInput | ImportJobCreateOrConnectWithoutWorkspaceInput[]
    upsert?: ImportJobUpsertWithWhereUniqueWithoutWorkspaceInput | ImportJobUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: ImportJobCreateManyWorkspaceInputEnvelope
    set?: ImportJobWhereUniqueInput | ImportJobWhereUniqueInput[]
    disconnect?: ImportJobWhereUniqueInput | ImportJobWhereUniqueInput[]
    delete?: ImportJobWhereUniqueInput | ImportJobWhereUniqueInput[]
    connect?: ImportJobWhereUniqueInput | ImportJobWhereUniqueInput[]
    update?: ImportJobUpdateWithWhereUniqueWithoutWorkspaceInput | ImportJobUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: ImportJobUpdateManyWithWhereWithoutWorkspaceInput | ImportJobUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: ImportJobScalarWhereInput | ImportJobScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<AuditLogCreateWithoutWorkspaceInput, AuditLogUncheckedCreateWithoutWorkspaceInput> | AuditLogCreateWithoutWorkspaceInput[] | AuditLogUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutWorkspaceInput | AuditLogCreateOrConnectWithoutWorkspaceInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutWorkspaceInput | AuditLogUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: AuditLogCreateManyWorkspaceInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutWorkspaceInput | AuditLogUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutWorkspaceInput | AuditLogUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type EnvelopeUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<EnvelopeCreateWithoutWorkspaceInput, EnvelopeUncheckedCreateWithoutWorkspaceInput> | EnvelopeCreateWithoutWorkspaceInput[] | EnvelopeUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: EnvelopeCreateOrConnectWithoutWorkspaceInput | EnvelopeCreateOrConnectWithoutWorkspaceInput[]
    upsert?: EnvelopeUpsertWithWhereUniqueWithoutWorkspaceInput | EnvelopeUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: EnvelopeCreateManyWorkspaceInputEnvelope
    set?: EnvelopeWhereUniqueInput | EnvelopeWhereUniqueInput[]
    disconnect?: EnvelopeWhereUniqueInput | EnvelopeWhereUniqueInput[]
    delete?: EnvelopeWhereUniqueInput | EnvelopeWhereUniqueInput[]
    connect?: EnvelopeWhereUniqueInput | EnvelopeWhereUniqueInput[]
    update?: EnvelopeUpdateWithWhereUniqueWithoutWorkspaceInput | EnvelopeUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: EnvelopeUpdateManyWithWhereWithoutWorkspaceInput | EnvelopeUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: EnvelopeScalarWhereInput | EnvelopeScalarWhereInput[]
  }

  export type AssetUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<AssetCreateWithoutWorkspaceInput, AssetUncheckedCreateWithoutWorkspaceInput> | AssetCreateWithoutWorkspaceInput[] | AssetUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutWorkspaceInput | AssetCreateOrConnectWithoutWorkspaceInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutWorkspaceInput | AssetUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: AssetCreateManyWorkspaceInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutWorkspaceInput | AssetUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutWorkspaceInput | AssetUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type LiabilityUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<LiabilityCreateWithoutWorkspaceInput, LiabilityUncheckedCreateWithoutWorkspaceInput> | LiabilityCreateWithoutWorkspaceInput[] | LiabilityUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: LiabilityCreateOrConnectWithoutWorkspaceInput | LiabilityCreateOrConnectWithoutWorkspaceInput[]
    upsert?: LiabilityUpsertWithWhereUniqueWithoutWorkspaceInput | LiabilityUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: LiabilityCreateManyWorkspaceInputEnvelope
    set?: LiabilityWhereUniqueInput | LiabilityWhereUniqueInput[]
    disconnect?: LiabilityWhereUniqueInput | LiabilityWhereUniqueInput[]
    delete?: LiabilityWhereUniqueInput | LiabilityWhereUniqueInput[]
    connect?: LiabilityWhereUniqueInput | LiabilityWhereUniqueInput[]
    update?: LiabilityUpdateWithWhereUniqueWithoutWorkspaceInput | LiabilityUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: LiabilityUpdateManyWithWhereWithoutWorkspaceInput | LiabilityUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: LiabilityScalarWhereInput | LiabilityScalarWhereInput[]
  }

  export type AIInsightUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<AIInsightCreateWithoutWorkspaceInput, AIInsightUncheckedCreateWithoutWorkspaceInput> | AIInsightCreateWithoutWorkspaceInput[] | AIInsightUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AIInsightCreateOrConnectWithoutWorkspaceInput | AIInsightCreateOrConnectWithoutWorkspaceInput[]
    upsert?: AIInsightUpsertWithWhereUniqueWithoutWorkspaceInput | AIInsightUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: AIInsightCreateManyWorkspaceInputEnvelope
    set?: AIInsightWhereUniqueInput | AIInsightWhereUniqueInput[]
    disconnect?: AIInsightWhereUniqueInput | AIInsightWhereUniqueInput[]
    delete?: AIInsightWhereUniqueInput | AIInsightWhereUniqueInput[]
    connect?: AIInsightWhereUniqueInput | AIInsightWhereUniqueInput[]
    update?: AIInsightUpdateWithWhereUniqueWithoutWorkspaceInput | AIInsightUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: AIInsightUpdateManyWithWhereWithoutWorkspaceInput | AIInsightUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: AIInsightScalarWhereInput | AIInsightScalarWhereInput[]
  }

  export type ScenarioUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<ScenarioCreateWithoutWorkspaceInput, ScenarioUncheckedCreateWithoutWorkspaceInput> | ScenarioCreateWithoutWorkspaceInput[] | ScenarioUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ScenarioCreateOrConnectWithoutWorkspaceInput | ScenarioCreateOrConnectWithoutWorkspaceInput[]
    upsert?: ScenarioUpsertWithWhereUniqueWithoutWorkspaceInput | ScenarioUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: ScenarioCreateManyWorkspaceInputEnvelope
    set?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
    disconnect?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
    delete?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
    connect?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
    update?: ScenarioUpdateWithWhereUniqueWithoutWorkspaceInput | ScenarioUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: ScenarioUpdateManyWithWhereWithoutWorkspaceInput | ScenarioUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: ScenarioScalarWhereInput | ScenarioScalarWhereInput[]
  }

  export type BankConnectionUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<BankConnectionCreateWithoutWorkspaceInput, BankConnectionUncheckedCreateWithoutWorkspaceInput> | BankConnectionCreateWithoutWorkspaceInput[] | BankConnectionUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: BankConnectionCreateOrConnectWithoutWorkspaceInput | BankConnectionCreateOrConnectWithoutWorkspaceInput[]
    upsert?: BankConnectionUpsertWithWhereUniqueWithoutWorkspaceInput | BankConnectionUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: BankConnectionCreateManyWorkspaceInputEnvelope
    set?: BankConnectionWhereUniqueInput | BankConnectionWhereUniqueInput[]
    disconnect?: BankConnectionWhereUniqueInput | BankConnectionWhereUniqueInput[]
    delete?: BankConnectionWhereUniqueInput | BankConnectionWhereUniqueInput[]
    connect?: BankConnectionWhereUniqueInput | BankConnectionWhereUniqueInput[]
    update?: BankConnectionUpdateWithWhereUniqueWithoutWorkspaceInput | BankConnectionUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: BankConnectionUpdateManyWithWhereWithoutWorkspaceInput | BankConnectionUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: BankConnectionScalarWhereInput | BankConnectionScalarWhereInput[]
  }

  export type AutoRuleUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<AutoRuleCreateWithoutWorkspaceInput, AutoRuleUncheckedCreateWithoutWorkspaceInput> | AutoRuleCreateWithoutWorkspaceInput[] | AutoRuleUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AutoRuleCreateOrConnectWithoutWorkspaceInput | AutoRuleCreateOrConnectWithoutWorkspaceInput[]
    upsert?: AutoRuleUpsertWithWhereUniqueWithoutWorkspaceInput | AutoRuleUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: AutoRuleCreateManyWorkspaceInputEnvelope
    set?: AutoRuleWhereUniqueInput | AutoRuleWhereUniqueInput[]
    disconnect?: AutoRuleWhereUniqueInput | AutoRuleWhereUniqueInput[]
    delete?: AutoRuleWhereUniqueInput | AutoRuleWhereUniqueInput[]
    connect?: AutoRuleWhereUniqueInput | AutoRuleWhereUniqueInput[]
    update?: AutoRuleUpdateWithWhereUniqueWithoutWorkspaceInput | AutoRuleUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: AutoRuleUpdateManyWithWhereWithoutWorkspaceInput | AutoRuleUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: AutoRuleScalarWhereInput | AutoRuleScalarWhereInput[]
  }

  export type CashFlowProjectionUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<CashFlowProjectionCreateWithoutWorkspaceInput, CashFlowProjectionUncheckedCreateWithoutWorkspaceInput> | CashFlowProjectionCreateWithoutWorkspaceInput[] | CashFlowProjectionUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: CashFlowProjectionCreateOrConnectWithoutWorkspaceInput | CashFlowProjectionCreateOrConnectWithoutWorkspaceInput[]
    upsert?: CashFlowProjectionUpsertWithWhereUniqueWithoutWorkspaceInput | CashFlowProjectionUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: CashFlowProjectionCreateManyWorkspaceInputEnvelope
    set?: CashFlowProjectionWhereUniqueInput | CashFlowProjectionWhereUniqueInput[]
    disconnect?: CashFlowProjectionWhereUniqueInput | CashFlowProjectionWhereUniqueInput[]
    delete?: CashFlowProjectionWhereUniqueInput | CashFlowProjectionWhereUniqueInput[]
    connect?: CashFlowProjectionWhereUniqueInput | CashFlowProjectionWhereUniqueInput[]
    update?: CashFlowProjectionUpdateWithWhereUniqueWithoutWorkspaceInput | CashFlowProjectionUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: CashFlowProjectionUpdateManyWithWhereWithoutWorkspaceInput | CashFlowProjectionUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: CashFlowProjectionScalarWhereInput | CashFlowProjectionScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<TransactionCreateWithoutWorkspaceInput, TransactionUncheckedCreateWithoutWorkspaceInput> | TransactionCreateWithoutWorkspaceInput[] | TransactionUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutWorkspaceInput | TransactionCreateOrConnectWithoutWorkspaceInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutWorkspaceInput | TransactionUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: TransactionCreateManyWorkspaceInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutWorkspaceInput | TransactionUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutWorkspaceInput | TransactionUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type WorkspaceCreateNestedOneWithoutMembersInput = {
    create?: XOR<WorkspaceCreateWithoutMembersInput, WorkspaceUncheckedCreateWithoutMembersInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutMembersInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutWorkspacesInput = {
    create?: XOR<UserCreateWithoutWorkspacesInput, UserUncheckedCreateWithoutWorkspacesInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkspacesInput
    connect?: UserWhereUniqueInput
  }

  export type WorkspaceUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<WorkspaceCreateWithoutMembersInput, WorkspaceUncheckedCreateWithoutMembersInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutMembersInput
    upsert?: WorkspaceUpsertWithoutMembersInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutMembersInput, WorkspaceUpdateWithoutMembersInput>, WorkspaceUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutWorkspacesNestedInput = {
    create?: XOR<UserCreateWithoutWorkspacesInput, UserUncheckedCreateWithoutWorkspacesInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkspacesInput
    upsert?: UserUpsertWithoutWorkspacesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWorkspacesInput, UserUpdateWithoutWorkspacesInput>, UserUncheckedUpdateWithoutWorkspacesInput>
  }

  export type WorkspaceCreateNestedOneWithoutAccountsInput = {
    create?: XOR<WorkspaceCreateWithoutAccountsInput, WorkspaceUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutAccountsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type TransactionCreateNestedManyWithoutAccountInput = {
    create?: XOR<TransactionCreateWithoutAccountInput, TransactionUncheckedCreateWithoutAccountInput> | TransactionCreateWithoutAccountInput[] | TransactionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutAccountInput | TransactionCreateOrConnectWithoutAccountInput[]
    createMany?: TransactionCreateManyAccountInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransferCreateNestedManyWithoutFromAccountInput = {
    create?: XOR<TransferCreateWithoutFromAccountInput, TransferUncheckedCreateWithoutFromAccountInput> | TransferCreateWithoutFromAccountInput[] | TransferUncheckedCreateWithoutFromAccountInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutFromAccountInput | TransferCreateOrConnectWithoutFromAccountInput[]
    createMany?: TransferCreateManyFromAccountInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type TransferCreateNestedManyWithoutToAccountInput = {
    create?: XOR<TransferCreateWithoutToAccountInput, TransferUncheckedCreateWithoutToAccountInput> | TransferCreateWithoutToAccountInput[] | TransferUncheckedCreateWithoutToAccountInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutToAccountInput | TransferCreateOrConnectWithoutToAccountInput[]
    createMany?: TransferCreateManyToAccountInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type BankConnectionCreateNestedManyWithoutAccountInput = {
    create?: XOR<BankConnectionCreateWithoutAccountInput, BankConnectionUncheckedCreateWithoutAccountInput> | BankConnectionCreateWithoutAccountInput[] | BankConnectionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: BankConnectionCreateOrConnectWithoutAccountInput | BankConnectionCreateOrConnectWithoutAccountInput[]
    createMany?: BankConnectionCreateManyAccountInputEnvelope
    connect?: BankConnectionWhereUniqueInput | BankConnectionWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<TransactionCreateWithoutAccountInput, TransactionUncheckedCreateWithoutAccountInput> | TransactionCreateWithoutAccountInput[] | TransactionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutAccountInput | TransactionCreateOrConnectWithoutAccountInput[]
    createMany?: TransactionCreateManyAccountInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransferUncheckedCreateNestedManyWithoutFromAccountInput = {
    create?: XOR<TransferCreateWithoutFromAccountInput, TransferUncheckedCreateWithoutFromAccountInput> | TransferCreateWithoutFromAccountInput[] | TransferUncheckedCreateWithoutFromAccountInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutFromAccountInput | TransferCreateOrConnectWithoutFromAccountInput[]
    createMany?: TransferCreateManyFromAccountInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type TransferUncheckedCreateNestedManyWithoutToAccountInput = {
    create?: XOR<TransferCreateWithoutToAccountInput, TransferUncheckedCreateWithoutToAccountInput> | TransferCreateWithoutToAccountInput[] | TransferUncheckedCreateWithoutToAccountInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutToAccountInput | TransferCreateOrConnectWithoutToAccountInput[]
    createMany?: TransferCreateManyToAccountInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type BankConnectionUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<BankConnectionCreateWithoutAccountInput, BankConnectionUncheckedCreateWithoutAccountInput> | BankConnectionCreateWithoutAccountInput[] | BankConnectionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: BankConnectionCreateOrConnectWithoutAccountInput | BankConnectionCreateOrConnectWithoutAccountInput[]
    createMany?: BankConnectionCreateManyAccountInputEnvelope
    connect?: BankConnectionWhereUniqueInput | BankConnectionWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type WorkspaceUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutAccountsInput, WorkspaceUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutAccountsInput
    upsert?: WorkspaceUpsertWithoutAccountsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutAccountsInput, WorkspaceUpdateWithoutAccountsInput>, WorkspaceUncheckedUpdateWithoutAccountsInput>
  }

  export type TransactionUpdateManyWithoutAccountNestedInput = {
    create?: XOR<TransactionCreateWithoutAccountInput, TransactionUncheckedCreateWithoutAccountInput> | TransactionCreateWithoutAccountInput[] | TransactionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutAccountInput | TransactionCreateOrConnectWithoutAccountInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutAccountInput | TransactionUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: TransactionCreateManyAccountInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutAccountInput | TransactionUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutAccountInput | TransactionUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TransferUpdateManyWithoutFromAccountNestedInput = {
    create?: XOR<TransferCreateWithoutFromAccountInput, TransferUncheckedCreateWithoutFromAccountInput> | TransferCreateWithoutFromAccountInput[] | TransferUncheckedCreateWithoutFromAccountInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutFromAccountInput | TransferCreateOrConnectWithoutFromAccountInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutFromAccountInput | TransferUpsertWithWhereUniqueWithoutFromAccountInput[]
    createMany?: TransferCreateManyFromAccountInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutFromAccountInput | TransferUpdateWithWhereUniqueWithoutFromAccountInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutFromAccountInput | TransferUpdateManyWithWhereWithoutFromAccountInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type TransferUpdateManyWithoutToAccountNestedInput = {
    create?: XOR<TransferCreateWithoutToAccountInput, TransferUncheckedCreateWithoutToAccountInput> | TransferCreateWithoutToAccountInput[] | TransferUncheckedCreateWithoutToAccountInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutToAccountInput | TransferCreateOrConnectWithoutToAccountInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutToAccountInput | TransferUpsertWithWhereUniqueWithoutToAccountInput[]
    createMany?: TransferCreateManyToAccountInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutToAccountInput | TransferUpdateWithWhereUniqueWithoutToAccountInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutToAccountInput | TransferUpdateManyWithWhereWithoutToAccountInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type BankConnectionUpdateManyWithoutAccountNestedInput = {
    create?: XOR<BankConnectionCreateWithoutAccountInput, BankConnectionUncheckedCreateWithoutAccountInput> | BankConnectionCreateWithoutAccountInput[] | BankConnectionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: BankConnectionCreateOrConnectWithoutAccountInput | BankConnectionCreateOrConnectWithoutAccountInput[]
    upsert?: BankConnectionUpsertWithWhereUniqueWithoutAccountInput | BankConnectionUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: BankConnectionCreateManyAccountInputEnvelope
    set?: BankConnectionWhereUniqueInput | BankConnectionWhereUniqueInput[]
    disconnect?: BankConnectionWhereUniqueInput | BankConnectionWhereUniqueInput[]
    delete?: BankConnectionWhereUniqueInput | BankConnectionWhereUniqueInput[]
    connect?: BankConnectionWhereUniqueInput | BankConnectionWhereUniqueInput[]
    update?: BankConnectionUpdateWithWhereUniqueWithoutAccountInput | BankConnectionUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: BankConnectionUpdateManyWithWhereWithoutAccountInput | BankConnectionUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: BankConnectionScalarWhereInput | BankConnectionScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<TransactionCreateWithoutAccountInput, TransactionUncheckedCreateWithoutAccountInput> | TransactionCreateWithoutAccountInput[] | TransactionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutAccountInput | TransactionCreateOrConnectWithoutAccountInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutAccountInput | TransactionUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: TransactionCreateManyAccountInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutAccountInput | TransactionUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutAccountInput | TransactionUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TransferUncheckedUpdateManyWithoutFromAccountNestedInput = {
    create?: XOR<TransferCreateWithoutFromAccountInput, TransferUncheckedCreateWithoutFromAccountInput> | TransferCreateWithoutFromAccountInput[] | TransferUncheckedCreateWithoutFromAccountInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutFromAccountInput | TransferCreateOrConnectWithoutFromAccountInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutFromAccountInput | TransferUpsertWithWhereUniqueWithoutFromAccountInput[]
    createMany?: TransferCreateManyFromAccountInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutFromAccountInput | TransferUpdateWithWhereUniqueWithoutFromAccountInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutFromAccountInput | TransferUpdateManyWithWhereWithoutFromAccountInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type TransferUncheckedUpdateManyWithoutToAccountNestedInput = {
    create?: XOR<TransferCreateWithoutToAccountInput, TransferUncheckedCreateWithoutToAccountInput> | TransferCreateWithoutToAccountInput[] | TransferUncheckedCreateWithoutToAccountInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutToAccountInput | TransferCreateOrConnectWithoutToAccountInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutToAccountInput | TransferUpsertWithWhereUniqueWithoutToAccountInput[]
    createMany?: TransferCreateManyToAccountInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutToAccountInput | TransferUpdateWithWhereUniqueWithoutToAccountInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutToAccountInput | TransferUpdateManyWithWhereWithoutToAccountInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type BankConnectionUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<BankConnectionCreateWithoutAccountInput, BankConnectionUncheckedCreateWithoutAccountInput> | BankConnectionCreateWithoutAccountInput[] | BankConnectionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: BankConnectionCreateOrConnectWithoutAccountInput | BankConnectionCreateOrConnectWithoutAccountInput[]
    upsert?: BankConnectionUpsertWithWhereUniqueWithoutAccountInput | BankConnectionUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: BankConnectionCreateManyAccountInputEnvelope
    set?: BankConnectionWhereUniqueInput | BankConnectionWhereUniqueInput[]
    disconnect?: BankConnectionWhereUniqueInput | BankConnectionWhereUniqueInput[]
    delete?: BankConnectionWhereUniqueInput | BankConnectionWhereUniqueInput[]
    connect?: BankConnectionWhereUniqueInput | BankConnectionWhereUniqueInput[]
    update?: BankConnectionUpdateWithWhereUniqueWithoutAccountInput | BankConnectionUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: BankConnectionUpdateManyWithWhereWithoutAccountInput | BankConnectionUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: BankConnectionScalarWhereInput | BankConnectionScalarWhereInput[]
  }

  export type WorkspaceCreateNestedOneWithoutCategoriesInput = {
    create?: XOR<WorkspaceCreateWithoutCategoriesInput, WorkspaceUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutCategoriesInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutChildrenInput = {
    create?: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutChildrenInput
    connect?: CategoryWhereUniqueInput
  }

  export type CategoryCreateNestedManyWithoutParentInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutCategoryInput = {
    create?: XOR<TransactionCreateWithoutCategoryInput, TransactionUncheckedCreateWithoutCategoryInput> | TransactionCreateWithoutCategoryInput[] | TransactionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCategoryInput | TransactionCreateOrConnectWithoutCategoryInput[]
    createMany?: TransactionCreateManyCategoryInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type BudgetCategoryCreateNestedManyWithoutCategoryInput = {
    create?: XOR<BudgetCategoryCreateWithoutCategoryInput, BudgetCategoryUncheckedCreateWithoutCategoryInput> | BudgetCategoryCreateWithoutCategoryInput[] | BudgetCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: BudgetCategoryCreateOrConnectWithoutCategoryInput | BudgetCategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: BudgetCategoryCreateManyCategoryInputEnvelope
    connect?: BudgetCategoryWhereUniqueInput | BudgetCategoryWhereUniqueInput[]
  }

  export type EnvelopeCreateNestedManyWithoutCategoryInput = {
    create?: XOR<EnvelopeCreateWithoutCategoryInput, EnvelopeUncheckedCreateWithoutCategoryInput> | EnvelopeCreateWithoutCategoryInput[] | EnvelopeUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: EnvelopeCreateOrConnectWithoutCategoryInput | EnvelopeCreateOrConnectWithoutCategoryInput[]
    createMany?: EnvelopeCreateManyCategoryInputEnvelope
    connect?: EnvelopeWhereUniqueInput | EnvelopeWhereUniqueInput[]
  }

  export type CategoryUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<TransactionCreateWithoutCategoryInput, TransactionUncheckedCreateWithoutCategoryInput> | TransactionCreateWithoutCategoryInput[] | TransactionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCategoryInput | TransactionCreateOrConnectWithoutCategoryInput[]
    createMany?: TransactionCreateManyCategoryInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type BudgetCategoryUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<BudgetCategoryCreateWithoutCategoryInput, BudgetCategoryUncheckedCreateWithoutCategoryInput> | BudgetCategoryCreateWithoutCategoryInput[] | BudgetCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: BudgetCategoryCreateOrConnectWithoutCategoryInput | BudgetCategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: BudgetCategoryCreateManyCategoryInputEnvelope
    connect?: BudgetCategoryWhereUniqueInput | BudgetCategoryWhereUniqueInput[]
  }

  export type EnvelopeUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<EnvelopeCreateWithoutCategoryInput, EnvelopeUncheckedCreateWithoutCategoryInput> | EnvelopeCreateWithoutCategoryInput[] | EnvelopeUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: EnvelopeCreateOrConnectWithoutCategoryInput | EnvelopeCreateOrConnectWithoutCategoryInput[]
    createMany?: EnvelopeCreateManyCategoryInputEnvelope
    connect?: EnvelopeWhereUniqueInput | EnvelopeWhereUniqueInput[]
  }

  export type WorkspaceUpdateOneRequiredWithoutCategoriesNestedInput = {
    create?: XOR<WorkspaceCreateWithoutCategoriesInput, WorkspaceUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutCategoriesInput
    upsert?: WorkspaceUpsertWithoutCategoriesInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutCategoriesInput, WorkspaceUpdateWithoutCategoriesInput>, WorkspaceUncheckedUpdateWithoutCategoriesInput>
  }

  export type CategoryUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutChildrenInput
    upsert?: CategoryUpsertWithoutChildrenInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutChildrenInput, CategoryUpdateWithoutChildrenInput>, CategoryUncheckedUpdateWithoutChildrenInput>
  }

  export type CategoryUpdateManyWithoutParentNestedInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutParentInput | CategoryUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutParentInput | CategoryUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutParentInput | CategoryUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<TransactionCreateWithoutCategoryInput, TransactionUncheckedCreateWithoutCategoryInput> | TransactionCreateWithoutCategoryInput[] | TransactionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCategoryInput | TransactionCreateOrConnectWithoutCategoryInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutCategoryInput | TransactionUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: TransactionCreateManyCategoryInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutCategoryInput | TransactionUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutCategoryInput | TransactionUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type BudgetCategoryUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<BudgetCategoryCreateWithoutCategoryInput, BudgetCategoryUncheckedCreateWithoutCategoryInput> | BudgetCategoryCreateWithoutCategoryInput[] | BudgetCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: BudgetCategoryCreateOrConnectWithoutCategoryInput | BudgetCategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: BudgetCategoryUpsertWithWhereUniqueWithoutCategoryInput | BudgetCategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: BudgetCategoryCreateManyCategoryInputEnvelope
    set?: BudgetCategoryWhereUniqueInput | BudgetCategoryWhereUniqueInput[]
    disconnect?: BudgetCategoryWhereUniqueInput | BudgetCategoryWhereUniqueInput[]
    delete?: BudgetCategoryWhereUniqueInput | BudgetCategoryWhereUniqueInput[]
    connect?: BudgetCategoryWhereUniqueInput | BudgetCategoryWhereUniqueInput[]
    update?: BudgetCategoryUpdateWithWhereUniqueWithoutCategoryInput | BudgetCategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: BudgetCategoryUpdateManyWithWhereWithoutCategoryInput | BudgetCategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: BudgetCategoryScalarWhereInput | BudgetCategoryScalarWhereInput[]
  }

  export type EnvelopeUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<EnvelopeCreateWithoutCategoryInput, EnvelopeUncheckedCreateWithoutCategoryInput> | EnvelopeCreateWithoutCategoryInput[] | EnvelopeUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: EnvelopeCreateOrConnectWithoutCategoryInput | EnvelopeCreateOrConnectWithoutCategoryInput[]
    upsert?: EnvelopeUpsertWithWhereUniqueWithoutCategoryInput | EnvelopeUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: EnvelopeCreateManyCategoryInputEnvelope
    set?: EnvelopeWhereUniqueInput | EnvelopeWhereUniqueInput[]
    disconnect?: EnvelopeWhereUniqueInput | EnvelopeWhereUniqueInput[]
    delete?: EnvelopeWhereUniqueInput | EnvelopeWhereUniqueInput[]
    connect?: EnvelopeWhereUniqueInput | EnvelopeWhereUniqueInput[]
    update?: EnvelopeUpdateWithWhereUniqueWithoutCategoryInput | EnvelopeUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: EnvelopeUpdateManyWithWhereWithoutCategoryInput | EnvelopeUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: EnvelopeScalarWhereInput | EnvelopeScalarWhereInput[]
  }

  export type CategoryUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutParentInput | CategoryUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutParentInput | CategoryUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutParentInput | CategoryUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<TransactionCreateWithoutCategoryInput, TransactionUncheckedCreateWithoutCategoryInput> | TransactionCreateWithoutCategoryInput[] | TransactionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCategoryInput | TransactionCreateOrConnectWithoutCategoryInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutCategoryInput | TransactionUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: TransactionCreateManyCategoryInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutCategoryInput | TransactionUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutCategoryInput | TransactionUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type BudgetCategoryUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<BudgetCategoryCreateWithoutCategoryInput, BudgetCategoryUncheckedCreateWithoutCategoryInput> | BudgetCategoryCreateWithoutCategoryInput[] | BudgetCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: BudgetCategoryCreateOrConnectWithoutCategoryInput | BudgetCategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: BudgetCategoryUpsertWithWhereUniqueWithoutCategoryInput | BudgetCategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: BudgetCategoryCreateManyCategoryInputEnvelope
    set?: BudgetCategoryWhereUniqueInput | BudgetCategoryWhereUniqueInput[]
    disconnect?: BudgetCategoryWhereUniqueInput | BudgetCategoryWhereUniqueInput[]
    delete?: BudgetCategoryWhereUniqueInput | BudgetCategoryWhereUniqueInput[]
    connect?: BudgetCategoryWhereUniqueInput | BudgetCategoryWhereUniqueInput[]
    update?: BudgetCategoryUpdateWithWhereUniqueWithoutCategoryInput | BudgetCategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: BudgetCategoryUpdateManyWithWhereWithoutCategoryInput | BudgetCategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: BudgetCategoryScalarWhereInput | BudgetCategoryScalarWhereInput[]
  }

  export type EnvelopeUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<EnvelopeCreateWithoutCategoryInput, EnvelopeUncheckedCreateWithoutCategoryInput> | EnvelopeCreateWithoutCategoryInput[] | EnvelopeUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: EnvelopeCreateOrConnectWithoutCategoryInput | EnvelopeCreateOrConnectWithoutCategoryInput[]
    upsert?: EnvelopeUpsertWithWhereUniqueWithoutCategoryInput | EnvelopeUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: EnvelopeCreateManyCategoryInputEnvelope
    set?: EnvelopeWhereUniqueInput | EnvelopeWhereUniqueInput[]
    disconnect?: EnvelopeWhereUniqueInput | EnvelopeWhereUniqueInput[]
    delete?: EnvelopeWhereUniqueInput | EnvelopeWhereUniqueInput[]
    connect?: EnvelopeWhereUniqueInput | EnvelopeWhereUniqueInput[]
    update?: EnvelopeUpdateWithWhereUniqueWithoutCategoryInput | EnvelopeUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: EnvelopeUpdateManyWithWhereWithoutCategoryInput | EnvelopeUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: EnvelopeScalarWhereInput | EnvelopeScalarWhereInput[]
  }

  export type WorkspaceCreateNestedOneWithoutTransactionInput = {
    create?: XOR<WorkspaceCreateWithoutTransactionInput, WorkspaceUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutTransactionInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<AccountCreateWithoutTransactionsInput, AccountUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutTransactionsInput
    connect?: AccountWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<CategoryCreateWithoutTransactionsInput, CategoryUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutTransactionsInput
    connect?: CategoryWhereUniqueInput
  }

  export type WorkspaceUpdateOneRequiredWithoutTransactionNestedInput = {
    create?: XOR<WorkspaceCreateWithoutTransactionInput, WorkspaceUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutTransactionInput
    upsert?: WorkspaceUpsertWithoutTransactionInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutTransactionInput, WorkspaceUpdateWithoutTransactionInput>, WorkspaceUncheckedUpdateWithoutTransactionInput>
  }

  export type AccountUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<AccountCreateWithoutTransactionsInput, AccountUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutTransactionsInput
    upsert?: AccountUpsertWithoutTransactionsInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutTransactionsInput, AccountUpdateWithoutTransactionsInput>, AccountUncheckedUpdateWithoutTransactionsInput>
  }

  export type CategoryUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<CategoryCreateWithoutTransactionsInput, CategoryUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutTransactionsInput
    upsert?: CategoryUpsertWithoutTransactionsInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutTransactionsInput, CategoryUpdateWithoutTransactionsInput>, CategoryUncheckedUpdateWithoutTransactionsInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AccountCreateNestedOneWithoutFromTransfersInput = {
    create?: XOR<AccountCreateWithoutFromTransfersInput, AccountUncheckedCreateWithoutFromTransfersInput>
    connectOrCreate?: AccountCreateOrConnectWithoutFromTransfersInput
    connect?: AccountWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutToTransfersInput = {
    create?: XOR<AccountCreateWithoutToTransfersInput, AccountUncheckedCreateWithoutToTransfersInput>
    connectOrCreate?: AccountCreateOrConnectWithoutToTransfersInput
    connect?: AccountWhereUniqueInput
  }

  export type AccountUpdateOneRequiredWithoutFromTransfersNestedInput = {
    create?: XOR<AccountCreateWithoutFromTransfersInput, AccountUncheckedCreateWithoutFromTransfersInput>
    connectOrCreate?: AccountCreateOrConnectWithoutFromTransfersInput
    upsert?: AccountUpsertWithoutFromTransfersInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutFromTransfersInput, AccountUpdateWithoutFromTransfersInput>, AccountUncheckedUpdateWithoutFromTransfersInput>
  }

  export type AccountUpdateOneRequiredWithoutToTransfersNestedInput = {
    create?: XOR<AccountCreateWithoutToTransfersInput, AccountUncheckedCreateWithoutToTransfersInput>
    connectOrCreate?: AccountCreateOrConnectWithoutToTransfersInput
    upsert?: AccountUpsertWithoutToTransfersInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutToTransfersInput, AccountUpdateWithoutToTransfersInput>, AccountUncheckedUpdateWithoutToTransfersInput>
  }

  export type BudgetCategoryCreateNestedManyWithoutBudgetInput = {
    create?: XOR<BudgetCategoryCreateWithoutBudgetInput, BudgetCategoryUncheckedCreateWithoutBudgetInput> | BudgetCategoryCreateWithoutBudgetInput[] | BudgetCategoryUncheckedCreateWithoutBudgetInput[]
    connectOrCreate?: BudgetCategoryCreateOrConnectWithoutBudgetInput | BudgetCategoryCreateOrConnectWithoutBudgetInput[]
    createMany?: BudgetCategoryCreateManyBudgetInputEnvelope
    connect?: BudgetCategoryWhereUniqueInput | BudgetCategoryWhereUniqueInput[]
  }

  export type WorkspaceCreateNestedOneWithoutBudgetsInput = {
    create?: XOR<WorkspaceCreateWithoutBudgetsInput, WorkspaceUncheckedCreateWithoutBudgetsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutBudgetsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type BudgetCategoryUncheckedCreateNestedManyWithoutBudgetInput = {
    create?: XOR<BudgetCategoryCreateWithoutBudgetInput, BudgetCategoryUncheckedCreateWithoutBudgetInput> | BudgetCategoryCreateWithoutBudgetInput[] | BudgetCategoryUncheckedCreateWithoutBudgetInput[]
    connectOrCreate?: BudgetCategoryCreateOrConnectWithoutBudgetInput | BudgetCategoryCreateOrConnectWithoutBudgetInput[]
    createMany?: BudgetCategoryCreateManyBudgetInputEnvelope
    connect?: BudgetCategoryWhereUniqueInput | BudgetCategoryWhereUniqueInput[]
  }

  export type BudgetCategoryUpdateManyWithoutBudgetNestedInput = {
    create?: XOR<BudgetCategoryCreateWithoutBudgetInput, BudgetCategoryUncheckedCreateWithoutBudgetInput> | BudgetCategoryCreateWithoutBudgetInput[] | BudgetCategoryUncheckedCreateWithoutBudgetInput[]
    connectOrCreate?: BudgetCategoryCreateOrConnectWithoutBudgetInput | BudgetCategoryCreateOrConnectWithoutBudgetInput[]
    upsert?: BudgetCategoryUpsertWithWhereUniqueWithoutBudgetInput | BudgetCategoryUpsertWithWhereUniqueWithoutBudgetInput[]
    createMany?: BudgetCategoryCreateManyBudgetInputEnvelope
    set?: BudgetCategoryWhereUniqueInput | BudgetCategoryWhereUniqueInput[]
    disconnect?: BudgetCategoryWhereUniqueInput | BudgetCategoryWhereUniqueInput[]
    delete?: BudgetCategoryWhereUniqueInput | BudgetCategoryWhereUniqueInput[]
    connect?: BudgetCategoryWhereUniqueInput | BudgetCategoryWhereUniqueInput[]
    update?: BudgetCategoryUpdateWithWhereUniqueWithoutBudgetInput | BudgetCategoryUpdateWithWhereUniqueWithoutBudgetInput[]
    updateMany?: BudgetCategoryUpdateManyWithWhereWithoutBudgetInput | BudgetCategoryUpdateManyWithWhereWithoutBudgetInput[]
    deleteMany?: BudgetCategoryScalarWhereInput | BudgetCategoryScalarWhereInput[]
  }

  export type WorkspaceUpdateOneRequiredWithoutBudgetsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutBudgetsInput, WorkspaceUncheckedCreateWithoutBudgetsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutBudgetsInput
    upsert?: WorkspaceUpsertWithoutBudgetsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutBudgetsInput, WorkspaceUpdateWithoutBudgetsInput>, WorkspaceUncheckedUpdateWithoutBudgetsInput>
  }

  export type BudgetCategoryUncheckedUpdateManyWithoutBudgetNestedInput = {
    create?: XOR<BudgetCategoryCreateWithoutBudgetInput, BudgetCategoryUncheckedCreateWithoutBudgetInput> | BudgetCategoryCreateWithoutBudgetInput[] | BudgetCategoryUncheckedCreateWithoutBudgetInput[]
    connectOrCreate?: BudgetCategoryCreateOrConnectWithoutBudgetInput | BudgetCategoryCreateOrConnectWithoutBudgetInput[]
    upsert?: BudgetCategoryUpsertWithWhereUniqueWithoutBudgetInput | BudgetCategoryUpsertWithWhereUniqueWithoutBudgetInput[]
    createMany?: BudgetCategoryCreateManyBudgetInputEnvelope
    set?: BudgetCategoryWhereUniqueInput | BudgetCategoryWhereUniqueInput[]
    disconnect?: BudgetCategoryWhereUniqueInput | BudgetCategoryWhereUniqueInput[]
    delete?: BudgetCategoryWhereUniqueInput | BudgetCategoryWhereUniqueInput[]
    connect?: BudgetCategoryWhereUniqueInput | BudgetCategoryWhereUniqueInput[]
    update?: BudgetCategoryUpdateWithWhereUniqueWithoutBudgetInput | BudgetCategoryUpdateWithWhereUniqueWithoutBudgetInput[]
    updateMany?: BudgetCategoryUpdateManyWithWhereWithoutBudgetInput | BudgetCategoryUpdateManyWithWhereWithoutBudgetInput[]
    deleteMany?: BudgetCategoryScalarWhereInput | BudgetCategoryScalarWhereInput[]
  }

  export type BudgetCreateNestedOneWithoutCategoriesInput = {
    create?: XOR<BudgetCreateWithoutCategoriesInput, BudgetUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: BudgetCreateOrConnectWithoutCategoriesInput
    connect?: BudgetWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutBudgetsInput = {
    create?: XOR<CategoryCreateWithoutBudgetsInput, CategoryUncheckedCreateWithoutBudgetsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutBudgetsInput
    connect?: CategoryWhereUniqueInput
  }

  export type BudgetUpdateOneRequiredWithoutCategoriesNestedInput = {
    create?: XOR<BudgetCreateWithoutCategoriesInput, BudgetUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: BudgetCreateOrConnectWithoutCategoriesInput
    upsert?: BudgetUpsertWithoutCategoriesInput
    connect?: BudgetWhereUniqueInput
    update?: XOR<XOR<BudgetUpdateToOneWithWhereWithoutCategoriesInput, BudgetUpdateWithoutCategoriesInput>, BudgetUncheckedUpdateWithoutCategoriesInput>
  }

  export type CategoryUpdateOneRequiredWithoutBudgetsNestedInput = {
    create?: XOR<CategoryCreateWithoutBudgetsInput, CategoryUncheckedCreateWithoutBudgetsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutBudgetsInput
    upsert?: CategoryUpsertWithoutBudgetsInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutBudgetsInput, CategoryUpdateWithoutBudgetsInput>, CategoryUncheckedUpdateWithoutBudgetsInput>
  }

  export type GoalContributionCreateNestedManyWithoutGoalInput = {
    create?: XOR<GoalContributionCreateWithoutGoalInput, GoalContributionUncheckedCreateWithoutGoalInput> | GoalContributionCreateWithoutGoalInput[] | GoalContributionUncheckedCreateWithoutGoalInput[]
    connectOrCreate?: GoalContributionCreateOrConnectWithoutGoalInput | GoalContributionCreateOrConnectWithoutGoalInput[]
    createMany?: GoalContributionCreateManyGoalInputEnvelope
    connect?: GoalContributionWhereUniqueInput | GoalContributionWhereUniqueInput[]
  }

  export type WorkspaceCreateNestedOneWithoutGoalsInput = {
    create?: XOR<WorkspaceCreateWithoutGoalsInput, WorkspaceUncheckedCreateWithoutGoalsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutGoalsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type GoalContributionUncheckedCreateNestedManyWithoutGoalInput = {
    create?: XOR<GoalContributionCreateWithoutGoalInput, GoalContributionUncheckedCreateWithoutGoalInput> | GoalContributionCreateWithoutGoalInput[] | GoalContributionUncheckedCreateWithoutGoalInput[]
    connectOrCreate?: GoalContributionCreateOrConnectWithoutGoalInput | GoalContributionCreateOrConnectWithoutGoalInput[]
    createMany?: GoalContributionCreateManyGoalInputEnvelope
    connect?: GoalContributionWhereUniqueInput | GoalContributionWhereUniqueInput[]
  }

  export type GoalContributionUpdateManyWithoutGoalNestedInput = {
    create?: XOR<GoalContributionCreateWithoutGoalInput, GoalContributionUncheckedCreateWithoutGoalInput> | GoalContributionCreateWithoutGoalInput[] | GoalContributionUncheckedCreateWithoutGoalInput[]
    connectOrCreate?: GoalContributionCreateOrConnectWithoutGoalInput | GoalContributionCreateOrConnectWithoutGoalInput[]
    upsert?: GoalContributionUpsertWithWhereUniqueWithoutGoalInput | GoalContributionUpsertWithWhereUniqueWithoutGoalInput[]
    createMany?: GoalContributionCreateManyGoalInputEnvelope
    set?: GoalContributionWhereUniqueInput | GoalContributionWhereUniqueInput[]
    disconnect?: GoalContributionWhereUniqueInput | GoalContributionWhereUniqueInput[]
    delete?: GoalContributionWhereUniqueInput | GoalContributionWhereUniqueInput[]
    connect?: GoalContributionWhereUniqueInput | GoalContributionWhereUniqueInput[]
    update?: GoalContributionUpdateWithWhereUniqueWithoutGoalInput | GoalContributionUpdateWithWhereUniqueWithoutGoalInput[]
    updateMany?: GoalContributionUpdateManyWithWhereWithoutGoalInput | GoalContributionUpdateManyWithWhereWithoutGoalInput[]
    deleteMany?: GoalContributionScalarWhereInput | GoalContributionScalarWhereInput[]
  }

  export type WorkspaceUpdateOneRequiredWithoutGoalsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutGoalsInput, WorkspaceUncheckedCreateWithoutGoalsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutGoalsInput
    upsert?: WorkspaceUpsertWithoutGoalsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutGoalsInput, WorkspaceUpdateWithoutGoalsInput>, WorkspaceUncheckedUpdateWithoutGoalsInput>
  }

  export type GoalContributionUncheckedUpdateManyWithoutGoalNestedInput = {
    create?: XOR<GoalContributionCreateWithoutGoalInput, GoalContributionUncheckedCreateWithoutGoalInput> | GoalContributionCreateWithoutGoalInput[] | GoalContributionUncheckedCreateWithoutGoalInput[]
    connectOrCreate?: GoalContributionCreateOrConnectWithoutGoalInput | GoalContributionCreateOrConnectWithoutGoalInput[]
    upsert?: GoalContributionUpsertWithWhereUniqueWithoutGoalInput | GoalContributionUpsertWithWhereUniqueWithoutGoalInput[]
    createMany?: GoalContributionCreateManyGoalInputEnvelope
    set?: GoalContributionWhereUniqueInput | GoalContributionWhereUniqueInput[]
    disconnect?: GoalContributionWhereUniqueInput | GoalContributionWhereUniqueInput[]
    delete?: GoalContributionWhereUniqueInput | GoalContributionWhereUniqueInput[]
    connect?: GoalContributionWhereUniqueInput | GoalContributionWhereUniqueInput[]
    update?: GoalContributionUpdateWithWhereUniqueWithoutGoalInput | GoalContributionUpdateWithWhereUniqueWithoutGoalInput[]
    updateMany?: GoalContributionUpdateManyWithWhereWithoutGoalInput | GoalContributionUpdateManyWithWhereWithoutGoalInput[]
    deleteMany?: GoalContributionScalarWhereInput | GoalContributionScalarWhereInput[]
  }

  export type GoalCreateNestedOneWithoutContributionsInput = {
    create?: XOR<GoalCreateWithoutContributionsInput, GoalUncheckedCreateWithoutContributionsInput>
    connectOrCreate?: GoalCreateOrConnectWithoutContributionsInput
    connect?: GoalWhereUniqueInput
  }

  export type GoalUpdateOneRequiredWithoutContributionsNestedInput = {
    create?: XOR<GoalCreateWithoutContributionsInput, GoalUncheckedCreateWithoutContributionsInput>
    connectOrCreate?: GoalCreateOrConnectWithoutContributionsInput
    upsert?: GoalUpsertWithoutContributionsInput
    connect?: GoalWhereUniqueInput
    update?: XOR<XOR<GoalUpdateToOneWithWhereWithoutContributionsInput, GoalUpdateWithoutContributionsInput>, GoalUncheckedUpdateWithoutContributionsInput>
  }

  export type WorkspaceCreateNestedOneWithoutImportsInput = {
    create?: XOR<WorkspaceCreateWithoutImportsInput, WorkspaceUncheckedCreateWithoutImportsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutImportsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type WorkspaceUpdateOneRequiredWithoutImportsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutImportsInput, WorkspaceUncheckedCreateWithoutImportsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutImportsInput
    upsert?: WorkspaceUpsertWithoutImportsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutImportsInput, WorkspaceUpdateWithoutImportsInput>, WorkspaceUncheckedUpdateWithoutImportsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type WorkspaceCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<WorkspaceCreateWithoutAuditLogsInput, WorkspaceUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutAuditLogsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type WorkspaceUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutAuditLogsInput, WorkspaceUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutAuditLogsInput
    upsert?: WorkspaceUpsertWithoutAuditLogsInput
    disconnect?: WorkspaceWhereInput | boolean
    delete?: WorkspaceWhereInput | boolean
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutAuditLogsInput, WorkspaceUpdateWithoutAuditLogsInput>, WorkspaceUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserCreateNestedOneWithoutGamificationInput = {
    create?: XOR<UserCreateWithoutGamificationInput, UserUncheckedCreateWithoutGamificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutGamificationInput
    connect?: UserWhereUniqueInput
  }

  export type UserAchievementCreateNestedManyWithoutUserGamificationInput = {
    create?: XOR<UserAchievementCreateWithoutUserGamificationInput, UserAchievementUncheckedCreateWithoutUserGamificationInput> | UserAchievementCreateWithoutUserGamificationInput[] | UserAchievementUncheckedCreateWithoutUserGamificationInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserGamificationInput | UserAchievementCreateOrConnectWithoutUserGamificationInput[]
    createMany?: UserAchievementCreateManyUserGamificationInputEnvelope
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
  }

  export type UserAchievementUncheckedCreateNestedManyWithoutUserGamificationInput = {
    create?: XOR<UserAchievementCreateWithoutUserGamificationInput, UserAchievementUncheckedCreateWithoutUserGamificationInput> | UserAchievementCreateWithoutUserGamificationInput[] | UserAchievementUncheckedCreateWithoutUserGamificationInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserGamificationInput | UserAchievementCreateOrConnectWithoutUserGamificationInput[]
    createMany?: UserAchievementCreateManyUserGamificationInputEnvelope
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutGamificationNestedInput = {
    create?: XOR<UserCreateWithoutGamificationInput, UserUncheckedCreateWithoutGamificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutGamificationInput
    upsert?: UserUpsertWithoutGamificationInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGamificationInput, UserUpdateWithoutGamificationInput>, UserUncheckedUpdateWithoutGamificationInput>
  }

  export type UserAchievementUpdateManyWithoutUserGamificationNestedInput = {
    create?: XOR<UserAchievementCreateWithoutUserGamificationInput, UserAchievementUncheckedCreateWithoutUserGamificationInput> | UserAchievementCreateWithoutUserGamificationInput[] | UserAchievementUncheckedCreateWithoutUserGamificationInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserGamificationInput | UserAchievementCreateOrConnectWithoutUserGamificationInput[]
    upsert?: UserAchievementUpsertWithWhereUniqueWithoutUserGamificationInput | UserAchievementUpsertWithWhereUniqueWithoutUserGamificationInput[]
    createMany?: UserAchievementCreateManyUserGamificationInputEnvelope
    set?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    disconnect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    delete?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    update?: UserAchievementUpdateWithWhereUniqueWithoutUserGamificationInput | UserAchievementUpdateWithWhereUniqueWithoutUserGamificationInput[]
    updateMany?: UserAchievementUpdateManyWithWhereWithoutUserGamificationInput | UserAchievementUpdateManyWithWhereWithoutUserGamificationInput[]
    deleteMany?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
  }

  export type UserAchievementUncheckedUpdateManyWithoutUserGamificationNestedInput = {
    create?: XOR<UserAchievementCreateWithoutUserGamificationInput, UserAchievementUncheckedCreateWithoutUserGamificationInput> | UserAchievementCreateWithoutUserGamificationInput[] | UserAchievementUncheckedCreateWithoutUserGamificationInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserGamificationInput | UserAchievementCreateOrConnectWithoutUserGamificationInput[]
    upsert?: UserAchievementUpsertWithWhereUniqueWithoutUserGamificationInput | UserAchievementUpsertWithWhereUniqueWithoutUserGamificationInput[]
    createMany?: UserAchievementCreateManyUserGamificationInputEnvelope
    set?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    disconnect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    delete?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    update?: UserAchievementUpdateWithWhereUniqueWithoutUserGamificationInput | UserAchievementUpdateWithWhereUniqueWithoutUserGamificationInput[]
    updateMany?: UserAchievementUpdateManyWithWhereWithoutUserGamificationInput | UserAchievementUpdateManyWithWhereWithoutUserGamificationInput[]
    deleteMany?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
  }

  export type UserGamificationCreateNestedOneWithoutAchievementsInput = {
    create?: XOR<UserGamificationCreateWithoutAchievementsInput, UserGamificationUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: UserGamificationCreateOrConnectWithoutAchievementsInput
    connect?: UserGamificationWhereUniqueInput
  }

  export type UserGamificationUpdateOneRequiredWithoutAchievementsNestedInput = {
    create?: XOR<UserGamificationCreateWithoutAchievementsInput, UserGamificationUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: UserGamificationCreateOrConnectWithoutAchievementsInput
    upsert?: UserGamificationUpsertWithoutAchievementsInput
    connect?: UserGamificationWhereUniqueInput
    update?: XOR<XOR<UserGamificationUpdateToOneWithWhereWithoutAchievementsInput, UserGamificationUpdateWithoutAchievementsInput>, UserGamificationUncheckedUpdateWithoutAchievementsInput>
  }

  export type WorkspaceCreateNestedOneWithoutEnvelopesInput = {
    create?: XOR<WorkspaceCreateWithoutEnvelopesInput, WorkspaceUncheckedCreateWithoutEnvelopesInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutEnvelopesInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutEnvelopesInput = {
    create?: XOR<CategoryCreateWithoutEnvelopesInput, CategoryUncheckedCreateWithoutEnvelopesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutEnvelopesInput
    connect?: CategoryWhereUniqueInput
  }

  export type WorkspaceUpdateOneRequiredWithoutEnvelopesNestedInput = {
    create?: XOR<WorkspaceCreateWithoutEnvelopesInput, WorkspaceUncheckedCreateWithoutEnvelopesInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutEnvelopesInput
    upsert?: WorkspaceUpsertWithoutEnvelopesInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutEnvelopesInput, WorkspaceUpdateWithoutEnvelopesInput>, WorkspaceUncheckedUpdateWithoutEnvelopesInput>
  }

  export type CategoryUpdateOneWithoutEnvelopesNestedInput = {
    create?: XOR<CategoryCreateWithoutEnvelopesInput, CategoryUncheckedCreateWithoutEnvelopesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutEnvelopesInput
    upsert?: CategoryUpsertWithoutEnvelopesInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutEnvelopesInput, CategoryUpdateWithoutEnvelopesInput>, CategoryUncheckedUpdateWithoutEnvelopesInput>
  }

  export type WorkspaceCreateNestedOneWithoutAssetsInput = {
    create?: XOR<WorkspaceCreateWithoutAssetsInput, WorkspaceUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutAssetsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type WorkspaceUpdateOneRequiredWithoutAssetsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutAssetsInput, WorkspaceUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutAssetsInput
    upsert?: WorkspaceUpsertWithoutAssetsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutAssetsInput, WorkspaceUpdateWithoutAssetsInput>, WorkspaceUncheckedUpdateWithoutAssetsInput>
  }

  export type WorkspaceCreateNestedOneWithoutLiabilitiesInput = {
    create?: XOR<WorkspaceCreateWithoutLiabilitiesInput, WorkspaceUncheckedCreateWithoutLiabilitiesInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutLiabilitiesInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type WorkspaceUpdateOneRequiredWithoutLiabilitiesNestedInput = {
    create?: XOR<WorkspaceCreateWithoutLiabilitiesInput, WorkspaceUncheckedCreateWithoutLiabilitiesInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutLiabilitiesInput
    upsert?: WorkspaceUpsertWithoutLiabilitiesInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutLiabilitiesInput, WorkspaceUpdateWithoutLiabilitiesInput>, WorkspaceUncheckedUpdateWithoutLiabilitiesInput>
  }

  export type UserCreateNestedOneWithoutAiInsightsInput = {
    create?: XOR<UserCreateWithoutAiInsightsInput, UserUncheckedCreateWithoutAiInsightsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAiInsightsInput
    connect?: UserWhereUniqueInput
  }

  export type WorkspaceCreateNestedOneWithoutAiInsightsInput = {
    create?: XOR<WorkspaceCreateWithoutAiInsightsInput, WorkspaceUncheckedCreateWithoutAiInsightsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutAiInsightsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAiInsightsNestedInput = {
    create?: XOR<UserCreateWithoutAiInsightsInput, UserUncheckedCreateWithoutAiInsightsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAiInsightsInput
    upsert?: UserUpsertWithoutAiInsightsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAiInsightsInput, UserUpdateWithoutAiInsightsInput>, UserUncheckedUpdateWithoutAiInsightsInput>
  }

  export type WorkspaceUpdateOneRequiredWithoutAiInsightsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutAiInsightsInput, WorkspaceUncheckedCreateWithoutAiInsightsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutAiInsightsInput
    upsert?: WorkspaceUpsertWithoutAiInsightsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutAiInsightsInput, WorkspaceUpdateWithoutAiInsightsInput>, WorkspaceUncheckedUpdateWithoutAiInsightsInput>
  }

  export type UserCreateNestedOneWithoutScenariosInput = {
    create?: XOR<UserCreateWithoutScenariosInput, UserUncheckedCreateWithoutScenariosInput>
    connectOrCreate?: UserCreateOrConnectWithoutScenariosInput
    connect?: UserWhereUniqueInput
  }

  export type WorkspaceCreateNestedOneWithoutScenariosInput = {
    create?: XOR<WorkspaceCreateWithoutScenariosInput, WorkspaceUncheckedCreateWithoutScenariosInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutScenariosInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutScenariosNestedInput = {
    create?: XOR<UserCreateWithoutScenariosInput, UserUncheckedCreateWithoutScenariosInput>
    connectOrCreate?: UserCreateOrConnectWithoutScenariosInput
    upsert?: UserUpsertWithoutScenariosInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutScenariosInput, UserUpdateWithoutScenariosInput>, UserUncheckedUpdateWithoutScenariosInput>
  }

  export type WorkspaceUpdateOneRequiredWithoutScenariosNestedInput = {
    create?: XOR<WorkspaceCreateWithoutScenariosInput, WorkspaceUncheckedCreateWithoutScenariosInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutScenariosInput
    upsert?: WorkspaceUpsertWithoutScenariosInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutScenariosInput, WorkspaceUpdateWithoutScenariosInput>, WorkspaceUncheckedUpdateWithoutScenariosInput>
  }

  export type WorkspaceCreateNestedOneWithoutBankConnectionsInput = {
    create?: XOR<WorkspaceCreateWithoutBankConnectionsInput, WorkspaceUncheckedCreateWithoutBankConnectionsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutBankConnectionsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutBankConnectionsInput = {
    create?: XOR<AccountCreateWithoutBankConnectionsInput, AccountUncheckedCreateWithoutBankConnectionsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutBankConnectionsInput
    connect?: AccountWhereUniqueInput
  }

  export type WorkspaceUpdateOneRequiredWithoutBankConnectionsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutBankConnectionsInput, WorkspaceUncheckedCreateWithoutBankConnectionsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutBankConnectionsInput
    upsert?: WorkspaceUpsertWithoutBankConnectionsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutBankConnectionsInput, WorkspaceUpdateWithoutBankConnectionsInput>, WorkspaceUncheckedUpdateWithoutBankConnectionsInput>
  }

  export type AccountUpdateOneRequiredWithoutBankConnectionsNestedInput = {
    create?: XOR<AccountCreateWithoutBankConnectionsInput, AccountUncheckedCreateWithoutBankConnectionsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutBankConnectionsInput
    upsert?: AccountUpsertWithoutBankConnectionsInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutBankConnectionsInput, AccountUpdateWithoutBankConnectionsInput>, AccountUncheckedUpdateWithoutBankConnectionsInput>
  }

  export type UserCreateNestedOneWithoutAutoRulesInput = {
    create?: XOR<UserCreateWithoutAutoRulesInput, UserUncheckedCreateWithoutAutoRulesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAutoRulesInput
    connect?: UserWhereUniqueInput
  }

  export type WorkspaceCreateNestedOneWithoutAutoRulesInput = {
    create?: XOR<WorkspaceCreateWithoutAutoRulesInput, WorkspaceUncheckedCreateWithoutAutoRulesInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutAutoRulesInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAutoRulesNestedInput = {
    create?: XOR<UserCreateWithoutAutoRulesInput, UserUncheckedCreateWithoutAutoRulesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAutoRulesInput
    upsert?: UserUpsertWithoutAutoRulesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAutoRulesInput, UserUpdateWithoutAutoRulesInput>, UserUncheckedUpdateWithoutAutoRulesInput>
  }

  export type WorkspaceUpdateOneRequiredWithoutAutoRulesNestedInput = {
    create?: XOR<WorkspaceCreateWithoutAutoRulesInput, WorkspaceUncheckedCreateWithoutAutoRulesInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutAutoRulesInput
    upsert?: WorkspaceUpsertWithoutAutoRulesInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutAutoRulesInput, WorkspaceUpdateWithoutAutoRulesInput>, WorkspaceUncheckedUpdateWithoutAutoRulesInput>
  }

  export type WorkspaceCreateNestedOneWithoutCashFlowProjectionsInput = {
    create?: XOR<WorkspaceCreateWithoutCashFlowProjectionsInput, WorkspaceUncheckedCreateWithoutCashFlowProjectionsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutCashFlowProjectionsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type WorkspaceUpdateOneRequiredWithoutCashFlowProjectionsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutCashFlowProjectionsInput, WorkspaceUncheckedCreateWithoutCashFlowProjectionsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutCashFlowProjectionsInput
    upsert?: WorkspaceUpsertWithoutCashFlowProjectionsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutCashFlowProjectionsInput, WorkspaceUpdateWithoutCashFlowProjectionsInput>, WorkspaceUncheckedUpdateWithoutCashFlowProjectionsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type WorkspaceMemberCreateWithoutUserInput = {
    id?: string
    role: string
    joinedAt?: Date | string
    invitedBy?: string | null
    workspace: WorkspaceCreateNestedOneWithoutMembersInput
  }

  export type WorkspaceMemberUncheckedCreateWithoutUserInput = {
    id?: string
    workspaceId: string
    role: string
    joinedAt?: Date | string
    invitedBy?: string | null
  }

  export type WorkspaceMemberCreateOrConnectWithoutUserInput = {
    where: WorkspaceMemberWhereUniqueInput
    create: XOR<WorkspaceMemberCreateWithoutUserInput, WorkspaceMemberUncheckedCreateWithoutUserInput>
  }

  export type WorkspaceMemberCreateManyUserInputEnvelope = {
    data: WorkspaceMemberCreateManyUserInput | WorkspaceMemberCreateManyUserInput[]
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    token: string
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    workspaceId?: string | null
    type: string
    title: string
    message: string
    data?: string | null
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    workspaceId?: string | null
    type: string
    title: string
    message: string
    data?: string | null
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: string
    entityType: string
    entityId?: string | null
    oldData?: string | null
    newData?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    Workspace?: WorkspaceCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    workspaceId?: string | null
    action: string
    entityType: string
    entityId?: string | null
    oldData?: string | null
    newData?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
  }

  export type PasswordResetCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PasswordResetUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PasswordResetCreateOrConnectWithoutUserInput = {
    where: PasswordResetWhereUniqueInput
    create: XOR<PasswordResetCreateWithoutUserInput, PasswordResetUncheckedCreateWithoutUserInput>
  }

  export type PasswordResetCreateManyUserInputEnvelope = {
    data: PasswordResetCreateManyUserInput | PasswordResetCreateManyUserInput[]
  }

  export type RefreshTokenCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    revokedAt?: Date | string | null
  }

  export type RefreshTokenUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    revokedAt?: Date | string | null
  }

  export type RefreshTokenCreateOrConnectWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenCreateManyUserInputEnvelope = {
    data: RefreshTokenCreateManyUserInput | RefreshTokenCreateManyUserInput[]
  }

  export type UserGamificationCreateWithoutUserInput = {
    id?: string
    tier: string
    totalXP?: number
    currentLevel?: number
    xpToNextLevel?: number
    loginStreak?: number
    longestLoginStreak?: number
    transactionStreak?: number
    transactionsLogged?: number
    budgetsMet?: number
    goalsAchieved?: number
    lastLoginDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    achievements?: UserAchievementCreateNestedManyWithoutUserGamificationInput
  }

  export type UserGamificationUncheckedCreateWithoutUserInput = {
    id?: string
    tier: string
    totalXP?: number
    currentLevel?: number
    xpToNextLevel?: number
    loginStreak?: number
    longestLoginStreak?: number
    transactionStreak?: number
    transactionsLogged?: number
    budgetsMet?: number
    goalsAchieved?: number
    lastLoginDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserGamificationInput
  }

  export type UserGamificationCreateOrConnectWithoutUserInput = {
    where: UserGamificationWhereUniqueInput
    create: XOR<UserGamificationCreateWithoutUserInput, UserGamificationUncheckedCreateWithoutUserInput>
  }

  export type AIInsightCreateWithoutUserInput = {
    id?: string
    type: string
    title: string
    description: string
    severity: string
    suggestedAction?: string | null
    actionTaken?: boolean
    confidenceScore?: number | null
    dismissedAt?: Date | string | null
    createdAt?: Date | string
    Workspace: WorkspaceCreateNestedOneWithoutAiInsightsInput
  }

  export type AIInsightUncheckedCreateWithoutUserInput = {
    id?: string
    workspaceId: string
    type: string
    title: string
    description: string
    severity: string
    suggestedAction?: string | null
    actionTaken?: boolean
    confidenceScore?: number | null
    dismissedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AIInsightCreateOrConnectWithoutUserInput = {
    where: AIInsightWhereUniqueInput
    create: XOR<AIInsightCreateWithoutUserInput, AIInsightUncheckedCreateWithoutUserInput>
  }

  export type AIInsightCreateManyUserInputEnvelope = {
    data: AIInsightCreateManyUserInput | AIInsightCreateManyUserInput[]
  }

  export type ScenarioCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    parameters: string
    isFavorite?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Workspace: WorkspaceCreateNestedOneWithoutScenariosInput
  }

  export type ScenarioUncheckedCreateWithoutUserInput = {
    id?: string
    workspaceId: string
    name: string
    description?: string | null
    type: string
    parameters: string
    isFavorite?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScenarioCreateOrConnectWithoutUserInput = {
    where: ScenarioWhereUniqueInput
    create: XOR<ScenarioCreateWithoutUserInput, ScenarioUncheckedCreateWithoutUserInput>
  }

  export type ScenarioCreateManyUserInputEnvelope = {
    data: ScenarioCreateManyUserInput | ScenarioCreateManyUserInput[]
  }

  export type AutoRuleCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    priority?: number
    conditions: string
    actions: string
    timesApplied?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Workspace: WorkspaceCreateNestedOneWithoutAutoRulesInput
  }

  export type AutoRuleUncheckedCreateWithoutUserInput = {
    id?: string
    workspaceId: string
    name: string
    description?: string | null
    isActive?: boolean
    priority?: number
    conditions: string
    actions: string
    timesApplied?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AutoRuleCreateOrConnectWithoutUserInput = {
    where: AutoRuleWhereUniqueInput
    create: XOR<AutoRuleCreateWithoutUserInput, AutoRuleUncheckedCreateWithoutUserInput>
  }

  export type AutoRuleCreateManyUserInputEnvelope = {
    data: AutoRuleCreateManyUserInput | AutoRuleCreateManyUserInput[]
  }

  export type WorkspaceMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: WorkspaceMemberWhereUniqueInput
    update: XOR<WorkspaceMemberUpdateWithoutUserInput, WorkspaceMemberUncheckedUpdateWithoutUserInput>
    create: XOR<WorkspaceMemberCreateWithoutUserInput, WorkspaceMemberUncheckedCreateWithoutUserInput>
  }

  export type WorkspaceMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: WorkspaceMemberWhereUniqueInput
    data: XOR<WorkspaceMemberUpdateWithoutUserInput, WorkspaceMemberUncheckedUpdateWithoutUserInput>
  }

  export type WorkspaceMemberUpdateManyWithWhereWithoutUserInput = {
    where: WorkspaceMemberScalarWhereInput
    data: XOR<WorkspaceMemberUpdateManyMutationInput, WorkspaceMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type WorkspaceMemberScalarWhereInput = {
    AND?: WorkspaceMemberScalarWhereInput | WorkspaceMemberScalarWhereInput[]
    OR?: WorkspaceMemberScalarWhereInput[]
    NOT?: WorkspaceMemberScalarWhereInput | WorkspaceMemberScalarWhereInput[]
    id?: StringFilter<"WorkspaceMember"> | string
    workspaceId?: StringFilter<"WorkspaceMember"> | string
    userId?: StringFilter<"WorkspaceMember"> | string
    role?: StringFilter<"WorkspaceMember"> | string
    joinedAt?: DateTimeFilter<"WorkspaceMember"> | Date | string
    invitedBy?: StringNullableFilter<"WorkspaceMember"> | string | null
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    token?: StringFilter<"Session"> | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    workspaceId?: StringNullableFilter<"Notification"> | string | null
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    data?: StringNullableFilter<"Notification"> | string | null
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    workspaceId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    oldData?: StringNullableFilter<"AuditLog"> | string | null
    newData?: StringNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type PasswordResetUpsertWithWhereUniqueWithoutUserInput = {
    where: PasswordResetWhereUniqueInput
    update: XOR<PasswordResetUpdateWithoutUserInput, PasswordResetUncheckedUpdateWithoutUserInput>
    create: XOR<PasswordResetCreateWithoutUserInput, PasswordResetUncheckedCreateWithoutUserInput>
  }

  export type PasswordResetUpdateWithWhereUniqueWithoutUserInput = {
    where: PasswordResetWhereUniqueInput
    data: XOR<PasswordResetUpdateWithoutUserInput, PasswordResetUncheckedUpdateWithoutUserInput>
  }

  export type PasswordResetUpdateManyWithWhereWithoutUserInput = {
    where: PasswordResetScalarWhereInput
    data: XOR<PasswordResetUpdateManyMutationInput, PasswordResetUncheckedUpdateManyWithoutUserInput>
  }

  export type PasswordResetScalarWhereInput = {
    AND?: PasswordResetScalarWhereInput | PasswordResetScalarWhereInput[]
    OR?: PasswordResetScalarWhereInput[]
    NOT?: PasswordResetScalarWhereInput | PasswordResetScalarWhereInput[]
    id?: StringFilter<"PasswordReset"> | string
    userId?: StringFilter<"PasswordReset"> | string
    token?: StringFilter<"PasswordReset"> | string
    expiresAt?: DateTimeFilter<"PasswordReset"> | Date | string
    usedAt?: DateTimeNullableFilter<"PasswordReset"> | Date | string | null
    createdAt?: DateTimeFilter<"PasswordReset"> | Date | string
  }

  export type RefreshTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    update: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    data: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUpdateManyWithWhereWithoutUserInput = {
    where: RefreshTokenScalarWhereInput
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type RefreshTokenScalarWhereInput = {
    AND?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    OR?: RefreshTokenScalarWhereInput[]
    NOT?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    revokedAt?: DateTimeNullableFilter<"RefreshToken"> | Date | string | null
  }

  export type UserGamificationUpsertWithoutUserInput = {
    update: XOR<UserGamificationUpdateWithoutUserInput, UserGamificationUncheckedUpdateWithoutUserInput>
    create: XOR<UserGamificationCreateWithoutUserInput, UserGamificationUncheckedCreateWithoutUserInput>
    where?: UserGamificationWhereInput
  }

  export type UserGamificationUpdateToOneWithWhereWithoutUserInput = {
    where?: UserGamificationWhereInput
    data: XOR<UserGamificationUpdateWithoutUserInput, UserGamificationUncheckedUpdateWithoutUserInput>
  }

  export type UserGamificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    totalXP?: IntFieldUpdateOperationsInput | number
    currentLevel?: IntFieldUpdateOperationsInput | number
    xpToNextLevel?: IntFieldUpdateOperationsInput | number
    loginStreak?: IntFieldUpdateOperationsInput | number
    longestLoginStreak?: IntFieldUpdateOperationsInput | number
    transactionStreak?: IntFieldUpdateOperationsInput | number
    transactionsLogged?: IntFieldUpdateOperationsInput | number
    budgetsMet?: IntFieldUpdateOperationsInput | number
    goalsAchieved?: IntFieldUpdateOperationsInput | number
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    achievements?: UserAchievementUpdateManyWithoutUserGamificationNestedInput
  }

  export type UserGamificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    totalXP?: IntFieldUpdateOperationsInput | number
    currentLevel?: IntFieldUpdateOperationsInput | number
    xpToNextLevel?: IntFieldUpdateOperationsInput | number
    loginStreak?: IntFieldUpdateOperationsInput | number
    longestLoginStreak?: IntFieldUpdateOperationsInput | number
    transactionStreak?: IntFieldUpdateOperationsInput | number
    transactionsLogged?: IntFieldUpdateOperationsInput | number
    budgetsMet?: IntFieldUpdateOperationsInput | number
    goalsAchieved?: IntFieldUpdateOperationsInput | number
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserGamificationNestedInput
  }

  export type AIInsightUpsertWithWhereUniqueWithoutUserInput = {
    where: AIInsightWhereUniqueInput
    update: XOR<AIInsightUpdateWithoutUserInput, AIInsightUncheckedUpdateWithoutUserInput>
    create: XOR<AIInsightCreateWithoutUserInput, AIInsightUncheckedCreateWithoutUserInput>
  }

  export type AIInsightUpdateWithWhereUniqueWithoutUserInput = {
    where: AIInsightWhereUniqueInput
    data: XOR<AIInsightUpdateWithoutUserInput, AIInsightUncheckedUpdateWithoutUserInput>
  }

  export type AIInsightUpdateManyWithWhereWithoutUserInput = {
    where: AIInsightScalarWhereInput
    data: XOR<AIInsightUpdateManyMutationInput, AIInsightUncheckedUpdateManyWithoutUserInput>
  }

  export type AIInsightScalarWhereInput = {
    AND?: AIInsightScalarWhereInput | AIInsightScalarWhereInput[]
    OR?: AIInsightScalarWhereInput[]
    NOT?: AIInsightScalarWhereInput | AIInsightScalarWhereInput[]
    id?: StringFilter<"AIInsight"> | string
    workspaceId?: StringFilter<"AIInsight"> | string
    userId?: StringFilter<"AIInsight"> | string
    type?: StringFilter<"AIInsight"> | string
    title?: StringFilter<"AIInsight"> | string
    description?: StringFilter<"AIInsight"> | string
    severity?: StringFilter<"AIInsight"> | string
    suggestedAction?: StringNullableFilter<"AIInsight"> | string | null
    actionTaken?: BoolFilter<"AIInsight"> | boolean
    confidenceScore?: FloatNullableFilter<"AIInsight"> | number | null
    dismissedAt?: DateTimeNullableFilter<"AIInsight"> | Date | string | null
    createdAt?: DateTimeFilter<"AIInsight"> | Date | string
  }

  export type ScenarioUpsertWithWhereUniqueWithoutUserInput = {
    where: ScenarioWhereUniqueInput
    update: XOR<ScenarioUpdateWithoutUserInput, ScenarioUncheckedUpdateWithoutUserInput>
    create: XOR<ScenarioCreateWithoutUserInput, ScenarioUncheckedCreateWithoutUserInput>
  }

  export type ScenarioUpdateWithWhereUniqueWithoutUserInput = {
    where: ScenarioWhereUniqueInput
    data: XOR<ScenarioUpdateWithoutUserInput, ScenarioUncheckedUpdateWithoutUserInput>
  }

  export type ScenarioUpdateManyWithWhereWithoutUserInput = {
    where: ScenarioScalarWhereInput
    data: XOR<ScenarioUpdateManyMutationInput, ScenarioUncheckedUpdateManyWithoutUserInput>
  }

  export type ScenarioScalarWhereInput = {
    AND?: ScenarioScalarWhereInput | ScenarioScalarWhereInput[]
    OR?: ScenarioScalarWhereInput[]
    NOT?: ScenarioScalarWhereInput | ScenarioScalarWhereInput[]
    id?: StringFilter<"Scenario"> | string
    workspaceId?: StringFilter<"Scenario"> | string
    userId?: StringFilter<"Scenario"> | string
    name?: StringFilter<"Scenario"> | string
    description?: StringNullableFilter<"Scenario"> | string | null
    type?: StringFilter<"Scenario"> | string
    parameters?: StringFilter<"Scenario"> | string
    isFavorite?: BoolFilter<"Scenario"> | boolean
    isActive?: BoolFilter<"Scenario"> | boolean
    createdAt?: DateTimeFilter<"Scenario"> | Date | string
    updatedAt?: DateTimeFilter<"Scenario"> | Date | string
  }

  export type AutoRuleUpsertWithWhereUniqueWithoutUserInput = {
    where: AutoRuleWhereUniqueInput
    update: XOR<AutoRuleUpdateWithoutUserInput, AutoRuleUncheckedUpdateWithoutUserInput>
    create: XOR<AutoRuleCreateWithoutUserInput, AutoRuleUncheckedCreateWithoutUserInput>
  }

  export type AutoRuleUpdateWithWhereUniqueWithoutUserInput = {
    where: AutoRuleWhereUniqueInput
    data: XOR<AutoRuleUpdateWithoutUserInput, AutoRuleUncheckedUpdateWithoutUserInput>
  }

  export type AutoRuleUpdateManyWithWhereWithoutUserInput = {
    where: AutoRuleScalarWhereInput
    data: XOR<AutoRuleUpdateManyMutationInput, AutoRuleUncheckedUpdateManyWithoutUserInput>
  }

  export type AutoRuleScalarWhereInput = {
    AND?: AutoRuleScalarWhereInput | AutoRuleScalarWhereInput[]
    OR?: AutoRuleScalarWhereInput[]
    NOT?: AutoRuleScalarWhereInput | AutoRuleScalarWhereInput[]
    id?: StringFilter<"AutoRule"> | string
    workspaceId?: StringFilter<"AutoRule"> | string
    userId?: StringFilter<"AutoRule"> | string
    name?: StringFilter<"AutoRule"> | string
    description?: StringNullableFilter<"AutoRule"> | string | null
    isActive?: BoolFilter<"AutoRule"> | boolean
    priority?: IntFilter<"AutoRule"> | number
    conditions?: StringFilter<"AutoRule"> | string
    actions?: StringFilter<"AutoRule"> | string
    timesApplied?: IntFilter<"AutoRule"> | number
    createdAt?: DateTimeFilter<"AutoRule"> | Date | string
    updatedAt?: DateTimeFilter<"AutoRule"> | Date | string
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    avatarUrl?: string | null
    phone?: string | null
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    workspaces?: WorkspaceMemberCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    gamification?: UserGamificationCreateNestedOneWithoutUserInput
    aiInsights?: AIInsightCreateNestedManyWithoutUserInput
    scenarios?: ScenarioCreateNestedManyWithoutUserInput
    autoRules?: AutoRuleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    avatarUrl?: string | null
    phone?: string | null
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    workspaces?: WorkspaceMemberUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    gamification?: UserGamificationUncheckedCreateNestedOneWithoutUserInput
    aiInsights?: AIInsightUncheckedCreateNestedManyWithoutUserInput
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutUserInput
    autoRules?: AutoRuleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workspaces?: WorkspaceMemberUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    gamification?: UserGamificationUpdateOneWithoutUserNestedInput
    aiInsights?: AIInsightUpdateManyWithoutUserNestedInput
    scenarios?: ScenarioUpdateManyWithoutUserNestedInput
    autoRules?: AutoRuleUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workspaces?: WorkspaceMemberUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    gamification?: UserGamificationUncheckedUpdateOneWithoutUserNestedInput
    aiInsights?: AIInsightUncheckedUpdateManyWithoutUserNestedInput
    scenarios?: ScenarioUncheckedUpdateManyWithoutUserNestedInput
    autoRules?: AutoRuleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutRefreshTokensInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    avatarUrl?: string | null
    phone?: string | null
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    workspaces?: WorkspaceMemberCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    gamification?: UserGamificationCreateNestedOneWithoutUserInput
    aiInsights?: AIInsightCreateNestedManyWithoutUserInput
    scenarios?: ScenarioCreateNestedManyWithoutUserInput
    autoRules?: AutoRuleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRefreshTokensInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    avatarUrl?: string | null
    phone?: string | null
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    workspaces?: WorkspaceMemberUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    gamification?: UserGamificationUncheckedCreateNestedOneWithoutUserInput
    aiInsights?: AIInsightUncheckedCreateNestedManyWithoutUserInput
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutUserInput
    autoRules?: AutoRuleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRefreshTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
  }

  export type UserUpsertWithoutRefreshTokensInput = {
    update: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRefreshTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type UserUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workspaces?: WorkspaceMemberUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    gamification?: UserGamificationUpdateOneWithoutUserNestedInput
    aiInsights?: AIInsightUpdateManyWithoutUserNestedInput
    scenarios?: ScenarioUpdateManyWithoutUserNestedInput
    autoRules?: AutoRuleUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workspaces?: WorkspaceMemberUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    gamification?: UserGamificationUncheckedUpdateOneWithoutUserNestedInput
    aiInsights?: AIInsightUncheckedUpdateManyWithoutUserNestedInput
    scenarios?: ScenarioUncheckedUpdateManyWithoutUserNestedInput
    autoRules?: AutoRuleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPasswordResetsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    avatarUrl?: string | null
    phone?: string | null
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    workspaces?: WorkspaceMemberCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    gamification?: UserGamificationCreateNestedOneWithoutUserInput
    aiInsights?: AIInsightCreateNestedManyWithoutUserInput
    scenarios?: ScenarioCreateNestedManyWithoutUserInput
    autoRules?: AutoRuleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPasswordResetsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    avatarUrl?: string | null
    phone?: string | null
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    workspaces?: WorkspaceMemberUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    gamification?: UserGamificationUncheckedCreateNestedOneWithoutUserInput
    aiInsights?: AIInsightUncheckedCreateNestedManyWithoutUserInput
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutUserInput
    autoRules?: AutoRuleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPasswordResetsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPasswordResetsInput, UserUncheckedCreateWithoutPasswordResetsInput>
  }

  export type UserUpsertWithoutPasswordResetsInput = {
    update: XOR<UserUpdateWithoutPasswordResetsInput, UserUncheckedUpdateWithoutPasswordResetsInput>
    create: XOR<UserCreateWithoutPasswordResetsInput, UserUncheckedCreateWithoutPasswordResetsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPasswordResetsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPasswordResetsInput, UserUncheckedUpdateWithoutPasswordResetsInput>
  }

  export type UserUpdateWithoutPasswordResetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workspaces?: WorkspaceMemberUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    gamification?: UserGamificationUpdateOneWithoutUserNestedInput
    aiInsights?: AIInsightUpdateManyWithoutUserNestedInput
    scenarios?: ScenarioUpdateManyWithoutUserNestedInput
    autoRules?: AutoRuleUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPasswordResetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workspaces?: WorkspaceMemberUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    gamification?: UserGamificationUncheckedUpdateOneWithoutUserNestedInput
    aiInsights?: AIInsightUncheckedUpdateManyWithoutUserNestedInput
    scenarios?: ScenarioUncheckedUpdateManyWithoutUserNestedInput
    autoRules?: AutoRuleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WorkspaceMemberCreateWithoutWorkspaceInput = {
    id?: string
    role: string
    joinedAt?: Date | string
    invitedBy?: string | null
    user: UserCreateNestedOneWithoutWorkspacesInput
  }

  export type WorkspaceMemberUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    userId: string
    role: string
    joinedAt?: Date | string
    invitedBy?: string | null
  }

  export type WorkspaceMemberCreateOrConnectWithoutWorkspaceInput = {
    where: WorkspaceMemberWhereUniqueInput
    create: XOR<WorkspaceMemberCreateWithoutWorkspaceInput, WorkspaceMemberUncheckedCreateWithoutWorkspaceInput>
  }

  export type WorkspaceMemberCreateManyWorkspaceInputEnvelope = {
    data: WorkspaceMemberCreateManyWorkspaceInput | WorkspaceMemberCreateManyWorkspaceInput[]
  }

  export type AccountCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    type: string
    description?: string | null
    bankName?: string | null
    bankCode?: string | null
    agency?: string | null
    accountNumber?: string | null
    initialBalance?: number
    currentBalance?: number
    creditLimit?: number | null
    closingDay?: number | null
    dueDay?: number | null
    color?: string
    icon?: string
    isActive?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionCreateNestedManyWithoutAccountInput
    fromTransfers?: TransferCreateNestedManyWithoutFromAccountInput
    toTransfers?: TransferCreateNestedManyWithoutToAccountInput
    bankConnections?: BankConnectionCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    type: string
    description?: string | null
    bankName?: string | null
    bankCode?: string | null
    agency?: string | null
    accountNumber?: string | null
    initialBalance?: number
    currentBalance?: number
    creditLimit?: number | null
    closingDay?: number | null
    dueDay?: number | null
    color?: string
    icon?: string
    isActive?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutAccountInput
    fromTransfers?: TransferUncheckedCreateNestedManyWithoutFromAccountInput
    toTransfers?: TransferUncheckedCreateNestedManyWithoutToAccountInput
    bankConnections?: BankConnectionUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutWorkspaceInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutWorkspaceInput, AccountUncheckedCreateWithoutWorkspaceInput>
  }

  export type AccountCreateManyWorkspaceInputEnvelope = {
    data: AccountCreateManyWorkspaceInput | AccountCreateManyWorkspaceInput[]
  }

  export type CategoryCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    type: string
    color?: string
    icon?: string
    description?: string | null
    keywords: string
    isSystem?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    children?: CategoryCreateNestedManyWithoutParentInput
    transactions?: TransactionCreateNestedManyWithoutCategoryInput
    budgets?: BudgetCategoryCreateNestedManyWithoutCategoryInput
    envelopes?: EnvelopeCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    parentId?: string | null
    name: string
    type: string
    color?: string
    icon?: string
    description?: string | null
    keywords: string
    isSystem?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCategoryInput
    budgets?: BudgetCategoryUncheckedCreateNestedManyWithoutCategoryInput
    envelopes?: EnvelopeUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutWorkspaceInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutWorkspaceInput, CategoryUncheckedCreateWithoutWorkspaceInput>
  }

  export type CategoryCreateManyWorkspaceInputEnvelope = {
    data: CategoryCreateManyWorkspaceInput | CategoryCreateManyWorkspaceInput[]
  }

  export type GoalCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    targetAmount: number
    currentAmount?: number
    startDate: Date | string
    targetDate?: Date | string | null
    completedAt?: Date | string | null
    status: string
    icon?: string
    color?: string
    autoAllocate?: boolean
    allocationPercentage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contributions?: GoalContributionCreateNestedManyWithoutGoalInput
  }

  export type GoalUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    targetAmount: number
    currentAmount?: number
    startDate: Date | string
    targetDate?: Date | string | null
    completedAt?: Date | string | null
    status: string
    icon?: string
    color?: string
    autoAllocate?: boolean
    allocationPercentage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contributions?: GoalContributionUncheckedCreateNestedManyWithoutGoalInput
  }

  export type GoalCreateOrConnectWithoutWorkspaceInput = {
    where: GoalWhereUniqueInput
    create: XOR<GoalCreateWithoutWorkspaceInput, GoalUncheckedCreateWithoutWorkspaceInput>
  }

  export type GoalCreateManyWorkspaceInputEnvelope = {
    data: GoalCreateManyWorkspaceInput | GoalCreateManyWorkspaceInput[]
  }

  export type BudgetCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    totalBudgeted: number
    totalSpent?: number
    isActive?: boolean
    alertThreshold?: number
    alertSent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: BudgetCategoryCreateNestedManyWithoutBudgetInput
  }

  export type BudgetUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    totalBudgeted: number
    totalSpent?: number
    isActive?: boolean
    alertThreshold?: number
    alertSent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: BudgetCategoryUncheckedCreateNestedManyWithoutBudgetInput
  }

  export type BudgetCreateOrConnectWithoutWorkspaceInput = {
    where: BudgetWhereUniqueInput
    create: XOR<BudgetCreateWithoutWorkspaceInput, BudgetUncheckedCreateWithoutWorkspaceInput>
  }

  export type BudgetCreateManyWorkspaceInputEnvelope = {
    data: BudgetCreateManyWorkspaceInput | BudgetCreateManyWorkspaceInput[]
  }

  export type ImportJobCreateWithoutWorkspaceInput = {
    id?: string
    accountId: string
    format: string
    fileName: string
    fileSize: number
    fileUrl?: string | null
    status: string
    progress?: number
    totalRows?: number
    processedRows?: number
    importedRows?: number
    errorLog?: string | null
    mappingConfig?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ImportJobUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    accountId: string
    format: string
    fileName: string
    fileSize: number
    fileUrl?: string | null
    status: string
    progress?: number
    totalRows?: number
    processedRows?: number
    importedRows?: number
    errorLog?: string | null
    mappingConfig?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ImportJobCreateOrConnectWithoutWorkspaceInput = {
    where: ImportJobWhereUniqueInput
    create: XOR<ImportJobCreateWithoutWorkspaceInput, ImportJobUncheckedCreateWithoutWorkspaceInput>
  }

  export type ImportJobCreateManyWorkspaceInputEnvelope = {
    data: ImportJobCreateManyWorkspaceInput | ImportJobCreateManyWorkspaceInput[]
  }

  export type AuditLogCreateWithoutWorkspaceInput = {
    id?: string
    action: string
    entityType: string
    entityId?: string | null
    oldData?: string | null
    newData?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    userId?: string | null
    action: string
    entityType: string
    entityId?: string | null
    oldData?: string | null
    newData?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutWorkspaceInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutWorkspaceInput, AuditLogUncheckedCreateWithoutWorkspaceInput>
  }

  export type AuditLogCreateManyWorkspaceInputEnvelope = {
    data: AuditLogCreateManyWorkspaceInput | AuditLogCreateManyWorkspaceInput[]
  }

  export type EnvelopeCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    description?: string | null
    color?: string
    budgetedAmount: number
    availableAmount?: number
    spentAmount?: number
    month: number
    year: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Category?: CategoryCreateNestedOneWithoutEnvelopesInput
  }

  export type EnvelopeUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    categoryId?: string | null
    name: string
    description?: string | null
    color?: string
    budgetedAmount: number
    availableAmount?: number
    spentAmount?: number
    month: number
    year: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EnvelopeCreateOrConnectWithoutWorkspaceInput = {
    where: EnvelopeWhereUniqueInput
    create: XOR<EnvelopeCreateWithoutWorkspaceInput, EnvelopeUncheckedCreateWithoutWorkspaceInput>
  }

  export type EnvelopeCreateManyWorkspaceInputEnvelope = {
    data: EnvelopeCreateManyWorkspaceInput | EnvelopeCreateManyWorkspaceInput[]
  }

  export type AssetCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    type: string
    description?: string | null
    currentValue: number
    purchaseValue?: number | null
    purchaseDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssetUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    type: string
    description?: string | null
    currentValue: number
    purchaseValue?: number | null
    purchaseDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssetCreateOrConnectWithoutWorkspaceInput = {
    where: AssetWhereUniqueInput
    create: XOR<AssetCreateWithoutWorkspaceInput, AssetUncheckedCreateWithoutWorkspaceInput>
  }

  export type AssetCreateManyWorkspaceInputEnvelope = {
    data: AssetCreateManyWorkspaceInput | AssetCreateManyWorkspaceInput[]
  }

  export type LiabilityCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    type: string
    description?: string | null
    currentBalance: number
    originalAmount: number
    interestRate?: number | null
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LiabilityUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    type: string
    description?: string | null
    currentBalance: number
    originalAmount: number
    interestRate?: number | null
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LiabilityCreateOrConnectWithoutWorkspaceInput = {
    where: LiabilityWhereUniqueInput
    create: XOR<LiabilityCreateWithoutWorkspaceInput, LiabilityUncheckedCreateWithoutWorkspaceInput>
  }

  export type LiabilityCreateManyWorkspaceInputEnvelope = {
    data: LiabilityCreateManyWorkspaceInput | LiabilityCreateManyWorkspaceInput[]
  }

  export type AIInsightCreateWithoutWorkspaceInput = {
    id?: string
    type: string
    title: string
    description: string
    severity: string
    suggestedAction?: string | null
    actionTaken?: boolean
    confidenceScore?: number | null
    dismissedAt?: Date | string | null
    createdAt?: Date | string
    User: UserCreateNestedOneWithoutAiInsightsInput
  }

  export type AIInsightUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    userId: string
    type: string
    title: string
    description: string
    severity: string
    suggestedAction?: string | null
    actionTaken?: boolean
    confidenceScore?: number | null
    dismissedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AIInsightCreateOrConnectWithoutWorkspaceInput = {
    where: AIInsightWhereUniqueInput
    create: XOR<AIInsightCreateWithoutWorkspaceInput, AIInsightUncheckedCreateWithoutWorkspaceInput>
  }

  export type AIInsightCreateManyWorkspaceInputEnvelope = {
    data: AIInsightCreateManyWorkspaceInput | AIInsightCreateManyWorkspaceInput[]
  }

  export type ScenarioCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    parameters: string
    isFavorite?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    User: UserCreateNestedOneWithoutScenariosInput
  }

  export type ScenarioUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    type: string
    parameters: string
    isFavorite?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScenarioCreateOrConnectWithoutWorkspaceInput = {
    where: ScenarioWhereUniqueInput
    create: XOR<ScenarioCreateWithoutWorkspaceInput, ScenarioUncheckedCreateWithoutWorkspaceInput>
  }

  export type ScenarioCreateManyWorkspaceInputEnvelope = {
    data: ScenarioCreateManyWorkspaceInput | ScenarioCreateManyWorkspaceInput[]
  }

  export type BankConnectionCreateWithoutWorkspaceInput = {
    id?: string
    bankName: string
    bankCode: string
    accessToken: string
    status: string
    lastSyncAt?: Date | string | null
    lastSyncError?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Account: AccountCreateNestedOneWithoutBankConnectionsInput
  }

  export type BankConnectionUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    accountId: string
    bankName: string
    bankCode: string
    accessToken: string
    status: string
    lastSyncAt?: Date | string | null
    lastSyncError?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankConnectionCreateOrConnectWithoutWorkspaceInput = {
    where: BankConnectionWhereUniqueInput
    create: XOR<BankConnectionCreateWithoutWorkspaceInput, BankConnectionUncheckedCreateWithoutWorkspaceInput>
  }

  export type BankConnectionCreateManyWorkspaceInputEnvelope = {
    data: BankConnectionCreateManyWorkspaceInput | BankConnectionCreateManyWorkspaceInput[]
  }

  export type AutoRuleCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    priority?: number
    conditions: string
    actions: string
    timesApplied?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    User: UserCreateNestedOneWithoutAutoRulesInput
  }

  export type AutoRuleUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    isActive?: boolean
    priority?: number
    conditions: string
    actions: string
    timesApplied?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AutoRuleCreateOrConnectWithoutWorkspaceInput = {
    where: AutoRuleWhereUniqueInput
    create: XOR<AutoRuleCreateWithoutWorkspaceInput, AutoRuleUncheckedCreateWithoutWorkspaceInput>
  }

  export type AutoRuleCreateManyWorkspaceInputEnvelope = {
    data: AutoRuleCreateManyWorkspaceInput | AutoRuleCreateManyWorkspaceInput[]
  }

  export type CashFlowProjectionCreateWithoutWorkspaceInput = {
    id?: string
    month: number
    year: number
    projectedIncome: number
    projectedExpense: number
    projectedBalance: number
    generatedAt?: Date | string
    updatedAt?: Date | string
  }

  export type CashFlowProjectionUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    month: number
    year: number
    projectedIncome: number
    projectedExpense: number
    projectedBalance: number
    generatedAt?: Date | string
    updatedAt?: Date | string
  }

  export type CashFlowProjectionCreateOrConnectWithoutWorkspaceInput = {
    where: CashFlowProjectionWhereUniqueInput
    create: XOR<CashFlowProjectionCreateWithoutWorkspaceInput, CashFlowProjectionUncheckedCreateWithoutWorkspaceInput>
  }

  export type CashFlowProjectionCreateManyWorkspaceInputEnvelope = {
    data: CashFlowProjectionCreateManyWorkspaceInput | CashFlowProjectionCreateManyWorkspaceInput[]
  }

  export type TransactionCreateWithoutWorkspaceInput = {
    id?: string
    creditCardId?: string | null
    type: string
    description: string
    amount: number
    currency?: string
    status: string
    transactionDate: Date | string
    confirmedAt?: Date | string | null
    recurrenceId?: string | null
    notes?: string | null
    tags: string
    attachmentUrl?: string | null
    location?: string | null
    importId?: string | null
    rawData?: string | null
    aiConfidence?: number | null
    aiCategory?: string | null
    aiCategorizedAt?: Date | string | null
    aiModelVersion?: string | null
    autoRuleId?: string | null
    bankConnectionId?: string | null
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutTransactionsInput
    category?: CategoryCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    accountId: string
    categoryId?: string | null
    creditCardId?: string | null
    type: string
    description: string
    amount: number
    currency?: string
    status: string
    transactionDate: Date | string
    confirmedAt?: Date | string | null
    recurrenceId?: string | null
    notes?: string | null
    tags: string
    attachmentUrl?: string | null
    location?: string | null
    importId?: string | null
    rawData?: string | null
    aiConfidence?: number | null
    aiCategory?: string | null
    aiCategorizedAt?: Date | string | null
    aiModelVersion?: string | null
    autoRuleId?: string | null
    bankConnectionId?: string | null
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutWorkspaceInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutWorkspaceInput, TransactionUncheckedCreateWithoutWorkspaceInput>
  }

  export type TransactionCreateManyWorkspaceInputEnvelope = {
    data: TransactionCreateManyWorkspaceInput | TransactionCreateManyWorkspaceInput[]
  }

  export type WorkspaceMemberUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: WorkspaceMemberWhereUniqueInput
    update: XOR<WorkspaceMemberUpdateWithoutWorkspaceInput, WorkspaceMemberUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<WorkspaceMemberCreateWithoutWorkspaceInput, WorkspaceMemberUncheckedCreateWithoutWorkspaceInput>
  }

  export type WorkspaceMemberUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: WorkspaceMemberWhereUniqueInput
    data: XOR<WorkspaceMemberUpdateWithoutWorkspaceInput, WorkspaceMemberUncheckedUpdateWithoutWorkspaceInput>
  }

  export type WorkspaceMemberUpdateManyWithWhereWithoutWorkspaceInput = {
    where: WorkspaceMemberScalarWhereInput
    data: XOR<WorkspaceMemberUpdateManyMutationInput, WorkspaceMemberUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type AccountUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutWorkspaceInput, AccountUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<AccountCreateWithoutWorkspaceInput, AccountUncheckedCreateWithoutWorkspaceInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutWorkspaceInput, AccountUncheckedUpdateWithoutWorkspaceInput>
  }

  export type AccountUpdateManyWithWhereWithoutWorkspaceInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    workspaceId?: StringFilter<"Account"> | string
    name?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    description?: StringNullableFilter<"Account"> | string | null
    bankName?: StringNullableFilter<"Account"> | string | null
    bankCode?: StringNullableFilter<"Account"> | string | null
    agency?: StringNullableFilter<"Account"> | string | null
    accountNumber?: StringNullableFilter<"Account"> | string | null
    initialBalance?: FloatFilter<"Account"> | number
    currentBalance?: FloatFilter<"Account"> | number
    creditLimit?: FloatNullableFilter<"Account"> | number | null
    closingDay?: IntNullableFilter<"Account"> | number | null
    dueDay?: IntNullableFilter<"Account"> | number | null
    color?: StringFilter<"Account"> | string
    icon?: StringFilter<"Account"> | string
    isActive?: BoolFilter<"Account"> | boolean
    archivedAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
  }

  export type CategoryUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutWorkspaceInput, CategoryUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<CategoryCreateWithoutWorkspaceInput, CategoryUncheckedCreateWithoutWorkspaceInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutWorkspaceInput, CategoryUncheckedUpdateWithoutWorkspaceInput>
  }

  export type CategoryUpdateManyWithWhereWithoutWorkspaceInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type CategoryScalarWhereInput = {
    AND?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    OR?: CategoryScalarWhereInput[]
    NOT?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    id?: StringFilter<"Category"> | string
    workspaceId?: StringFilter<"Category"> | string
    parentId?: StringNullableFilter<"Category"> | string | null
    name?: StringFilter<"Category"> | string
    type?: StringFilter<"Category"> | string
    color?: StringFilter<"Category"> | string
    icon?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    keywords?: StringFilter<"Category"> | string
    isSystem?: BoolFilter<"Category"> | boolean
    isActive?: BoolFilter<"Category"> | boolean
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
  }

  export type GoalUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: GoalWhereUniqueInput
    update: XOR<GoalUpdateWithoutWorkspaceInput, GoalUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<GoalCreateWithoutWorkspaceInput, GoalUncheckedCreateWithoutWorkspaceInput>
  }

  export type GoalUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: GoalWhereUniqueInput
    data: XOR<GoalUpdateWithoutWorkspaceInput, GoalUncheckedUpdateWithoutWorkspaceInput>
  }

  export type GoalUpdateManyWithWhereWithoutWorkspaceInput = {
    where: GoalScalarWhereInput
    data: XOR<GoalUpdateManyMutationInput, GoalUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type GoalScalarWhereInput = {
    AND?: GoalScalarWhereInput | GoalScalarWhereInput[]
    OR?: GoalScalarWhereInput[]
    NOT?: GoalScalarWhereInput | GoalScalarWhereInput[]
    id?: StringFilter<"Goal"> | string
    workspaceId?: StringFilter<"Goal"> | string
    name?: StringFilter<"Goal"> | string
    description?: StringNullableFilter<"Goal"> | string | null
    type?: StringFilter<"Goal"> | string
    targetAmount?: FloatFilter<"Goal"> | number
    currentAmount?: FloatFilter<"Goal"> | number
    startDate?: DateTimeFilter<"Goal"> | Date | string
    targetDate?: DateTimeNullableFilter<"Goal"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Goal"> | Date | string | null
    status?: StringFilter<"Goal"> | string
    icon?: StringFilter<"Goal"> | string
    color?: StringFilter<"Goal"> | string
    autoAllocate?: BoolFilter<"Goal"> | boolean
    allocationPercentage?: FloatNullableFilter<"Goal"> | number | null
    createdAt?: DateTimeFilter<"Goal"> | Date | string
    updatedAt?: DateTimeFilter<"Goal"> | Date | string
  }

  export type BudgetUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: BudgetWhereUniqueInput
    update: XOR<BudgetUpdateWithoutWorkspaceInput, BudgetUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<BudgetCreateWithoutWorkspaceInput, BudgetUncheckedCreateWithoutWorkspaceInput>
  }

  export type BudgetUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: BudgetWhereUniqueInput
    data: XOR<BudgetUpdateWithoutWorkspaceInput, BudgetUncheckedUpdateWithoutWorkspaceInput>
  }

  export type BudgetUpdateManyWithWhereWithoutWorkspaceInput = {
    where: BudgetScalarWhereInput
    data: XOR<BudgetUpdateManyMutationInput, BudgetUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type BudgetScalarWhereInput = {
    AND?: BudgetScalarWhereInput | BudgetScalarWhereInput[]
    OR?: BudgetScalarWhereInput[]
    NOT?: BudgetScalarWhereInput | BudgetScalarWhereInput[]
    id?: StringFilter<"Budget"> | string
    workspaceId?: StringFilter<"Budget"> | string
    name?: StringFilter<"Budget"> | string
    description?: StringNullableFilter<"Budget"> | string | null
    startDate?: DateTimeFilter<"Budget"> | Date | string
    endDate?: DateTimeFilter<"Budget"> | Date | string
    totalBudgeted?: FloatFilter<"Budget"> | number
    totalSpent?: FloatFilter<"Budget"> | number
    isActive?: BoolFilter<"Budget"> | boolean
    alertThreshold?: IntFilter<"Budget"> | number
    alertSent?: BoolFilter<"Budget"> | boolean
    createdAt?: DateTimeFilter<"Budget"> | Date | string
    updatedAt?: DateTimeFilter<"Budget"> | Date | string
  }

  export type ImportJobUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: ImportJobWhereUniqueInput
    update: XOR<ImportJobUpdateWithoutWorkspaceInput, ImportJobUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<ImportJobCreateWithoutWorkspaceInput, ImportJobUncheckedCreateWithoutWorkspaceInput>
  }

  export type ImportJobUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: ImportJobWhereUniqueInput
    data: XOR<ImportJobUpdateWithoutWorkspaceInput, ImportJobUncheckedUpdateWithoutWorkspaceInput>
  }

  export type ImportJobUpdateManyWithWhereWithoutWorkspaceInput = {
    where: ImportJobScalarWhereInput
    data: XOR<ImportJobUpdateManyMutationInput, ImportJobUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type ImportJobScalarWhereInput = {
    AND?: ImportJobScalarWhereInput | ImportJobScalarWhereInput[]
    OR?: ImportJobScalarWhereInput[]
    NOT?: ImportJobScalarWhereInput | ImportJobScalarWhereInput[]
    id?: StringFilter<"ImportJob"> | string
    workspaceId?: StringFilter<"ImportJob"> | string
    accountId?: StringFilter<"ImportJob"> | string
    format?: StringFilter<"ImportJob"> | string
    fileName?: StringFilter<"ImportJob"> | string
    fileSize?: IntFilter<"ImportJob"> | number
    fileUrl?: StringNullableFilter<"ImportJob"> | string | null
    status?: StringFilter<"ImportJob"> | string
    progress?: IntFilter<"ImportJob"> | number
    totalRows?: IntFilter<"ImportJob"> | number
    processedRows?: IntFilter<"ImportJob"> | number
    importedRows?: IntFilter<"ImportJob"> | number
    errorLog?: StringNullableFilter<"ImportJob"> | string | null
    mappingConfig?: StringNullableFilter<"ImportJob"> | string | null
    startedAt?: DateTimeNullableFilter<"ImportJob"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"ImportJob"> | Date | string | null
    createdAt?: DateTimeFilter<"ImportJob"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutWorkspaceInput, AuditLogUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<AuditLogCreateWithoutWorkspaceInput, AuditLogUncheckedCreateWithoutWorkspaceInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutWorkspaceInput, AuditLogUncheckedUpdateWithoutWorkspaceInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutWorkspaceInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type EnvelopeUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: EnvelopeWhereUniqueInput
    update: XOR<EnvelopeUpdateWithoutWorkspaceInput, EnvelopeUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<EnvelopeCreateWithoutWorkspaceInput, EnvelopeUncheckedCreateWithoutWorkspaceInput>
  }

  export type EnvelopeUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: EnvelopeWhereUniqueInput
    data: XOR<EnvelopeUpdateWithoutWorkspaceInput, EnvelopeUncheckedUpdateWithoutWorkspaceInput>
  }

  export type EnvelopeUpdateManyWithWhereWithoutWorkspaceInput = {
    where: EnvelopeScalarWhereInput
    data: XOR<EnvelopeUpdateManyMutationInput, EnvelopeUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type EnvelopeScalarWhereInput = {
    AND?: EnvelopeScalarWhereInput | EnvelopeScalarWhereInput[]
    OR?: EnvelopeScalarWhereInput[]
    NOT?: EnvelopeScalarWhereInput | EnvelopeScalarWhereInput[]
    id?: StringFilter<"Envelope"> | string
    workspaceId?: StringFilter<"Envelope"> | string
    categoryId?: StringNullableFilter<"Envelope"> | string | null
    name?: StringFilter<"Envelope"> | string
    description?: StringNullableFilter<"Envelope"> | string | null
    color?: StringFilter<"Envelope"> | string
    budgetedAmount?: FloatFilter<"Envelope"> | number
    availableAmount?: FloatFilter<"Envelope"> | number
    spentAmount?: FloatFilter<"Envelope"> | number
    month?: IntFilter<"Envelope"> | number
    year?: IntFilter<"Envelope"> | number
    isActive?: BoolFilter<"Envelope"> | boolean
    createdAt?: DateTimeFilter<"Envelope"> | Date | string
    updatedAt?: DateTimeFilter<"Envelope"> | Date | string
  }

  export type AssetUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: AssetWhereUniqueInput
    update: XOR<AssetUpdateWithoutWorkspaceInput, AssetUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<AssetCreateWithoutWorkspaceInput, AssetUncheckedCreateWithoutWorkspaceInput>
  }

  export type AssetUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: AssetWhereUniqueInput
    data: XOR<AssetUpdateWithoutWorkspaceInput, AssetUncheckedUpdateWithoutWorkspaceInput>
  }

  export type AssetUpdateManyWithWhereWithoutWorkspaceInput = {
    where: AssetScalarWhereInput
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type AssetScalarWhereInput = {
    AND?: AssetScalarWhereInput | AssetScalarWhereInput[]
    OR?: AssetScalarWhereInput[]
    NOT?: AssetScalarWhereInput | AssetScalarWhereInput[]
    id?: StringFilter<"Asset"> | string
    workspaceId?: StringFilter<"Asset"> | string
    name?: StringFilter<"Asset"> | string
    type?: StringFilter<"Asset"> | string
    description?: StringNullableFilter<"Asset"> | string | null
    currentValue?: FloatFilter<"Asset"> | number
    purchaseValue?: FloatNullableFilter<"Asset"> | number | null
    purchaseDate?: DateTimeNullableFilter<"Asset"> | Date | string | null
    isActive?: BoolFilter<"Asset"> | boolean
    createdAt?: DateTimeFilter<"Asset"> | Date | string
    updatedAt?: DateTimeFilter<"Asset"> | Date | string
  }

  export type LiabilityUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: LiabilityWhereUniqueInput
    update: XOR<LiabilityUpdateWithoutWorkspaceInput, LiabilityUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<LiabilityCreateWithoutWorkspaceInput, LiabilityUncheckedCreateWithoutWorkspaceInput>
  }

  export type LiabilityUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: LiabilityWhereUniqueInput
    data: XOR<LiabilityUpdateWithoutWorkspaceInput, LiabilityUncheckedUpdateWithoutWorkspaceInput>
  }

  export type LiabilityUpdateManyWithWhereWithoutWorkspaceInput = {
    where: LiabilityScalarWhereInput
    data: XOR<LiabilityUpdateManyMutationInput, LiabilityUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type LiabilityScalarWhereInput = {
    AND?: LiabilityScalarWhereInput | LiabilityScalarWhereInput[]
    OR?: LiabilityScalarWhereInput[]
    NOT?: LiabilityScalarWhereInput | LiabilityScalarWhereInput[]
    id?: StringFilter<"Liability"> | string
    workspaceId?: StringFilter<"Liability"> | string
    name?: StringFilter<"Liability"> | string
    type?: StringFilter<"Liability"> | string
    description?: StringNullableFilter<"Liability"> | string | null
    currentBalance?: FloatFilter<"Liability"> | number
    originalAmount?: FloatFilter<"Liability"> | number
    interestRate?: FloatNullableFilter<"Liability"> | number | null
    startDate?: DateTimeFilter<"Liability"> | Date | string
    endDate?: DateTimeNullableFilter<"Liability"> | Date | string | null
    isActive?: BoolFilter<"Liability"> | boolean
    createdAt?: DateTimeFilter<"Liability"> | Date | string
    updatedAt?: DateTimeFilter<"Liability"> | Date | string
  }

  export type AIInsightUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: AIInsightWhereUniqueInput
    update: XOR<AIInsightUpdateWithoutWorkspaceInput, AIInsightUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<AIInsightCreateWithoutWorkspaceInput, AIInsightUncheckedCreateWithoutWorkspaceInput>
  }

  export type AIInsightUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: AIInsightWhereUniqueInput
    data: XOR<AIInsightUpdateWithoutWorkspaceInput, AIInsightUncheckedUpdateWithoutWorkspaceInput>
  }

  export type AIInsightUpdateManyWithWhereWithoutWorkspaceInput = {
    where: AIInsightScalarWhereInput
    data: XOR<AIInsightUpdateManyMutationInput, AIInsightUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type ScenarioUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: ScenarioWhereUniqueInput
    update: XOR<ScenarioUpdateWithoutWorkspaceInput, ScenarioUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<ScenarioCreateWithoutWorkspaceInput, ScenarioUncheckedCreateWithoutWorkspaceInput>
  }

  export type ScenarioUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: ScenarioWhereUniqueInput
    data: XOR<ScenarioUpdateWithoutWorkspaceInput, ScenarioUncheckedUpdateWithoutWorkspaceInput>
  }

  export type ScenarioUpdateManyWithWhereWithoutWorkspaceInput = {
    where: ScenarioScalarWhereInput
    data: XOR<ScenarioUpdateManyMutationInput, ScenarioUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type BankConnectionUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: BankConnectionWhereUniqueInput
    update: XOR<BankConnectionUpdateWithoutWorkspaceInput, BankConnectionUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<BankConnectionCreateWithoutWorkspaceInput, BankConnectionUncheckedCreateWithoutWorkspaceInput>
  }

  export type BankConnectionUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: BankConnectionWhereUniqueInput
    data: XOR<BankConnectionUpdateWithoutWorkspaceInput, BankConnectionUncheckedUpdateWithoutWorkspaceInput>
  }

  export type BankConnectionUpdateManyWithWhereWithoutWorkspaceInput = {
    where: BankConnectionScalarWhereInput
    data: XOR<BankConnectionUpdateManyMutationInput, BankConnectionUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type BankConnectionScalarWhereInput = {
    AND?: BankConnectionScalarWhereInput | BankConnectionScalarWhereInput[]
    OR?: BankConnectionScalarWhereInput[]
    NOT?: BankConnectionScalarWhereInput | BankConnectionScalarWhereInput[]
    id?: StringFilter<"BankConnection"> | string
    workspaceId?: StringFilter<"BankConnection"> | string
    accountId?: StringFilter<"BankConnection"> | string
    bankName?: StringFilter<"BankConnection"> | string
    bankCode?: StringFilter<"BankConnection"> | string
    accessToken?: StringFilter<"BankConnection"> | string
    status?: StringFilter<"BankConnection"> | string
    lastSyncAt?: DateTimeNullableFilter<"BankConnection"> | Date | string | null
    lastSyncError?: StringNullableFilter<"BankConnection"> | string | null
    isActive?: BoolFilter<"BankConnection"> | boolean
    createdAt?: DateTimeFilter<"BankConnection"> | Date | string
    updatedAt?: DateTimeFilter<"BankConnection"> | Date | string
  }

  export type AutoRuleUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: AutoRuleWhereUniqueInput
    update: XOR<AutoRuleUpdateWithoutWorkspaceInput, AutoRuleUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<AutoRuleCreateWithoutWorkspaceInput, AutoRuleUncheckedCreateWithoutWorkspaceInput>
  }

  export type AutoRuleUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: AutoRuleWhereUniqueInput
    data: XOR<AutoRuleUpdateWithoutWorkspaceInput, AutoRuleUncheckedUpdateWithoutWorkspaceInput>
  }

  export type AutoRuleUpdateManyWithWhereWithoutWorkspaceInput = {
    where: AutoRuleScalarWhereInput
    data: XOR<AutoRuleUpdateManyMutationInput, AutoRuleUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type CashFlowProjectionUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: CashFlowProjectionWhereUniqueInput
    update: XOR<CashFlowProjectionUpdateWithoutWorkspaceInput, CashFlowProjectionUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<CashFlowProjectionCreateWithoutWorkspaceInput, CashFlowProjectionUncheckedCreateWithoutWorkspaceInput>
  }

  export type CashFlowProjectionUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: CashFlowProjectionWhereUniqueInput
    data: XOR<CashFlowProjectionUpdateWithoutWorkspaceInput, CashFlowProjectionUncheckedUpdateWithoutWorkspaceInput>
  }

  export type CashFlowProjectionUpdateManyWithWhereWithoutWorkspaceInput = {
    where: CashFlowProjectionScalarWhereInput
    data: XOR<CashFlowProjectionUpdateManyMutationInput, CashFlowProjectionUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type CashFlowProjectionScalarWhereInput = {
    AND?: CashFlowProjectionScalarWhereInput | CashFlowProjectionScalarWhereInput[]
    OR?: CashFlowProjectionScalarWhereInput[]
    NOT?: CashFlowProjectionScalarWhereInput | CashFlowProjectionScalarWhereInput[]
    id?: StringFilter<"CashFlowProjection"> | string
    workspaceId?: StringFilter<"CashFlowProjection"> | string
    month?: IntFilter<"CashFlowProjection"> | number
    year?: IntFilter<"CashFlowProjection"> | number
    projectedIncome?: FloatFilter<"CashFlowProjection"> | number
    projectedExpense?: FloatFilter<"CashFlowProjection"> | number
    projectedBalance?: FloatFilter<"CashFlowProjection"> | number
    generatedAt?: DateTimeFilter<"CashFlowProjection"> | Date | string
    updatedAt?: DateTimeFilter<"CashFlowProjection"> | Date | string
  }

  export type TransactionUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutWorkspaceInput, TransactionUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<TransactionCreateWithoutWorkspaceInput, TransactionUncheckedCreateWithoutWorkspaceInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutWorkspaceInput, TransactionUncheckedUpdateWithoutWorkspaceInput>
  }

  export type TransactionUpdateManyWithWhereWithoutWorkspaceInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: StringFilter<"Transaction"> | string
    workspaceId?: StringFilter<"Transaction"> | string
    accountId?: StringFilter<"Transaction"> | string
    categoryId?: StringNullableFilter<"Transaction"> | string | null
    creditCardId?: StringNullableFilter<"Transaction"> | string | null
    type?: StringFilter<"Transaction"> | string
    description?: StringFilter<"Transaction"> | string
    amount?: FloatFilter<"Transaction"> | number
    currency?: StringFilter<"Transaction"> | string
    status?: StringFilter<"Transaction"> | string
    transactionDate?: DateTimeFilter<"Transaction"> | Date | string
    confirmedAt?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    recurrenceId?: StringNullableFilter<"Transaction"> | string | null
    notes?: StringNullableFilter<"Transaction"> | string | null
    tags?: StringFilter<"Transaction"> | string
    attachmentUrl?: StringNullableFilter<"Transaction"> | string | null
    location?: StringNullableFilter<"Transaction"> | string | null
    importId?: StringNullableFilter<"Transaction"> | string | null
    rawData?: StringNullableFilter<"Transaction"> | string | null
    aiConfidence?: FloatNullableFilter<"Transaction"> | number | null
    aiCategory?: StringNullableFilter<"Transaction"> | string | null
    aiCategorizedAt?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    aiModelVersion?: StringNullableFilter<"Transaction"> | string | null
    autoRuleId?: StringNullableFilter<"Transaction"> | string | null
    bankConnectionId?: StringNullableFilter<"Transaction"> | string | null
    externalId?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
  }

  export type WorkspaceCreateWithoutMembersInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    type: string
    currency?: string
    timezone?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutWorkspaceInput
    categories?: CategoryCreateNestedManyWithoutWorkspaceInput
    goals?: GoalCreateNestedManyWithoutWorkspaceInput
    budgets?: BudgetCreateNestedManyWithoutWorkspaceInput
    imports?: ImportJobCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogCreateNestedManyWithoutWorkspaceInput
    envelopes?: EnvelopeCreateNestedManyWithoutWorkspaceInput
    assets?: AssetCreateNestedManyWithoutWorkspaceInput
    liabilities?: LiabilityCreateNestedManyWithoutWorkspaceInput
    aiInsights?: AIInsightCreateNestedManyWithoutWorkspaceInput
    scenarios?: ScenarioCreateNestedManyWithoutWorkspaceInput
    bankConnections?: BankConnectionCreateNestedManyWithoutWorkspaceInput
    autoRules?: AutoRuleCreateNestedManyWithoutWorkspaceInput
    cashFlowProjections?: CashFlowProjectionCreateNestedManyWithoutWorkspaceInput
    Transaction?: TransactionCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    type: string
    currency?: string
    timezone?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutWorkspaceInput
    categories?: CategoryUncheckedCreateNestedManyWithoutWorkspaceInput
    goals?: GoalUncheckedCreateNestedManyWithoutWorkspaceInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutWorkspaceInput
    imports?: ImportJobUncheckedCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutWorkspaceInput
    envelopes?: EnvelopeUncheckedCreateNestedManyWithoutWorkspaceInput
    assets?: AssetUncheckedCreateNestedManyWithoutWorkspaceInput
    liabilities?: LiabilityUncheckedCreateNestedManyWithoutWorkspaceInput
    aiInsights?: AIInsightUncheckedCreateNestedManyWithoutWorkspaceInput
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutWorkspaceInput
    bankConnections?: BankConnectionUncheckedCreateNestedManyWithoutWorkspaceInput
    autoRules?: AutoRuleUncheckedCreateNestedManyWithoutWorkspaceInput
    cashFlowProjections?: CashFlowProjectionUncheckedCreateNestedManyWithoutWorkspaceInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutMembersInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutMembersInput, WorkspaceUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutWorkspacesInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    avatarUrl?: string | null
    phone?: string | null
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    gamification?: UserGamificationCreateNestedOneWithoutUserInput
    aiInsights?: AIInsightCreateNestedManyWithoutUserInput
    scenarios?: ScenarioCreateNestedManyWithoutUserInput
    autoRules?: AutoRuleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWorkspacesInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    avatarUrl?: string | null
    phone?: string | null
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    gamification?: UserGamificationUncheckedCreateNestedOneWithoutUserInput
    aiInsights?: AIInsightUncheckedCreateNestedManyWithoutUserInput
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutUserInput
    autoRules?: AutoRuleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWorkspacesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWorkspacesInput, UserUncheckedCreateWithoutWorkspacesInput>
  }

  export type WorkspaceUpsertWithoutMembersInput = {
    update: XOR<WorkspaceUpdateWithoutMembersInput, WorkspaceUncheckedUpdateWithoutMembersInput>
    create: XOR<WorkspaceCreateWithoutMembersInput, WorkspaceUncheckedCreateWithoutMembersInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutMembersInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutMembersInput, WorkspaceUncheckedUpdateWithoutMembersInput>
  }

  export type WorkspaceUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutWorkspaceNestedInput
    categories?: CategoryUpdateManyWithoutWorkspaceNestedInput
    goals?: GoalUpdateManyWithoutWorkspaceNestedInput
    budgets?: BudgetUpdateManyWithoutWorkspaceNestedInput
    imports?: ImportJobUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUpdateManyWithoutWorkspaceNestedInput
    envelopes?: EnvelopeUpdateManyWithoutWorkspaceNestedInput
    assets?: AssetUpdateManyWithoutWorkspaceNestedInput
    liabilities?: LiabilityUpdateManyWithoutWorkspaceNestedInput
    aiInsights?: AIInsightUpdateManyWithoutWorkspaceNestedInput
    scenarios?: ScenarioUpdateManyWithoutWorkspaceNestedInput
    bankConnections?: BankConnectionUpdateManyWithoutWorkspaceNestedInput
    autoRules?: AutoRuleUpdateManyWithoutWorkspaceNestedInput
    cashFlowProjections?: CashFlowProjectionUpdateManyWithoutWorkspaceNestedInput
    Transaction?: TransactionUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutWorkspaceNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutWorkspaceNestedInput
    goals?: GoalUncheckedUpdateManyWithoutWorkspaceNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutWorkspaceNestedInput
    imports?: ImportJobUncheckedUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutWorkspaceNestedInput
    envelopes?: EnvelopeUncheckedUpdateManyWithoutWorkspaceNestedInput
    assets?: AssetUncheckedUpdateManyWithoutWorkspaceNestedInput
    liabilities?: LiabilityUncheckedUpdateManyWithoutWorkspaceNestedInput
    aiInsights?: AIInsightUncheckedUpdateManyWithoutWorkspaceNestedInput
    scenarios?: ScenarioUncheckedUpdateManyWithoutWorkspaceNestedInput
    bankConnections?: BankConnectionUncheckedUpdateManyWithoutWorkspaceNestedInput
    autoRules?: AutoRuleUncheckedUpdateManyWithoutWorkspaceNestedInput
    cashFlowProjections?: CashFlowProjectionUncheckedUpdateManyWithoutWorkspaceNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type UserUpsertWithoutWorkspacesInput = {
    update: XOR<UserUpdateWithoutWorkspacesInput, UserUncheckedUpdateWithoutWorkspacesInput>
    create: XOR<UserCreateWithoutWorkspacesInput, UserUncheckedCreateWithoutWorkspacesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWorkspacesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWorkspacesInput, UserUncheckedUpdateWithoutWorkspacesInput>
  }

  export type UserUpdateWithoutWorkspacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    gamification?: UserGamificationUpdateOneWithoutUserNestedInput
    aiInsights?: AIInsightUpdateManyWithoutUserNestedInput
    scenarios?: ScenarioUpdateManyWithoutUserNestedInput
    autoRules?: AutoRuleUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWorkspacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    gamification?: UserGamificationUncheckedUpdateOneWithoutUserNestedInput
    aiInsights?: AIInsightUncheckedUpdateManyWithoutUserNestedInput
    scenarios?: ScenarioUncheckedUpdateManyWithoutUserNestedInput
    autoRules?: AutoRuleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WorkspaceCreateWithoutAccountsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    type: string
    currency?: string
    timezone?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberCreateNestedManyWithoutWorkspaceInput
    categories?: CategoryCreateNestedManyWithoutWorkspaceInput
    goals?: GoalCreateNestedManyWithoutWorkspaceInput
    budgets?: BudgetCreateNestedManyWithoutWorkspaceInput
    imports?: ImportJobCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogCreateNestedManyWithoutWorkspaceInput
    envelopes?: EnvelopeCreateNestedManyWithoutWorkspaceInput
    assets?: AssetCreateNestedManyWithoutWorkspaceInput
    liabilities?: LiabilityCreateNestedManyWithoutWorkspaceInput
    aiInsights?: AIInsightCreateNestedManyWithoutWorkspaceInput
    scenarios?: ScenarioCreateNestedManyWithoutWorkspaceInput
    bankConnections?: BankConnectionCreateNestedManyWithoutWorkspaceInput
    autoRules?: AutoRuleCreateNestedManyWithoutWorkspaceInput
    cashFlowProjections?: CashFlowProjectionCreateNestedManyWithoutWorkspaceInput
    Transaction?: TransactionCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutAccountsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    type: string
    currency?: string
    timezone?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberUncheckedCreateNestedManyWithoutWorkspaceInput
    categories?: CategoryUncheckedCreateNestedManyWithoutWorkspaceInput
    goals?: GoalUncheckedCreateNestedManyWithoutWorkspaceInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutWorkspaceInput
    imports?: ImportJobUncheckedCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutWorkspaceInput
    envelopes?: EnvelopeUncheckedCreateNestedManyWithoutWorkspaceInput
    assets?: AssetUncheckedCreateNestedManyWithoutWorkspaceInput
    liabilities?: LiabilityUncheckedCreateNestedManyWithoutWorkspaceInput
    aiInsights?: AIInsightUncheckedCreateNestedManyWithoutWorkspaceInput
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutWorkspaceInput
    bankConnections?: BankConnectionUncheckedCreateNestedManyWithoutWorkspaceInput
    autoRules?: AutoRuleUncheckedCreateNestedManyWithoutWorkspaceInput
    cashFlowProjections?: CashFlowProjectionUncheckedCreateNestedManyWithoutWorkspaceInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutAccountsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutAccountsInput, WorkspaceUncheckedCreateWithoutAccountsInput>
  }

  export type TransactionCreateWithoutAccountInput = {
    id?: string
    creditCardId?: string | null
    type: string
    description: string
    amount: number
    currency?: string
    status: string
    transactionDate: Date | string
    confirmedAt?: Date | string | null
    recurrenceId?: string | null
    notes?: string | null
    tags: string
    attachmentUrl?: string | null
    location?: string | null
    importId?: string | null
    rawData?: string | null
    aiConfidence?: number | null
    aiCategory?: string | null
    aiCategorizedAt?: Date | string | null
    aiModelVersion?: string | null
    autoRuleId?: string | null
    bankConnectionId?: string | null
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutTransactionInput
    category?: CategoryCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutAccountInput = {
    id?: string
    workspaceId: string
    categoryId?: string | null
    creditCardId?: string | null
    type: string
    description: string
    amount: number
    currency?: string
    status: string
    transactionDate: Date | string
    confirmedAt?: Date | string | null
    recurrenceId?: string | null
    notes?: string | null
    tags: string
    attachmentUrl?: string | null
    location?: string | null
    importId?: string | null
    rawData?: string | null
    aiConfidence?: number | null
    aiCategory?: string | null
    aiCategorizedAt?: Date | string | null
    aiModelVersion?: string | null
    autoRuleId?: string | null
    bankConnectionId?: string | null
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutAccountInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutAccountInput, TransactionUncheckedCreateWithoutAccountInput>
  }

  export type TransactionCreateManyAccountInputEnvelope = {
    data: TransactionCreateManyAccountInput | TransactionCreateManyAccountInput[]
  }

  export type TransferCreateWithoutFromAccountInput = {
    id?: string
    workspaceId: string
    description: string
    amount: number
    fee?: number | null
    transferDate: Date | string
    createdAt?: Date | string
    toAccount: AccountCreateNestedOneWithoutToTransfersInput
  }

  export type TransferUncheckedCreateWithoutFromAccountInput = {
    id?: string
    workspaceId: string
    toAccountId: string
    description: string
    amount: number
    fee?: number | null
    transferDate: Date | string
    createdAt?: Date | string
  }

  export type TransferCreateOrConnectWithoutFromAccountInput = {
    where: TransferWhereUniqueInput
    create: XOR<TransferCreateWithoutFromAccountInput, TransferUncheckedCreateWithoutFromAccountInput>
  }

  export type TransferCreateManyFromAccountInputEnvelope = {
    data: TransferCreateManyFromAccountInput | TransferCreateManyFromAccountInput[]
  }

  export type TransferCreateWithoutToAccountInput = {
    id?: string
    workspaceId: string
    description: string
    amount: number
    fee?: number | null
    transferDate: Date | string
    createdAt?: Date | string
    fromAccount: AccountCreateNestedOneWithoutFromTransfersInput
  }

  export type TransferUncheckedCreateWithoutToAccountInput = {
    id?: string
    workspaceId: string
    fromAccountId: string
    description: string
    amount: number
    fee?: number | null
    transferDate: Date | string
    createdAt?: Date | string
  }

  export type TransferCreateOrConnectWithoutToAccountInput = {
    where: TransferWhereUniqueInput
    create: XOR<TransferCreateWithoutToAccountInput, TransferUncheckedCreateWithoutToAccountInput>
  }

  export type TransferCreateManyToAccountInputEnvelope = {
    data: TransferCreateManyToAccountInput | TransferCreateManyToAccountInput[]
  }

  export type BankConnectionCreateWithoutAccountInput = {
    id?: string
    bankName: string
    bankCode: string
    accessToken: string
    status: string
    lastSyncAt?: Date | string | null
    lastSyncError?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Workspace: WorkspaceCreateNestedOneWithoutBankConnectionsInput
  }

  export type BankConnectionUncheckedCreateWithoutAccountInput = {
    id?: string
    workspaceId: string
    bankName: string
    bankCode: string
    accessToken: string
    status: string
    lastSyncAt?: Date | string | null
    lastSyncError?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankConnectionCreateOrConnectWithoutAccountInput = {
    where: BankConnectionWhereUniqueInput
    create: XOR<BankConnectionCreateWithoutAccountInput, BankConnectionUncheckedCreateWithoutAccountInput>
  }

  export type BankConnectionCreateManyAccountInputEnvelope = {
    data: BankConnectionCreateManyAccountInput | BankConnectionCreateManyAccountInput[]
  }

  export type WorkspaceUpsertWithoutAccountsInput = {
    update: XOR<WorkspaceUpdateWithoutAccountsInput, WorkspaceUncheckedUpdateWithoutAccountsInput>
    create: XOR<WorkspaceCreateWithoutAccountsInput, WorkspaceUncheckedCreateWithoutAccountsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutAccountsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutAccountsInput, WorkspaceUncheckedUpdateWithoutAccountsInput>
  }

  export type WorkspaceUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUpdateManyWithoutWorkspaceNestedInput
    categories?: CategoryUpdateManyWithoutWorkspaceNestedInput
    goals?: GoalUpdateManyWithoutWorkspaceNestedInput
    budgets?: BudgetUpdateManyWithoutWorkspaceNestedInput
    imports?: ImportJobUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUpdateManyWithoutWorkspaceNestedInput
    envelopes?: EnvelopeUpdateManyWithoutWorkspaceNestedInput
    assets?: AssetUpdateManyWithoutWorkspaceNestedInput
    liabilities?: LiabilityUpdateManyWithoutWorkspaceNestedInput
    aiInsights?: AIInsightUpdateManyWithoutWorkspaceNestedInput
    scenarios?: ScenarioUpdateManyWithoutWorkspaceNestedInput
    bankConnections?: BankConnectionUpdateManyWithoutWorkspaceNestedInput
    autoRules?: AutoRuleUpdateManyWithoutWorkspaceNestedInput
    cashFlowProjections?: CashFlowProjectionUpdateManyWithoutWorkspaceNestedInput
    Transaction?: TransactionUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUncheckedUpdateManyWithoutWorkspaceNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutWorkspaceNestedInput
    goals?: GoalUncheckedUpdateManyWithoutWorkspaceNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutWorkspaceNestedInput
    imports?: ImportJobUncheckedUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutWorkspaceNestedInput
    envelopes?: EnvelopeUncheckedUpdateManyWithoutWorkspaceNestedInput
    assets?: AssetUncheckedUpdateManyWithoutWorkspaceNestedInput
    liabilities?: LiabilityUncheckedUpdateManyWithoutWorkspaceNestedInput
    aiInsights?: AIInsightUncheckedUpdateManyWithoutWorkspaceNestedInput
    scenarios?: ScenarioUncheckedUpdateManyWithoutWorkspaceNestedInput
    bankConnections?: BankConnectionUncheckedUpdateManyWithoutWorkspaceNestedInput
    autoRules?: AutoRuleUncheckedUpdateManyWithoutWorkspaceNestedInput
    cashFlowProjections?: CashFlowProjectionUncheckedUpdateManyWithoutWorkspaceNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type TransactionUpsertWithWhereUniqueWithoutAccountInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutAccountInput, TransactionUncheckedUpdateWithoutAccountInput>
    create: XOR<TransactionCreateWithoutAccountInput, TransactionUncheckedCreateWithoutAccountInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutAccountInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutAccountInput, TransactionUncheckedUpdateWithoutAccountInput>
  }

  export type TransactionUpdateManyWithWhereWithoutAccountInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutAccountInput>
  }

  export type TransferUpsertWithWhereUniqueWithoutFromAccountInput = {
    where: TransferWhereUniqueInput
    update: XOR<TransferUpdateWithoutFromAccountInput, TransferUncheckedUpdateWithoutFromAccountInput>
    create: XOR<TransferCreateWithoutFromAccountInput, TransferUncheckedCreateWithoutFromAccountInput>
  }

  export type TransferUpdateWithWhereUniqueWithoutFromAccountInput = {
    where: TransferWhereUniqueInput
    data: XOR<TransferUpdateWithoutFromAccountInput, TransferUncheckedUpdateWithoutFromAccountInput>
  }

  export type TransferUpdateManyWithWhereWithoutFromAccountInput = {
    where: TransferScalarWhereInput
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyWithoutFromAccountInput>
  }

  export type TransferScalarWhereInput = {
    AND?: TransferScalarWhereInput | TransferScalarWhereInput[]
    OR?: TransferScalarWhereInput[]
    NOT?: TransferScalarWhereInput | TransferScalarWhereInput[]
    id?: StringFilter<"Transfer"> | string
    workspaceId?: StringFilter<"Transfer"> | string
    fromAccountId?: StringFilter<"Transfer"> | string
    toAccountId?: StringFilter<"Transfer"> | string
    description?: StringFilter<"Transfer"> | string
    amount?: FloatFilter<"Transfer"> | number
    fee?: FloatNullableFilter<"Transfer"> | number | null
    transferDate?: DateTimeFilter<"Transfer"> | Date | string
    createdAt?: DateTimeFilter<"Transfer"> | Date | string
  }

  export type TransferUpsertWithWhereUniqueWithoutToAccountInput = {
    where: TransferWhereUniqueInput
    update: XOR<TransferUpdateWithoutToAccountInput, TransferUncheckedUpdateWithoutToAccountInput>
    create: XOR<TransferCreateWithoutToAccountInput, TransferUncheckedCreateWithoutToAccountInput>
  }

  export type TransferUpdateWithWhereUniqueWithoutToAccountInput = {
    where: TransferWhereUniqueInput
    data: XOR<TransferUpdateWithoutToAccountInput, TransferUncheckedUpdateWithoutToAccountInput>
  }

  export type TransferUpdateManyWithWhereWithoutToAccountInput = {
    where: TransferScalarWhereInput
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyWithoutToAccountInput>
  }

  export type BankConnectionUpsertWithWhereUniqueWithoutAccountInput = {
    where: BankConnectionWhereUniqueInput
    update: XOR<BankConnectionUpdateWithoutAccountInput, BankConnectionUncheckedUpdateWithoutAccountInput>
    create: XOR<BankConnectionCreateWithoutAccountInput, BankConnectionUncheckedCreateWithoutAccountInput>
  }

  export type BankConnectionUpdateWithWhereUniqueWithoutAccountInput = {
    where: BankConnectionWhereUniqueInput
    data: XOR<BankConnectionUpdateWithoutAccountInput, BankConnectionUncheckedUpdateWithoutAccountInput>
  }

  export type BankConnectionUpdateManyWithWhereWithoutAccountInput = {
    where: BankConnectionScalarWhereInput
    data: XOR<BankConnectionUpdateManyMutationInput, BankConnectionUncheckedUpdateManyWithoutAccountInput>
  }

  export type WorkspaceCreateWithoutCategoriesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    type: string
    currency?: string
    timezone?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberCreateNestedManyWithoutWorkspaceInput
    accounts?: AccountCreateNestedManyWithoutWorkspaceInput
    goals?: GoalCreateNestedManyWithoutWorkspaceInput
    budgets?: BudgetCreateNestedManyWithoutWorkspaceInput
    imports?: ImportJobCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogCreateNestedManyWithoutWorkspaceInput
    envelopes?: EnvelopeCreateNestedManyWithoutWorkspaceInput
    assets?: AssetCreateNestedManyWithoutWorkspaceInput
    liabilities?: LiabilityCreateNestedManyWithoutWorkspaceInput
    aiInsights?: AIInsightCreateNestedManyWithoutWorkspaceInput
    scenarios?: ScenarioCreateNestedManyWithoutWorkspaceInput
    bankConnections?: BankConnectionCreateNestedManyWithoutWorkspaceInput
    autoRules?: AutoRuleCreateNestedManyWithoutWorkspaceInput
    cashFlowProjections?: CashFlowProjectionCreateNestedManyWithoutWorkspaceInput
    Transaction?: TransactionCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutCategoriesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    type: string
    currency?: string
    timezone?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberUncheckedCreateNestedManyWithoutWorkspaceInput
    accounts?: AccountUncheckedCreateNestedManyWithoutWorkspaceInput
    goals?: GoalUncheckedCreateNestedManyWithoutWorkspaceInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutWorkspaceInput
    imports?: ImportJobUncheckedCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutWorkspaceInput
    envelopes?: EnvelopeUncheckedCreateNestedManyWithoutWorkspaceInput
    assets?: AssetUncheckedCreateNestedManyWithoutWorkspaceInput
    liabilities?: LiabilityUncheckedCreateNestedManyWithoutWorkspaceInput
    aiInsights?: AIInsightUncheckedCreateNestedManyWithoutWorkspaceInput
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutWorkspaceInput
    bankConnections?: BankConnectionUncheckedCreateNestedManyWithoutWorkspaceInput
    autoRules?: AutoRuleUncheckedCreateNestedManyWithoutWorkspaceInput
    cashFlowProjections?: CashFlowProjectionUncheckedCreateNestedManyWithoutWorkspaceInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutCategoriesInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutCategoriesInput, WorkspaceUncheckedCreateWithoutCategoriesInput>
  }

  export type CategoryCreateWithoutChildrenInput = {
    id?: string
    name: string
    type: string
    color?: string
    icon?: string
    description?: string | null
    keywords: string
    isSystem?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutCategoriesInput
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    transactions?: TransactionCreateNestedManyWithoutCategoryInput
    budgets?: BudgetCategoryCreateNestedManyWithoutCategoryInput
    envelopes?: EnvelopeCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutChildrenInput = {
    id?: string
    workspaceId: string
    parentId?: string | null
    name: string
    type: string
    color?: string
    icon?: string
    description?: string | null
    keywords: string
    isSystem?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutCategoryInput
    budgets?: BudgetCategoryUncheckedCreateNestedManyWithoutCategoryInput
    envelopes?: EnvelopeUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutChildrenInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
  }

  export type CategoryCreateWithoutParentInput = {
    id?: string
    name: string
    type: string
    color?: string
    icon?: string
    description?: string | null
    keywords: string
    isSystem?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutCategoriesInput
    children?: CategoryCreateNestedManyWithoutParentInput
    transactions?: TransactionCreateNestedManyWithoutCategoryInput
    budgets?: BudgetCategoryCreateNestedManyWithoutCategoryInput
    envelopes?: EnvelopeCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutParentInput = {
    id?: string
    workspaceId: string
    name: string
    type: string
    color?: string
    icon?: string
    description?: string | null
    keywords: string
    isSystem?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCategoryInput
    budgets?: BudgetCategoryUncheckedCreateNestedManyWithoutCategoryInput
    envelopes?: EnvelopeUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutParentInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput>
  }

  export type CategoryCreateManyParentInputEnvelope = {
    data: CategoryCreateManyParentInput | CategoryCreateManyParentInput[]
  }

  export type TransactionCreateWithoutCategoryInput = {
    id?: string
    creditCardId?: string | null
    type: string
    description: string
    amount: number
    currency?: string
    status: string
    transactionDate: Date | string
    confirmedAt?: Date | string | null
    recurrenceId?: string | null
    notes?: string | null
    tags: string
    attachmentUrl?: string | null
    location?: string | null
    importId?: string | null
    rawData?: string | null
    aiConfidence?: number | null
    aiCategory?: string | null
    aiCategorizedAt?: Date | string | null
    aiModelVersion?: string | null
    autoRuleId?: string | null
    bankConnectionId?: string | null
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutTransactionInput
    account: AccountCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutCategoryInput = {
    id?: string
    workspaceId: string
    accountId: string
    creditCardId?: string | null
    type: string
    description: string
    amount: number
    currency?: string
    status: string
    transactionDate: Date | string
    confirmedAt?: Date | string | null
    recurrenceId?: string | null
    notes?: string | null
    tags: string
    attachmentUrl?: string | null
    location?: string | null
    importId?: string | null
    rawData?: string | null
    aiConfidence?: number | null
    aiCategory?: string | null
    aiCategorizedAt?: Date | string | null
    aiModelVersion?: string | null
    autoRuleId?: string | null
    bankConnectionId?: string | null
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutCategoryInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutCategoryInput, TransactionUncheckedCreateWithoutCategoryInput>
  }

  export type TransactionCreateManyCategoryInputEnvelope = {
    data: TransactionCreateManyCategoryInput | TransactionCreateManyCategoryInput[]
  }

  export type BudgetCategoryCreateWithoutCategoryInput = {
    id?: string
    budgeted: number
    spent?: number
    budget: BudgetCreateNestedOneWithoutCategoriesInput
  }

  export type BudgetCategoryUncheckedCreateWithoutCategoryInput = {
    id?: string
    budgetId: string
    budgeted: number
    spent?: number
  }

  export type BudgetCategoryCreateOrConnectWithoutCategoryInput = {
    where: BudgetCategoryWhereUniqueInput
    create: XOR<BudgetCategoryCreateWithoutCategoryInput, BudgetCategoryUncheckedCreateWithoutCategoryInput>
  }

  export type BudgetCategoryCreateManyCategoryInputEnvelope = {
    data: BudgetCategoryCreateManyCategoryInput | BudgetCategoryCreateManyCategoryInput[]
  }

  export type EnvelopeCreateWithoutCategoryInput = {
    id?: string
    name: string
    description?: string | null
    color?: string
    budgetedAmount: number
    availableAmount?: number
    spentAmount?: number
    month: number
    year: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Workspace: WorkspaceCreateNestedOneWithoutEnvelopesInput
  }

  export type EnvelopeUncheckedCreateWithoutCategoryInput = {
    id?: string
    workspaceId: string
    name: string
    description?: string | null
    color?: string
    budgetedAmount: number
    availableAmount?: number
    spentAmount?: number
    month: number
    year: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EnvelopeCreateOrConnectWithoutCategoryInput = {
    where: EnvelopeWhereUniqueInput
    create: XOR<EnvelopeCreateWithoutCategoryInput, EnvelopeUncheckedCreateWithoutCategoryInput>
  }

  export type EnvelopeCreateManyCategoryInputEnvelope = {
    data: EnvelopeCreateManyCategoryInput | EnvelopeCreateManyCategoryInput[]
  }

  export type WorkspaceUpsertWithoutCategoriesInput = {
    update: XOR<WorkspaceUpdateWithoutCategoriesInput, WorkspaceUncheckedUpdateWithoutCategoriesInput>
    create: XOR<WorkspaceCreateWithoutCategoriesInput, WorkspaceUncheckedCreateWithoutCategoriesInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutCategoriesInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutCategoriesInput, WorkspaceUncheckedUpdateWithoutCategoriesInput>
  }

  export type WorkspaceUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUpdateManyWithoutWorkspaceNestedInput
    accounts?: AccountUpdateManyWithoutWorkspaceNestedInput
    goals?: GoalUpdateManyWithoutWorkspaceNestedInput
    budgets?: BudgetUpdateManyWithoutWorkspaceNestedInput
    imports?: ImportJobUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUpdateManyWithoutWorkspaceNestedInput
    envelopes?: EnvelopeUpdateManyWithoutWorkspaceNestedInput
    assets?: AssetUpdateManyWithoutWorkspaceNestedInput
    liabilities?: LiabilityUpdateManyWithoutWorkspaceNestedInput
    aiInsights?: AIInsightUpdateManyWithoutWorkspaceNestedInput
    scenarios?: ScenarioUpdateManyWithoutWorkspaceNestedInput
    bankConnections?: BankConnectionUpdateManyWithoutWorkspaceNestedInput
    autoRules?: AutoRuleUpdateManyWithoutWorkspaceNestedInput
    cashFlowProjections?: CashFlowProjectionUpdateManyWithoutWorkspaceNestedInput
    Transaction?: TransactionUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUncheckedUpdateManyWithoutWorkspaceNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutWorkspaceNestedInput
    goals?: GoalUncheckedUpdateManyWithoutWorkspaceNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutWorkspaceNestedInput
    imports?: ImportJobUncheckedUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutWorkspaceNestedInput
    envelopes?: EnvelopeUncheckedUpdateManyWithoutWorkspaceNestedInput
    assets?: AssetUncheckedUpdateManyWithoutWorkspaceNestedInput
    liabilities?: LiabilityUncheckedUpdateManyWithoutWorkspaceNestedInput
    aiInsights?: AIInsightUncheckedUpdateManyWithoutWorkspaceNestedInput
    scenarios?: ScenarioUncheckedUpdateManyWithoutWorkspaceNestedInput
    bankConnections?: BankConnectionUncheckedUpdateManyWithoutWorkspaceNestedInput
    autoRules?: AutoRuleUncheckedUpdateManyWithoutWorkspaceNestedInput
    cashFlowProjections?: CashFlowProjectionUncheckedUpdateManyWithoutWorkspaceNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type CategoryUpsertWithoutChildrenInput = {
    update: XOR<CategoryUpdateWithoutChildrenInput, CategoryUncheckedUpdateWithoutChildrenInput>
    create: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutChildrenInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutChildrenInput, CategoryUncheckedUpdateWithoutChildrenInput>
  }

  export type CategoryUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: StringFieldUpdateOperationsInput | string
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutCategoriesNestedInput
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    transactions?: TransactionUpdateManyWithoutCategoryNestedInput
    budgets?: BudgetCategoryUpdateManyWithoutCategoryNestedInput
    envelopes?: EnvelopeUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: StringFieldUpdateOperationsInput | string
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutCategoryNestedInput
    budgets?: BudgetCategoryUncheckedUpdateManyWithoutCategoryNestedInput
    envelopes?: EnvelopeUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUpsertWithWhereUniqueWithoutParentInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutParentInput, CategoryUncheckedUpdateWithoutParentInput>
    create: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutParentInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutParentInput, CategoryUncheckedUpdateWithoutParentInput>
  }

  export type CategoryUpdateManyWithWhereWithoutParentInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutParentInput>
  }

  export type TransactionUpsertWithWhereUniqueWithoutCategoryInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutCategoryInput, TransactionUncheckedUpdateWithoutCategoryInput>
    create: XOR<TransactionCreateWithoutCategoryInput, TransactionUncheckedCreateWithoutCategoryInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutCategoryInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutCategoryInput, TransactionUncheckedUpdateWithoutCategoryInput>
  }

  export type TransactionUpdateManyWithWhereWithoutCategoryInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutCategoryInput>
  }

  export type BudgetCategoryUpsertWithWhereUniqueWithoutCategoryInput = {
    where: BudgetCategoryWhereUniqueInput
    update: XOR<BudgetCategoryUpdateWithoutCategoryInput, BudgetCategoryUncheckedUpdateWithoutCategoryInput>
    create: XOR<BudgetCategoryCreateWithoutCategoryInput, BudgetCategoryUncheckedCreateWithoutCategoryInput>
  }

  export type BudgetCategoryUpdateWithWhereUniqueWithoutCategoryInput = {
    where: BudgetCategoryWhereUniqueInput
    data: XOR<BudgetCategoryUpdateWithoutCategoryInput, BudgetCategoryUncheckedUpdateWithoutCategoryInput>
  }

  export type BudgetCategoryUpdateManyWithWhereWithoutCategoryInput = {
    where: BudgetCategoryScalarWhereInput
    data: XOR<BudgetCategoryUpdateManyMutationInput, BudgetCategoryUncheckedUpdateManyWithoutCategoryInput>
  }

  export type BudgetCategoryScalarWhereInput = {
    AND?: BudgetCategoryScalarWhereInput | BudgetCategoryScalarWhereInput[]
    OR?: BudgetCategoryScalarWhereInput[]
    NOT?: BudgetCategoryScalarWhereInput | BudgetCategoryScalarWhereInput[]
    id?: StringFilter<"BudgetCategory"> | string
    budgetId?: StringFilter<"BudgetCategory"> | string
    categoryId?: StringFilter<"BudgetCategory"> | string
    budgeted?: FloatFilter<"BudgetCategory"> | number
    spent?: FloatFilter<"BudgetCategory"> | number
  }

  export type EnvelopeUpsertWithWhereUniqueWithoutCategoryInput = {
    where: EnvelopeWhereUniqueInput
    update: XOR<EnvelopeUpdateWithoutCategoryInput, EnvelopeUncheckedUpdateWithoutCategoryInput>
    create: XOR<EnvelopeCreateWithoutCategoryInput, EnvelopeUncheckedCreateWithoutCategoryInput>
  }

  export type EnvelopeUpdateWithWhereUniqueWithoutCategoryInput = {
    where: EnvelopeWhereUniqueInput
    data: XOR<EnvelopeUpdateWithoutCategoryInput, EnvelopeUncheckedUpdateWithoutCategoryInput>
  }

  export type EnvelopeUpdateManyWithWhereWithoutCategoryInput = {
    where: EnvelopeScalarWhereInput
    data: XOR<EnvelopeUpdateManyMutationInput, EnvelopeUncheckedUpdateManyWithoutCategoryInput>
  }

  export type WorkspaceCreateWithoutTransactionInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    type: string
    currency?: string
    timezone?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberCreateNestedManyWithoutWorkspaceInput
    accounts?: AccountCreateNestedManyWithoutWorkspaceInput
    categories?: CategoryCreateNestedManyWithoutWorkspaceInput
    goals?: GoalCreateNestedManyWithoutWorkspaceInput
    budgets?: BudgetCreateNestedManyWithoutWorkspaceInput
    imports?: ImportJobCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogCreateNestedManyWithoutWorkspaceInput
    envelopes?: EnvelopeCreateNestedManyWithoutWorkspaceInput
    assets?: AssetCreateNestedManyWithoutWorkspaceInput
    liabilities?: LiabilityCreateNestedManyWithoutWorkspaceInput
    aiInsights?: AIInsightCreateNestedManyWithoutWorkspaceInput
    scenarios?: ScenarioCreateNestedManyWithoutWorkspaceInput
    bankConnections?: BankConnectionCreateNestedManyWithoutWorkspaceInput
    autoRules?: AutoRuleCreateNestedManyWithoutWorkspaceInput
    cashFlowProjections?: CashFlowProjectionCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutTransactionInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    type: string
    currency?: string
    timezone?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberUncheckedCreateNestedManyWithoutWorkspaceInput
    accounts?: AccountUncheckedCreateNestedManyWithoutWorkspaceInput
    categories?: CategoryUncheckedCreateNestedManyWithoutWorkspaceInput
    goals?: GoalUncheckedCreateNestedManyWithoutWorkspaceInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutWorkspaceInput
    imports?: ImportJobUncheckedCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutWorkspaceInput
    envelopes?: EnvelopeUncheckedCreateNestedManyWithoutWorkspaceInput
    assets?: AssetUncheckedCreateNestedManyWithoutWorkspaceInput
    liabilities?: LiabilityUncheckedCreateNestedManyWithoutWorkspaceInput
    aiInsights?: AIInsightUncheckedCreateNestedManyWithoutWorkspaceInput
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutWorkspaceInput
    bankConnections?: BankConnectionUncheckedCreateNestedManyWithoutWorkspaceInput
    autoRules?: AutoRuleUncheckedCreateNestedManyWithoutWorkspaceInput
    cashFlowProjections?: CashFlowProjectionUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutTransactionInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutTransactionInput, WorkspaceUncheckedCreateWithoutTransactionInput>
  }

  export type AccountCreateWithoutTransactionsInput = {
    id?: string
    name: string
    type: string
    description?: string | null
    bankName?: string | null
    bankCode?: string | null
    agency?: string | null
    accountNumber?: string | null
    initialBalance?: number
    currentBalance?: number
    creditLimit?: number | null
    closingDay?: number | null
    dueDay?: number | null
    color?: string
    icon?: string
    isActive?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutAccountsInput
    fromTransfers?: TransferCreateNestedManyWithoutFromAccountInput
    toTransfers?: TransferCreateNestedManyWithoutToAccountInput
    bankConnections?: BankConnectionCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutTransactionsInput = {
    id?: string
    workspaceId: string
    name: string
    type: string
    description?: string | null
    bankName?: string | null
    bankCode?: string | null
    agency?: string | null
    accountNumber?: string | null
    initialBalance?: number
    currentBalance?: number
    creditLimit?: number | null
    closingDay?: number | null
    dueDay?: number | null
    color?: string
    icon?: string
    isActive?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fromTransfers?: TransferUncheckedCreateNestedManyWithoutFromAccountInput
    toTransfers?: TransferUncheckedCreateNestedManyWithoutToAccountInput
    bankConnections?: BankConnectionUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutTransactionsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutTransactionsInput, AccountUncheckedCreateWithoutTransactionsInput>
  }

  export type CategoryCreateWithoutTransactionsInput = {
    id?: string
    name: string
    type: string
    color?: string
    icon?: string
    description?: string | null
    keywords: string
    isSystem?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutCategoriesInput
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    children?: CategoryCreateNestedManyWithoutParentInput
    budgets?: BudgetCategoryCreateNestedManyWithoutCategoryInput
    envelopes?: EnvelopeCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutTransactionsInput = {
    id?: string
    workspaceId: string
    parentId?: string | null
    name: string
    type: string
    color?: string
    icon?: string
    description?: string | null
    keywords: string
    isSystem?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    budgets?: BudgetCategoryUncheckedCreateNestedManyWithoutCategoryInput
    envelopes?: EnvelopeUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutTransactionsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutTransactionsInput, CategoryUncheckedCreateWithoutTransactionsInput>
  }

  export type WorkspaceUpsertWithoutTransactionInput = {
    update: XOR<WorkspaceUpdateWithoutTransactionInput, WorkspaceUncheckedUpdateWithoutTransactionInput>
    create: XOR<WorkspaceCreateWithoutTransactionInput, WorkspaceUncheckedCreateWithoutTransactionInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutTransactionInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutTransactionInput, WorkspaceUncheckedUpdateWithoutTransactionInput>
  }

  export type WorkspaceUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUpdateManyWithoutWorkspaceNestedInput
    accounts?: AccountUpdateManyWithoutWorkspaceNestedInput
    categories?: CategoryUpdateManyWithoutWorkspaceNestedInput
    goals?: GoalUpdateManyWithoutWorkspaceNestedInput
    budgets?: BudgetUpdateManyWithoutWorkspaceNestedInput
    imports?: ImportJobUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUpdateManyWithoutWorkspaceNestedInput
    envelopes?: EnvelopeUpdateManyWithoutWorkspaceNestedInput
    assets?: AssetUpdateManyWithoutWorkspaceNestedInput
    liabilities?: LiabilityUpdateManyWithoutWorkspaceNestedInput
    aiInsights?: AIInsightUpdateManyWithoutWorkspaceNestedInput
    scenarios?: ScenarioUpdateManyWithoutWorkspaceNestedInput
    bankConnections?: BankConnectionUpdateManyWithoutWorkspaceNestedInput
    autoRules?: AutoRuleUpdateManyWithoutWorkspaceNestedInput
    cashFlowProjections?: CashFlowProjectionUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUncheckedUpdateManyWithoutWorkspaceNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutWorkspaceNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutWorkspaceNestedInput
    goals?: GoalUncheckedUpdateManyWithoutWorkspaceNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutWorkspaceNestedInput
    imports?: ImportJobUncheckedUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutWorkspaceNestedInput
    envelopes?: EnvelopeUncheckedUpdateManyWithoutWorkspaceNestedInput
    assets?: AssetUncheckedUpdateManyWithoutWorkspaceNestedInput
    liabilities?: LiabilityUncheckedUpdateManyWithoutWorkspaceNestedInput
    aiInsights?: AIInsightUncheckedUpdateManyWithoutWorkspaceNestedInput
    scenarios?: ScenarioUncheckedUpdateManyWithoutWorkspaceNestedInput
    bankConnections?: BankConnectionUncheckedUpdateManyWithoutWorkspaceNestedInput
    autoRules?: AutoRuleUncheckedUpdateManyWithoutWorkspaceNestedInput
    cashFlowProjections?: CashFlowProjectionUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type AccountUpsertWithoutTransactionsInput = {
    update: XOR<AccountUpdateWithoutTransactionsInput, AccountUncheckedUpdateWithoutTransactionsInput>
    create: XOR<AccountCreateWithoutTransactionsInput, AccountUncheckedCreateWithoutTransactionsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutTransactionsInput, AccountUncheckedUpdateWithoutTransactionsInput>
  }

  export type AccountUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankCode?: NullableStringFieldUpdateOperationsInput | string | null
    agency?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initialBalance?: FloatFieldUpdateOperationsInput | number
    currentBalance?: FloatFieldUpdateOperationsInput | number
    creditLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    closingDay?: NullableIntFieldUpdateOperationsInput | number | null
    dueDay?: NullableIntFieldUpdateOperationsInput | number | null
    color?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutAccountsNestedInput
    fromTransfers?: TransferUpdateManyWithoutFromAccountNestedInput
    toTransfers?: TransferUpdateManyWithoutToAccountNestedInput
    bankConnections?: BankConnectionUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankCode?: NullableStringFieldUpdateOperationsInput | string | null
    agency?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initialBalance?: FloatFieldUpdateOperationsInput | number
    currentBalance?: FloatFieldUpdateOperationsInput | number
    creditLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    closingDay?: NullableIntFieldUpdateOperationsInput | number | null
    dueDay?: NullableIntFieldUpdateOperationsInput | number | null
    color?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromTransfers?: TransferUncheckedUpdateManyWithoutFromAccountNestedInput
    toTransfers?: TransferUncheckedUpdateManyWithoutToAccountNestedInput
    bankConnections?: BankConnectionUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type CategoryUpsertWithoutTransactionsInput = {
    update: XOR<CategoryUpdateWithoutTransactionsInput, CategoryUncheckedUpdateWithoutTransactionsInput>
    create: XOR<CategoryCreateWithoutTransactionsInput, CategoryUncheckedCreateWithoutTransactionsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutTransactionsInput, CategoryUncheckedUpdateWithoutTransactionsInput>
  }

  export type CategoryUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: StringFieldUpdateOperationsInput | string
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutCategoriesNestedInput
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    children?: CategoryUpdateManyWithoutParentNestedInput
    budgets?: BudgetCategoryUpdateManyWithoutCategoryNestedInput
    envelopes?: EnvelopeUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: StringFieldUpdateOperationsInput | string
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
    budgets?: BudgetCategoryUncheckedUpdateManyWithoutCategoryNestedInput
    envelopes?: EnvelopeUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type AccountCreateWithoutFromTransfersInput = {
    id?: string
    name: string
    type: string
    description?: string | null
    bankName?: string | null
    bankCode?: string | null
    agency?: string | null
    accountNumber?: string | null
    initialBalance?: number
    currentBalance?: number
    creditLimit?: number | null
    closingDay?: number | null
    dueDay?: number | null
    color?: string
    icon?: string
    isActive?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutAccountsInput
    transactions?: TransactionCreateNestedManyWithoutAccountInput
    toTransfers?: TransferCreateNestedManyWithoutToAccountInput
    bankConnections?: BankConnectionCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutFromTransfersInput = {
    id?: string
    workspaceId: string
    name: string
    type: string
    description?: string | null
    bankName?: string | null
    bankCode?: string | null
    agency?: string | null
    accountNumber?: string | null
    initialBalance?: number
    currentBalance?: number
    creditLimit?: number | null
    closingDay?: number | null
    dueDay?: number | null
    color?: string
    icon?: string
    isActive?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutAccountInput
    toTransfers?: TransferUncheckedCreateNestedManyWithoutToAccountInput
    bankConnections?: BankConnectionUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutFromTransfersInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutFromTransfersInput, AccountUncheckedCreateWithoutFromTransfersInput>
  }

  export type AccountCreateWithoutToTransfersInput = {
    id?: string
    name: string
    type: string
    description?: string | null
    bankName?: string | null
    bankCode?: string | null
    agency?: string | null
    accountNumber?: string | null
    initialBalance?: number
    currentBalance?: number
    creditLimit?: number | null
    closingDay?: number | null
    dueDay?: number | null
    color?: string
    icon?: string
    isActive?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutAccountsInput
    transactions?: TransactionCreateNestedManyWithoutAccountInput
    fromTransfers?: TransferCreateNestedManyWithoutFromAccountInput
    bankConnections?: BankConnectionCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutToTransfersInput = {
    id?: string
    workspaceId: string
    name: string
    type: string
    description?: string | null
    bankName?: string | null
    bankCode?: string | null
    agency?: string | null
    accountNumber?: string | null
    initialBalance?: number
    currentBalance?: number
    creditLimit?: number | null
    closingDay?: number | null
    dueDay?: number | null
    color?: string
    icon?: string
    isActive?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutAccountInput
    fromTransfers?: TransferUncheckedCreateNestedManyWithoutFromAccountInput
    bankConnections?: BankConnectionUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutToTransfersInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutToTransfersInput, AccountUncheckedCreateWithoutToTransfersInput>
  }

  export type AccountUpsertWithoutFromTransfersInput = {
    update: XOR<AccountUpdateWithoutFromTransfersInput, AccountUncheckedUpdateWithoutFromTransfersInput>
    create: XOR<AccountCreateWithoutFromTransfersInput, AccountUncheckedCreateWithoutFromTransfersInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutFromTransfersInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutFromTransfersInput, AccountUncheckedUpdateWithoutFromTransfersInput>
  }

  export type AccountUpdateWithoutFromTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankCode?: NullableStringFieldUpdateOperationsInput | string | null
    agency?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initialBalance?: FloatFieldUpdateOperationsInput | number
    currentBalance?: FloatFieldUpdateOperationsInput | number
    creditLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    closingDay?: NullableIntFieldUpdateOperationsInput | number | null
    dueDay?: NullableIntFieldUpdateOperationsInput | number | null
    color?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutAccountsNestedInput
    transactions?: TransactionUpdateManyWithoutAccountNestedInput
    toTransfers?: TransferUpdateManyWithoutToAccountNestedInput
    bankConnections?: BankConnectionUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutFromTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankCode?: NullableStringFieldUpdateOperationsInput | string | null
    agency?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initialBalance?: FloatFieldUpdateOperationsInput | number
    currentBalance?: FloatFieldUpdateOperationsInput | number
    creditLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    closingDay?: NullableIntFieldUpdateOperationsInput | number | null
    dueDay?: NullableIntFieldUpdateOperationsInput | number | null
    color?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutAccountNestedInput
    toTransfers?: TransferUncheckedUpdateManyWithoutToAccountNestedInput
    bankConnections?: BankConnectionUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AccountUpsertWithoutToTransfersInput = {
    update: XOR<AccountUpdateWithoutToTransfersInput, AccountUncheckedUpdateWithoutToTransfersInput>
    create: XOR<AccountCreateWithoutToTransfersInput, AccountUncheckedCreateWithoutToTransfersInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutToTransfersInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutToTransfersInput, AccountUncheckedUpdateWithoutToTransfersInput>
  }

  export type AccountUpdateWithoutToTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankCode?: NullableStringFieldUpdateOperationsInput | string | null
    agency?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initialBalance?: FloatFieldUpdateOperationsInput | number
    currentBalance?: FloatFieldUpdateOperationsInput | number
    creditLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    closingDay?: NullableIntFieldUpdateOperationsInput | number | null
    dueDay?: NullableIntFieldUpdateOperationsInput | number | null
    color?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutAccountsNestedInput
    transactions?: TransactionUpdateManyWithoutAccountNestedInput
    fromTransfers?: TransferUpdateManyWithoutFromAccountNestedInput
    bankConnections?: BankConnectionUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutToTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankCode?: NullableStringFieldUpdateOperationsInput | string | null
    agency?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initialBalance?: FloatFieldUpdateOperationsInput | number
    currentBalance?: FloatFieldUpdateOperationsInput | number
    creditLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    closingDay?: NullableIntFieldUpdateOperationsInput | number | null
    dueDay?: NullableIntFieldUpdateOperationsInput | number | null
    color?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutAccountNestedInput
    fromTransfers?: TransferUncheckedUpdateManyWithoutFromAccountNestedInput
    bankConnections?: BankConnectionUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type BudgetCategoryCreateWithoutBudgetInput = {
    id?: string
    budgeted: number
    spent?: number
    category: CategoryCreateNestedOneWithoutBudgetsInput
  }

  export type BudgetCategoryUncheckedCreateWithoutBudgetInput = {
    id?: string
    categoryId: string
    budgeted: number
    spent?: number
  }

  export type BudgetCategoryCreateOrConnectWithoutBudgetInput = {
    where: BudgetCategoryWhereUniqueInput
    create: XOR<BudgetCategoryCreateWithoutBudgetInput, BudgetCategoryUncheckedCreateWithoutBudgetInput>
  }

  export type BudgetCategoryCreateManyBudgetInputEnvelope = {
    data: BudgetCategoryCreateManyBudgetInput | BudgetCategoryCreateManyBudgetInput[]
  }

  export type WorkspaceCreateWithoutBudgetsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    type: string
    currency?: string
    timezone?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberCreateNestedManyWithoutWorkspaceInput
    accounts?: AccountCreateNestedManyWithoutWorkspaceInput
    categories?: CategoryCreateNestedManyWithoutWorkspaceInput
    goals?: GoalCreateNestedManyWithoutWorkspaceInput
    imports?: ImportJobCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogCreateNestedManyWithoutWorkspaceInput
    envelopes?: EnvelopeCreateNestedManyWithoutWorkspaceInput
    assets?: AssetCreateNestedManyWithoutWorkspaceInput
    liabilities?: LiabilityCreateNestedManyWithoutWorkspaceInput
    aiInsights?: AIInsightCreateNestedManyWithoutWorkspaceInput
    scenarios?: ScenarioCreateNestedManyWithoutWorkspaceInput
    bankConnections?: BankConnectionCreateNestedManyWithoutWorkspaceInput
    autoRules?: AutoRuleCreateNestedManyWithoutWorkspaceInput
    cashFlowProjections?: CashFlowProjectionCreateNestedManyWithoutWorkspaceInput
    Transaction?: TransactionCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutBudgetsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    type: string
    currency?: string
    timezone?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberUncheckedCreateNestedManyWithoutWorkspaceInput
    accounts?: AccountUncheckedCreateNestedManyWithoutWorkspaceInput
    categories?: CategoryUncheckedCreateNestedManyWithoutWorkspaceInput
    goals?: GoalUncheckedCreateNestedManyWithoutWorkspaceInput
    imports?: ImportJobUncheckedCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutWorkspaceInput
    envelopes?: EnvelopeUncheckedCreateNestedManyWithoutWorkspaceInput
    assets?: AssetUncheckedCreateNestedManyWithoutWorkspaceInput
    liabilities?: LiabilityUncheckedCreateNestedManyWithoutWorkspaceInput
    aiInsights?: AIInsightUncheckedCreateNestedManyWithoutWorkspaceInput
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutWorkspaceInput
    bankConnections?: BankConnectionUncheckedCreateNestedManyWithoutWorkspaceInput
    autoRules?: AutoRuleUncheckedCreateNestedManyWithoutWorkspaceInput
    cashFlowProjections?: CashFlowProjectionUncheckedCreateNestedManyWithoutWorkspaceInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutBudgetsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutBudgetsInput, WorkspaceUncheckedCreateWithoutBudgetsInput>
  }

  export type BudgetCategoryUpsertWithWhereUniqueWithoutBudgetInput = {
    where: BudgetCategoryWhereUniqueInput
    update: XOR<BudgetCategoryUpdateWithoutBudgetInput, BudgetCategoryUncheckedUpdateWithoutBudgetInput>
    create: XOR<BudgetCategoryCreateWithoutBudgetInput, BudgetCategoryUncheckedCreateWithoutBudgetInput>
  }

  export type BudgetCategoryUpdateWithWhereUniqueWithoutBudgetInput = {
    where: BudgetCategoryWhereUniqueInput
    data: XOR<BudgetCategoryUpdateWithoutBudgetInput, BudgetCategoryUncheckedUpdateWithoutBudgetInput>
  }

  export type BudgetCategoryUpdateManyWithWhereWithoutBudgetInput = {
    where: BudgetCategoryScalarWhereInput
    data: XOR<BudgetCategoryUpdateManyMutationInput, BudgetCategoryUncheckedUpdateManyWithoutBudgetInput>
  }

  export type WorkspaceUpsertWithoutBudgetsInput = {
    update: XOR<WorkspaceUpdateWithoutBudgetsInput, WorkspaceUncheckedUpdateWithoutBudgetsInput>
    create: XOR<WorkspaceCreateWithoutBudgetsInput, WorkspaceUncheckedCreateWithoutBudgetsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutBudgetsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutBudgetsInput, WorkspaceUncheckedUpdateWithoutBudgetsInput>
  }

  export type WorkspaceUpdateWithoutBudgetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUpdateManyWithoutWorkspaceNestedInput
    accounts?: AccountUpdateManyWithoutWorkspaceNestedInput
    categories?: CategoryUpdateManyWithoutWorkspaceNestedInput
    goals?: GoalUpdateManyWithoutWorkspaceNestedInput
    imports?: ImportJobUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUpdateManyWithoutWorkspaceNestedInput
    envelopes?: EnvelopeUpdateManyWithoutWorkspaceNestedInput
    assets?: AssetUpdateManyWithoutWorkspaceNestedInput
    liabilities?: LiabilityUpdateManyWithoutWorkspaceNestedInput
    aiInsights?: AIInsightUpdateManyWithoutWorkspaceNestedInput
    scenarios?: ScenarioUpdateManyWithoutWorkspaceNestedInput
    bankConnections?: BankConnectionUpdateManyWithoutWorkspaceNestedInput
    autoRules?: AutoRuleUpdateManyWithoutWorkspaceNestedInput
    cashFlowProjections?: CashFlowProjectionUpdateManyWithoutWorkspaceNestedInput
    Transaction?: TransactionUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutBudgetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUncheckedUpdateManyWithoutWorkspaceNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutWorkspaceNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutWorkspaceNestedInput
    goals?: GoalUncheckedUpdateManyWithoutWorkspaceNestedInput
    imports?: ImportJobUncheckedUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutWorkspaceNestedInput
    envelopes?: EnvelopeUncheckedUpdateManyWithoutWorkspaceNestedInput
    assets?: AssetUncheckedUpdateManyWithoutWorkspaceNestedInput
    liabilities?: LiabilityUncheckedUpdateManyWithoutWorkspaceNestedInput
    aiInsights?: AIInsightUncheckedUpdateManyWithoutWorkspaceNestedInput
    scenarios?: ScenarioUncheckedUpdateManyWithoutWorkspaceNestedInput
    bankConnections?: BankConnectionUncheckedUpdateManyWithoutWorkspaceNestedInput
    autoRules?: AutoRuleUncheckedUpdateManyWithoutWorkspaceNestedInput
    cashFlowProjections?: CashFlowProjectionUncheckedUpdateManyWithoutWorkspaceNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type BudgetCreateWithoutCategoriesInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    totalBudgeted: number
    totalSpent?: number
    isActive?: boolean
    alertThreshold?: number
    alertSent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Workspace: WorkspaceCreateNestedOneWithoutBudgetsInput
  }

  export type BudgetUncheckedCreateWithoutCategoriesInput = {
    id?: string
    workspaceId: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    totalBudgeted: number
    totalSpent?: number
    isActive?: boolean
    alertThreshold?: number
    alertSent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BudgetCreateOrConnectWithoutCategoriesInput = {
    where: BudgetWhereUniqueInput
    create: XOR<BudgetCreateWithoutCategoriesInput, BudgetUncheckedCreateWithoutCategoriesInput>
  }

  export type CategoryCreateWithoutBudgetsInput = {
    id?: string
    name: string
    type: string
    color?: string
    icon?: string
    description?: string | null
    keywords: string
    isSystem?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutCategoriesInput
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    children?: CategoryCreateNestedManyWithoutParentInput
    transactions?: TransactionCreateNestedManyWithoutCategoryInput
    envelopes?: EnvelopeCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutBudgetsInput = {
    id?: string
    workspaceId: string
    parentId?: string | null
    name: string
    type: string
    color?: string
    icon?: string
    description?: string | null
    keywords: string
    isSystem?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCategoryInput
    envelopes?: EnvelopeUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutBudgetsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutBudgetsInput, CategoryUncheckedCreateWithoutBudgetsInput>
  }

  export type BudgetUpsertWithoutCategoriesInput = {
    update: XOR<BudgetUpdateWithoutCategoriesInput, BudgetUncheckedUpdateWithoutCategoriesInput>
    create: XOR<BudgetCreateWithoutCategoriesInput, BudgetUncheckedCreateWithoutCategoriesInput>
    where?: BudgetWhereInput
  }

  export type BudgetUpdateToOneWithWhereWithoutCategoriesInput = {
    where?: BudgetWhereInput
    data: XOR<BudgetUpdateWithoutCategoriesInput, BudgetUncheckedUpdateWithoutCategoriesInput>
  }

  export type BudgetUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalBudgeted?: FloatFieldUpdateOperationsInput | number
    totalSpent?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    alertThreshold?: IntFieldUpdateOperationsInput | number
    alertSent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Workspace?: WorkspaceUpdateOneRequiredWithoutBudgetsNestedInput
  }

  export type BudgetUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalBudgeted?: FloatFieldUpdateOperationsInput | number
    totalSpent?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    alertThreshold?: IntFieldUpdateOperationsInput | number
    alertSent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUpsertWithoutBudgetsInput = {
    update: XOR<CategoryUpdateWithoutBudgetsInput, CategoryUncheckedUpdateWithoutBudgetsInput>
    create: XOR<CategoryCreateWithoutBudgetsInput, CategoryUncheckedCreateWithoutBudgetsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutBudgetsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutBudgetsInput, CategoryUncheckedUpdateWithoutBudgetsInput>
  }

  export type CategoryUpdateWithoutBudgetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: StringFieldUpdateOperationsInput | string
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutCategoriesNestedInput
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    children?: CategoryUpdateManyWithoutParentNestedInput
    transactions?: TransactionUpdateManyWithoutCategoryNestedInput
    envelopes?: EnvelopeUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutBudgetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: StringFieldUpdateOperationsInput | string
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCategoryNestedInput
    envelopes?: EnvelopeUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type GoalContributionCreateWithoutGoalInput = {
    id?: string
    amount: number
    description?: string | null
    contributedAt?: Date | string
  }

  export type GoalContributionUncheckedCreateWithoutGoalInput = {
    id?: string
    amount: number
    description?: string | null
    contributedAt?: Date | string
  }

  export type GoalContributionCreateOrConnectWithoutGoalInput = {
    where: GoalContributionWhereUniqueInput
    create: XOR<GoalContributionCreateWithoutGoalInput, GoalContributionUncheckedCreateWithoutGoalInput>
  }

  export type GoalContributionCreateManyGoalInputEnvelope = {
    data: GoalContributionCreateManyGoalInput | GoalContributionCreateManyGoalInput[]
  }

  export type WorkspaceCreateWithoutGoalsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    type: string
    currency?: string
    timezone?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberCreateNestedManyWithoutWorkspaceInput
    accounts?: AccountCreateNestedManyWithoutWorkspaceInput
    categories?: CategoryCreateNestedManyWithoutWorkspaceInput
    budgets?: BudgetCreateNestedManyWithoutWorkspaceInput
    imports?: ImportJobCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogCreateNestedManyWithoutWorkspaceInput
    envelopes?: EnvelopeCreateNestedManyWithoutWorkspaceInput
    assets?: AssetCreateNestedManyWithoutWorkspaceInput
    liabilities?: LiabilityCreateNestedManyWithoutWorkspaceInput
    aiInsights?: AIInsightCreateNestedManyWithoutWorkspaceInput
    scenarios?: ScenarioCreateNestedManyWithoutWorkspaceInput
    bankConnections?: BankConnectionCreateNestedManyWithoutWorkspaceInput
    autoRules?: AutoRuleCreateNestedManyWithoutWorkspaceInput
    cashFlowProjections?: CashFlowProjectionCreateNestedManyWithoutWorkspaceInput
    Transaction?: TransactionCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutGoalsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    type: string
    currency?: string
    timezone?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberUncheckedCreateNestedManyWithoutWorkspaceInput
    accounts?: AccountUncheckedCreateNestedManyWithoutWorkspaceInput
    categories?: CategoryUncheckedCreateNestedManyWithoutWorkspaceInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutWorkspaceInput
    imports?: ImportJobUncheckedCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutWorkspaceInput
    envelopes?: EnvelopeUncheckedCreateNestedManyWithoutWorkspaceInput
    assets?: AssetUncheckedCreateNestedManyWithoutWorkspaceInput
    liabilities?: LiabilityUncheckedCreateNestedManyWithoutWorkspaceInput
    aiInsights?: AIInsightUncheckedCreateNestedManyWithoutWorkspaceInput
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutWorkspaceInput
    bankConnections?: BankConnectionUncheckedCreateNestedManyWithoutWorkspaceInput
    autoRules?: AutoRuleUncheckedCreateNestedManyWithoutWorkspaceInput
    cashFlowProjections?: CashFlowProjectionUncheckedCreateNestedManyWithoutWorkspaceInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutGoalsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutGoalsInput, WorkspaceUncheckedCreateWithoutGoalsInput>
  }

  export type GoalContributionUpsertWithWhereUniqueWithoutGoalInput = {
    where: GoalContributionWhereUniqueInput
    update: XOR<GoalContributionUpdateWithoutGoalInput, GoalContributionUncheckedUpdateWithoutGoalInput>
    create: XOR<GoalContributionCreateWithoutGoalInput, GoalContributionUncheckedCreateWithoutGoalInput>
  }

  export type GoalContributionUpdateWithWhereUniqueWithoutGoalInput = {
    where: GoalContributionWhereUniqueInput
    data: XOR<GoalContributionUpdateWithoutGoalInput, GoalContributionUncheckedUpdateWithoutGoalInput>
  }

  export type GoalContributionUpdateManyWithWhereWithoutGoalInput = {
    where: GoalContributionScalarWhereInput
    data: XOR<GoalContributionUpdateManyMutationInput, GoalContributionUncheckedUpdateManyWithoutGoalInput>
  }

  export type GoalContributionScalarWhereInput = {
    AND?: GoalContributionScalarWhereInput | GoalContributionScalarWhereInput[]
    OR?: GoalContributionScalarWhereInput[]
    NOT?: GoalContributionScalarWhereInput | GoalContributionScalarWhereInput[]
    id?: StringFilter<"GoalContribution"> | string
    goalId?: StringFilter<"GoalContribution"> | string
    amount?: FloatFilter<"GoalContribution"> | number
    description?: StringNullableFilter<"GoalContribution"> | string | null
    contributedAt?: DateTimeFilter<"GoalContribution"> | Date | string
  }

  export type WorkspaceUpsertWithoutGoalsInput = {
    update: XOR<WorkspaceUpdateWithoutGoalsInput, WorkspaceUncheckedUpdateWithoutGoalsInput>
    create: XOR<WorkspaceCreateWithoutGoalsInput, WorkspaceUncheckedCreateWithoutGoalsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutGoalsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutGoalsInput, WorkspaceUncheckedUpdateWithoutGoalsInput>
  }

  export type WorkspaceUpdateWithoutGoalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUpdateManyWithoutWorkspaceNestedInput
    accounts?: AccountUpdateManyWithoutWorkspaceNestedInput
    categories?: CategoryUpdateManyWithoutWorkspaceNestedInput
    budgets?: BudgetUpdateManyWithoutWorkspaceNestedInput
    imports?: ImportJobUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUpdateManyWithoutWorkspaceNestedInput
    envelopes?: EnvelopeUpdateManyWithoutWorkspaceNestedInput
    assets?: AssetUpdateManyWithoutWorkspaceNestedInput
    liabilities?: LiabilityUpdateManyWithoutWorkspaceNestedInput
    aiInsights?: AIInsightUpdateManyWithoutWorkspaceNestedInput
    scenarios?: ScenarioUpdateManyWithoutWorkspaceNestedInput
    bankConnections?: BankConnectionUpdateManyWithoutWorkspaceNestedInput
    autoRules?: AutoRuleUpdateManyWithoutWorkspaceNestedInput
    cashFlowProjections?: CashFlowProjectionUpdateManyWithoutWorkspaceNestedInput
    Transaction?: TransactionUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutGoalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUncheckedUpdateManyWithoutWorkspaceNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutWorkspaceNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutWorkspaceNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutWorkspaceNestedInput
    imports?: ImportJobUncheckedUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutWorkspaceNestedInput
    envelopes?: EnvelopeUncheckedUpdateManyWithoutWorkspaceNestedInput
    assets?: AssetUncheckedUpdateManyWithoutWorkspaceNestedInput
    liabilities?: LiabilityUncheckedUpdateManyWithoutWorkspaceNestedInput
    aiInsights?: AIInsightUncheckedUpdateManyWithoutWorkspaceNestedInput
    scenarios?: ScenarioUncheckedUpdateManyWithoutWorkspaceNestedInput
    bankConnections?: BankConnectionUncheckedUpdateManyWithoutWorkspaceNestedInput
    autoRules?: AutoRuleUncheckedUpdateManyWithoutWorkspaceNestedInput
    cashFlowProjections?: CashFlowProjectionUncheckedUpdateManyWithoutWorkspaceNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type GoalCreateWithoutContributionsInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    targetAmount: number
    currentAmount?: number
    startDate: Date | string
    targetDate?: Date | string | null
    completedAt?: Date | string | null
    status: string
    icon?: string
    color?: string
    autoAllocate?: boolean
    allocationPercentage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Workspace: WorkspaceCreateNestedOneWithoutGoalsInput
  }

  export type GoalUncheckedCreateWithoutContributionsInput = {
    id?: string
    workspaceId: string
    name: string
    description?: string | null
    type: string
    targetAmount: number
    currentAmount?: number
    startDate: Date | string
    targetDate?: Date | string | null
    completedAt?: Date | string | null
    status: string
    icon?: string
    color?: string
    autoAllocate?: boolean
    allocationPercentage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GoalCreateOrConnectWithoutContributionsInput = {
    where: GoalWhereUniqueInput
    create: XOR<GoalCreateWithoutContributionsInput, GoalUncheckedCreateWithoutContributionsInput>
  }

  export type GoalUpsertWithoutContributionsInput = {
    update: XOR<GoalUpdateWithoutContributionsInput, GoalUncheckedUpdateWithoutContributionsInput>
    create: XOR<GoalCreateWithoutContributionsInput, GoalUncheckedCreateWithoutContributionsInput>
    where?: GoalWhereInput
  }

  export type GoalUpdateToOneWithWhereWithoutContributionsInput = {
    where?: GoalWhereInput
    data: XOR<GoalUpdateWithoutContributionsInput, GoalUncheckedUpdateWithoutContributionsInput>
  }

  export type GoalUpdateWithoutContributionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    targetAmount?: FloatFieldUpdateOperationsInput | number
    currentAmount?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    autoAllocate?: BoolFieldUpdateOperationsInput | boolean
    allocationPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Workspace?: WorkspaceUpdateOneRequiredWithoutGoalsNestedInput
  }

  export type GoalUncheckedUpdateWithoutContributionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    targetAmount?: FloatFieldUpdateOperationsInput | number
    currentAmount?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    autoAllocate?: BoolFieldUpdateOperationsInput | boolean
    allocationPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceCreateWithoutImportsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    type: string
    currency?: string
    timezone?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberCreateNestedManyWithoutWorkspaceInput
    accounts?: AccountCreateNestedManyWithoutWorkspaceInput
    categories?: CategoryCreateNestedManyWithoutWorkspaceInput
    goals?: GoalCreateNestedManyWithoutWorkspaceInput
    budgets?: BudgetCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogCreateNestedManyWithoutWorkspaceInput
    envelopes?: EnvelopeCreateNestedManyWithoutWorkspaceInput
    assets?: AssetCreateNestedManyWithoutWorkspaceInput
    liabilities?: LiabilityCreateNestedManyWithoutWorkspaceInput
    aiInsights?: AIInsightCreateNestedManyWithoutWorkspaceInput
    scenarios?: ScenarioCreateNestedManyWithoutWorkspaceInput
    bankConnections?: BankConnectionCreateNestedManyWithoutWorkspaceInput
    autoRules?: AutoRuleCreateNestedManyWithoutWorkspaceInput
    cashFlowProjections?: CashFlowProjectionCreateNestedManyWithoutWorkspaceInput
    Transaction?: TransactionCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutImportsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    type: string
    currency?: string
    timezone?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberUncheckedCreateNestedManyWithoutWorkspaceInput
    accounts?: AccountUncheckedCreateNestedManyWithoutWorkspaceInput
    categories?: CategoryUncheckedCreateNestedManyWithoutWorkspaceInput
    goals?: GoalUncheckedCreateNestedManyWithoutWorkspaceInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutWorkspaceInput
    envelopes?: EnvelopeUncheckedCreateNestedManyWithoutWorkspaceInput
    assets?: AssetUncheckedCreateNestedManyWithoutWorkspaceInput
    liabilities?: LiabilityUncheckedCreateNestedManyWithoutWorkspaceInput
    aiInsights?: AIInsightUncheckedCreateNestedManyWithoutWorkspaceInput
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutWorkspaceInput
    bankConnections?: BankConnectionUncheckedCreateNestedManyWithoutWorkspaceInput
    autoRules?: AutoRuleUncheckedCreateNestedManyWithoutWorkspaceInput
    cashFlowProjections?: CashFlowProjectionUncheckedCreateNestedManyWithoutWorkspaceInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutImportsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutImportsInput, WorkspaceUncheckedCreateWithoutImportsInput>
  }

  export type WorkspaceUpsertWithoutImportsInput = {
    update: XOR<WorkspaceUpdateWithoutImportsInput, WorkspaceUncheckedUpdateWithoutImportsInput>
    create: XOR<WorkspaceCreateWithoutImportsInput, WorkspaceUncheckedCreateWithoutImportsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutImportsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutImportsInput, WorkspaceUncheckedUpdateWithoutImportsInput>
  }

  export type WorkspaceUpdateWithoutImportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUpdateManyWithoutWorkspaceNestedInput
    accounts?: AccountUpdateManyWithoutWorkspaceNestedInput
    categories?: CategoryUpdateManyWithoutWorkspaceNestedInput
    goals?: GoalUpdateManyWithoutWorkspaceNestedInput
    budgets?: BudgetUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUpdateManyWithoutWorkspaceNestedInput
    envelopes?: EnvelopeUpdateManyWithoutWorkspaceNestedInput
    assets?: AssetUpdateManyWithoutWorkspaceNestedInput
    liabilities?: LiabilityUpdateManyWithoutWorkspaceNestedInput
    aiInsights?: AIInsightUpdateManyWithoutWorkspaceNestedInput
    scenarios?: ScenarioUpdateManyWithoutWorkspaceNestedInput
    bankConnections?: BankConnectionUpdateManyWithoutWorkspaceNestedInput
    autoRules?: AutoRuleUpdateManyWithoutWorkspaceNestedInput
    cashFlowProjections?: CashFlowProjectionUpdateManyWithoutWorkspaceNestedInput
    Transaction?: TransactionUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutImportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUncheckedUpdateManyWithoutWorkspaceNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutWorkspaceNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutWorkspaceNestedInput
    goals?: GoalUncheckedUpdateManyWithoutWorkspaceNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutWorkspaceNestedInput
    envelopes?: EnvelopeUncheckedUpdateManyWithoutWorkspaceNestedInput
    assets?: AssetUncheckedUpdateManyWithoutWorkspaceNestedInput
    liabilities?: LiabilityUncheckedUpdateManyWithoutWorkspaceNestedInput
    aiInsights?: AIInsightUncheckedUpdateManyWithoutWorkspaceNestedInput
    scenarios?: ScenarioUncheckedUpdateManyWithoutWorkspaceNestedInput
    bankConnections?: BankConnectionUncheckedUpdateManyWithoutWorkspaceNestedInput
    autoRules?: AutoRuleUncheckedUpdateManyWithoutWorkspaceNestedInput
    cashFlowProjections?: CashFlowProjectionUncheckedUpdateManyWithoutWorkspaceNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    avatarUrl?: string | null
    phone?: string | null
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    workspaces?: WorkspaceMemberCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    gamification?: UserGamificationCreateNestedOneWithoutUserInput
    aiInsights?: AIInsightCreateNestedManyWithoutUserInput
    scenarios?: ScenarioCreateNestedManyWithoutUserInput
    autoRules?: AutoRuleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    avatarUrl?: string | null
    phone?: string | null
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    workspaces?: WorkspaceMemberUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    gamification?: UserGamificationUncheckedCreateNestedOneWithoutUserInput
    aiInsights?: AIInsightUncheckedCreateNestedManyWithoutUserInput
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutUserInput
    autoRules?: AutoRuleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workspaces?: WorkspaceMemberUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    gamification?: UserGamificationUpdateOneWithoutUserNestedInput
    aiInsights?: AIInsightUpdateManyWithoutUserNestedInput
    scenarios?: ScenarioUpdateManyWithoutUserNestedInput
    autoRules?: AutoRuleUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workspaces?: WorkspaceMemberUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    gamification?: UserGamificationUncheckedUpdateOneWithoutUserNestedInput
    aiInsights?: AIInsightUncheckedUpdateManyWithoutUserNestedInput
    scenarios?: ScenarioUncheckedUpdateManyWithoutUserNestedInput
    autoRules?: AutoRuleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    avatarUrl?: string | null
    phone?: string | null
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    workspaces?: WorkspaceMemberCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    gamification?: UserGamificationCreateNestedOneWithoutUserInput
    aiInsights?: AIInsightCreateNestedManyWithoutUserInput
    scenarios?: ScenarioCreateNestedManyWithoutUserInput
    autoRules?: AutoRuleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    avatarUrl?: string | null
    phone?: string | null
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    workspaces?: WorkspaceMemberUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    gamification?: UserGamificationUncheckedCreateNestedOneWithoutUserInput
    aiInsights?: AIInsightUncheckedCreateNestedManyWithoutUserInput
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutUserInput
    autoRules?: AutoRuleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type WorkspaceCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    type: string
    currency?: string
    timezone?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberCreateNestedManyWithoutWorkspaceInput
    accounts?: AccountCreateNestedManyWithoutWorkspaceInput
    categories?: CategoryCreateNestedManyWithoutWorkspaceInput
    goals?: GoalCreateNestedManyWithoutWorkspaceInput
    budgets?: BudgetCreateNestedManyWithoutWorkspaceInput
    imports?: ImportJobCreateNestedManyWithoutWorkspaceInput
    envelopes?: EnvelopeCreateNestedManyWithoutWorkspaceInput
    assets?: AssetCreateNestedManyWithoutWorkspaceInput
    liabilities?: LiabilityCreateNestedManyWithoutWorkspaceInput
    aiInsights?: AIInsightCreateNestedManyWithoutWorkspaceInput
    scenarios?: ScenarioCreateNestedManyWithoutWorkspaceInput
    bankConnections?: BankConnectionCreateNestedManyWithoutWorkspaceInput
    autoRules?: AutoRuleCreateNestedManyWithoutWorkspaceInput
    cashFlowProjections?: CashFlowProjectionCreateNestedManyWithoutWorkspaceInput
    Transaction?: TransactionCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    type: string
    currency?: string
    timezone?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberUncheckedCreateNestedManyWithoutWorkspaceInput
    accounts?: AccountUncheckedCreateNestedManyWithoutWorkspaceInput
    categories?: CategoryUncheckedCreateNestedManyWithoutWorkspaceInput
    goals?: GoalUncheckedCreateNestedManyWithoutWorkspaceInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutWorkspaceInput
    imports?: ImportJobUncheckedCreateNestedManyWithoutWorkspaceInput
    envelopes?: EnvelopeUncheckedCreateNestedManyWithoutWorkspaceInput
    assets?: AssetUncheckedCreateNestedManyWithoutWorkspaceInput
    liabilities?: LiabilityUncheckedCreateNestedManyWithoutWorkspaceInput
    aiInsights?: AIInsightUncheckedCreateNestedManyWithoutWorkspaceInput
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutWorkspaceInput
    bankConnections?: BankConnectionUncheckedCreateNestedManyWithoutWorkspaceInput
    autoRules?: AutoRuleUncheckedCreateNestedManyWithoutWorkspaceInput
    cashFlowProjections?: CashFlowProjectionUncheckedCreateNestedManyWithoutWorkspaceInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutAuditLogsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutAuditLogsInput, WorkspaceUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workspaces?: WorkspaceMemberUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    gamification?: UserGamificationUpdateOneWithoutUserNestedInput
    aiInsights?: AIInsightUpdateManyWithoutUserNestedInput
    scenarios?: ScenarioUpdateManyWithoutUserNestedInput
    autoRules?: AutoRuleUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workspaces?: WorkspaceMemberUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    gamification?: UserGamificationUncheckedUpdateOneWithoutUserNestedInput
    aiInsights?: AIInsightUncheckedUpdateManyWithoutUserNestedInput
    scenarios?: ScenarioUncheckedUpdateManyWithoutUserNestedInput
    autoRules?: AutoRuleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WorkspaceUpsertWithoutAuditLogsInput = {
    update: XOR<WorkspaceUpdateWithoutAuditLogsInput, WorkspaceUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<WorkspaceCreateWithoutAuditLogsInput, WorkspaceUncheckedCreateWithoutAuditLogsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutAuditLogsInput, WorkspaceUncheckedUpdateWithoutAuditLogsInput>
  }

  export type WorkspaceUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUpdateManyWithoutWorkspaceNestedInput
    accounts?: AccountUpdateManyWithoutWorkspaceNestedInput
    categories?: CategoryUpdateManyWithoutWorkspaceNestedInput
    goals?: GoalUpdateManyWithoutWorkspaceNestedInput
    budgets?: BudgetUpdateManyWithoutWorkspaceNestedInput
    imports?: ImportJobUpdateManyWithoutWorkspaceNestedInput
    envelopes?: EnvelopeUpdateManyWithoutWorkspaceNestedInput
    assets?: AssetUpdateManyWithoutWorkspaceNestedInput
    liabilities?: LiabilityUpdateManyWithoutWorkspaceNestedInput
    aiInsights?: AIInsightUpdateManyWithoutWorkspaceNestedInput
    scenarios?: ScenarioUpdateManyWithoutWorkspaceNestedInput
    bankConnections?: BankConnectionUpdateManyWithoutWorkspaceNestedInput
    autoRules?: AutoRuleUpdateManyWithoutWorkspaceNestedInput
    cashFlowProjections?: CashFlowProjectionUpdateManyWithoutWorkspaceNestedInput
    Transaction?: TransactionUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUncheckedUpdateManyWithoutWorkspaceNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutWorkspaceNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutWorkspaceNestedInput
    goals?: GoalUncheckedUpdateManyWithoutWorkspaceNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutWorkspaceNestedInput
    imports?: ImportJobUncheckedUpdateManyWithoutWorkspaceNestedInput
    envelopes?: EnvelopeUncheckedUpdateManyWithoutWorkspaceNestedInput
    assets?: AssetUncheckedUpdateManyWithoutWorkspaceNestedInput
    liabilities?: LiabilityUncheckedUpdateManyWithoutWorkspaceNestedInput
    aiInsights?: AIInsightUncheckedUpdateManyWithoutWorkspaceNestedInput
    scenarios?: ScenarioUncheckedUpdateManyWithoutWorkspaceNestedInput
    bankConnections?: BankConnectionUncheckedUpdateManyWithoutWorkspaceNestedInput
    autoRules?: AutoRuleUncheckedUpdateManyWithoutWorkspaceNestedInput
    cashFlowProjections?: CashFlowProjectionUncheckedUpdateManyWithoutWorkspaceNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type UserCreateWithoutGamificationInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    avatarUrl?: string | null
    phone?: string | null
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    workspaces?: WorkspaceMemberCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    aiInsights?: AIInsightCreateNestedManyWithoutUserInput
    scenarios?: ScenarioCreateNestedManyWithoutUserInput
    autoRules?: AutoRuleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGamificationInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    avatarUrl?: string | null
    phone?: string | null
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    workspaces?: WorkspaceMemberUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    aiInsights?: AIInsightUncheckedCreateNestedManyWithoutUserInput
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutUserInput
    autoRules?: AutoRuleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGamificationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGamificationInput, UserUncheckedCreateWithoutGamificationInput>
  }

  export type UserAchievementCreateWithoutUserGamificationInput = {
    id?: string
    achievementId: string
    unlockedAt?: Date | string
  }

  export type UserAchievementUncheckedCreateWithoutUserGamificationInput = {
    id?: string
    achievementId: string
    unlockedAt?: Date | string
  }

  export type UserAchievementCreateOrConnectWithoutUserGamificationInput = {
    where: UserAchievementWhereUniqueInput
    create: XOR<UserAchievementCreateWithoutUserGamificationInput, UserAchievementUncheckedCreateWithoutUserGamificationInput>
  }

  export type UserAchievementCreateManyUserGamificationInputEnvelope = {
    data: UserAchievementCreateManyUserGamificationInput | UserAchievementCreateManyUserGamificationInput[]
  }

  export type UserUpsertWithoutGamificationInput = {
    update: XOR<UserUpdateWithoutGamificationInput, UserUncheckedUpdateWithoutGamificationInput>
    create: XOR<UserCreateWithoutGamificationInput, UserUncheckedCreateWithoutGamificationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGamificationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGamificationInput, UserUncheckedUpdateWithoutGamificationInput>
  }

  export type UserUpdateWithoutGamificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workspaces?: WorkspaceMemberUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    aiInsights?: AIInsightUpdateManyWithoutUserNestedInput
    scenarios?: ScenarioUpdateManyWithoutUserNestedInput
    autoRules?: AutoRuleUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGamificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workspaces?: WorkspaceMemberUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    aiInsights?: AIInsightUncheckedUpdateManyWithoutUserNestedInput
    scenarios?: ScenarioUncheckedUpdateManyWithoutUserNestedInput
    autoRules?: AutoRuleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserAchievementUpsertWithWhereUniqueWithoutUserGamificationInput = {
    where: UserAchievementWhereUniqueInput
    update: XOR<UserAchievementUpdateWithoutUserGamificationInput, UserAchievementUncheckedUpdateWithoutUserGamificationInput>
    create: XOR<UserAchievementCreateWithoutUserGamificationInput, UserAchievementUncheckedCreateWithoutUserGamificationInput>
  }

  export type UserAchievementUpdateWithWhereUniqueWithoutUserGamificationInput = {
    where: UserAchievementWhereUniqueInput
    data: XOR<UserAchievementUpdateWithoutUserGamificationInput, UserAchievementUncheckedUpdateWithoutUserGamificationInput>
  }

  export type UserAchievementUpdateManyWithWhereWithoutUserGamificationInput = {
    where: UserAchievementScalarWhereInput
    data: XOR<UserAchievementUpdateManyMutationInput, UserAchievementUncheckedUpdateManyWithoutUserGamificationInput>
  }

  export type UserAchievementScalarWhereInput = {
    AND?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
    OR?: UserAchievementScalarWhereInput[]
    NOT?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
    id?: StringFilter<"UserAchievement"> | string
    userGamificationId?: StringFilter<"UserAchievement"> | string
    achievementId?: StringFilter<"UserAchievement"> | string
    unlockedAt?: DateTimeFilter<"UserAchievement"> | Date | string
  }

  export type UserGamificationCreateWithoutAchievementsInput = {
    id?: string
    tier: string
    totalXP?: number
    currentLevel?: number
    xpToNextLevel?: number
    loginStreak?: number
    longestLoginStreak?: number
    transactionStreak?: number
    transactionsLogged?: number
    budgetsMet?: number
    goalsAchieved?: number
    lastLoginDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutGamificationInput
  }

  export type UserGamificationUncheckedCreateWithoutAchievementsInput = {
    id?: string
    userId: string
    tier: string
    totalXP?: number
    currentLevel?: number
    xpToNextLevel?: number
    loginStreak?: number
    longestLoginStreak?: number
    transactionStreak?: number
    transactionsLogged?: number
    budgetsMet?: number
    goalsAchieved?: number
    lastLoginDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserGamificationCreateOrConnectWithoutAchievementsInput = {
    where: UserGamificationWhereUniqueInput
    create: XOR<UserGamificationCreateWithoutAchievementsInput, UserGamificationUncheckedCreateWithoutAchievementsInput>
  }

  export type UserGamificationUpsertWithoutAchievementsInput = {
    update: XOR<UserGamificationUpdateWithoutAchievementsInput, UserGamificationUncheckedUpdateWithoutAchievementsInput>
    create: XOR<UserGamificationCreateWithoutAchievementsInput, UserGamificationUncheckedCreateWithoutAchievementsInput>
    where?: UserGamificationWhereInput
  }

  export type UserGamificationUpdateToOneWithWhereWithoutAchievementsInput = {
    where?: UserGamificationWhereInput
    data: XOR<UserGamificationUpdateWithoutAchievementsInput, UserGamificationUncheckedUpdateWithoutAchievementsInput>
  }

  export type UserGamificationUpdateWithoutAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    totalXP?: IntFieldUpdateOperationsInput | number
    currentLevel?: IntFieldUpdateOperationsInput | number
    xpToNextLevel?: IntFieldUpdateOperationsInput | number
    loginStreak?: IntFieldUpdateOperationsInput | number
    longestLoginStreak?: IntFieldUpdateOperationsInput | number
    transactionStreak?: IntFieldUpdateOperationsInput | number
    transactionsLogged?: IntFieldUpdateOperationsInput | number
    budgetsMet?: IntFieldUpdateOperationsInput | number
    goalsAchieved?: IntFieldUpdateOperationsInput | number
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutGamificationNestedInput
  }

  export type UserGamificationUncheckedUpdateWithoutAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    totalXP?: IntFieldUpdateOperationsInput | number
    currentLevel?: IntFieldUpdateOperationsInput | number
    xpToNextLevel?: IntFieldUpdateOperationsInput | number
    loginStreak?: IntFieldUpdateOperationsInput | number
    longestLoginStreak?: IntFieldUpdateOperationsInput | number
    transactionStreak?: IntFieldUpdateOperationsInput | number
    transactionsLogged?: IntFieldUpdateOperationsInput | number
    budgetsMet?: IntFieldUpdateOperationsInput | number
    goalsAchieved?: IntFieldUpdateOperationsInput | number
    lastLoginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceCreateWithoutEnvelopesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    type: string
    currency?: string
    timezone?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberCreateNestedManyWithoutWorkspaceInput
    accounts?: AccountCreateNestedManyWithoutWorkspaceInput
    categories?: CategoryCreateNestedManyWithoutWorkspaceInput
    goals?: GoalCreateNestedManyWithoutWorkspaceInput
    budgets?: BudgetCreateNestedManyWithoutWorkspaceInput
    imports?: ImportJobCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogCreateNestedManyWithoutWorkspaceInput
    assets?: AssetCreateNestedManyWithoutWorkspaceInput
    liabilities?: LiabilityCreateNestedManyWithoutWorkspaceInput
    aiInsights?: AIInsightCreateNestedManyWithoutWorkspaceInput
    scenarios?: ScenarioCreateNestedManyWithoutWorkspaceInput
    bankConnections?: BankConnectionCreateNestedManyWithoutWorkspaceInput
    autoRules?: AutoRuleCreateNestedManyWithoutWorkspaceInput
    cashFlowProjections?: CashFlowProjectionCreateNestedManyWithoutWorkspaceInput
    Transaction?: TransactionCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutEnvelopesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    type: string
    currency?: string
    timezone?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberUncheckedCreateNestedManyWithoutWorkspaceInput
    accounts?: AccountUncheckedCreateNestedManyWithoutWorkspaceInput
    categories?: CategoryUncheckedCreateNestedManyWithoutWorkspaceInput
    goals?: GoalUncheckedCreateNestedManyWithoutWorkspaceInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutWorkspaceInput
    imports?: ImportJobUncheckedCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutWorkspaceInput
    assets?: AssetUncheckedCreateNestedManyWithoutWorkspaceInput
    liabilities?: LiabilityUncheckedCreateNestedManyWithoutWorkspaceInput
    aiInsights?: AIInsightUncheckedCreateNestedManyWithoutWorkspaceInput
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutWorkspaceInput
    bankConnections?: BankConnectionUncheckedCreateNestedManyWithoutWorkspaceInput
    autoRules?: AutoRuleUncheckedCreateNestedManyWithoutWorkspaceInput
    cashFlowProjections?: CashFlowProjectionUncheckedCreateNestedManyWithoutWorkspaceInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutEnvelopesInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutEnvelopesInput, WorkspaceUncheckedCreateWithoutEnvelopesInput>
  }

  export type CategoryCreateWithoutEnvelopesInput = {
    id?: string
    name: string
    type: string
    color?: string
    icon?: string
    description?: string | null
    keywords: string
    isSystem?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutCategoriesInput
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    children?: CategoryCreateNestedManyWithoutParentInput
    transactions?: TransactionCreateNestedManyWithoutCategoryInput
    budgets?: BudgetCategoryCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutEnvelopesInput = {
    id?: string
    workspaceId: string
    parentId?: string | null
    name: string
    type: string
    color?: string
    icon?: string
    description?: string | null
    keywords: string
    isSystem?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCategoryInput
    budgets?: BudgetCategoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutEnvelopesInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutEnvelopesInput, CategoryUncheckedCreateWithoutEnvelopesInput>
  }

  export type WorkspaceUpsertWithoutEnvelopesInput = {
    update: XOR<WorkspaceUpdateWithoutEnvelopesInput, WorkspaceUncheckedUpdateWithoutEnvelopesInput>
    create: XOR<WorkspaceCreateWithoutEnvelopesInput, WorkspaceUncheckedCreateWithoutEnvelopesInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutEnvelopesInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutEnvelopesInput, WorkspaceUncheckedUpdateWithoutEnvelopesInput>
  }

  export type WorkspaceUpdateWithoutEnvelopesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUpdateManyWithoutWorkspaceNestedInput
    accounts?: AccountUpdateManyWithoutWorkspaceNestedInput
    categories?: CategoryUpdateManyWithoutWorkspaceNestedInput
    goals?: GoalUpdateManyWithoutWorkspaceNestedInput
    budgets?: BudgetUpdateManyWithoutWorkspaceNestedInput
    imports?: ImportJobUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUpdateManyWithoutWorkspaceNestedInput
    assets?: AssetUpdateManyWithoutWorkspaceNestedInput
    liabilities?: LiabilityUpdateManyWithoutWorkspaceNestedInput
    aiInsights?: AIInsightUpdateManyWithoutWorkspaceNestedInput
    scenarios?: ScenarioUpdateManyWithoutWorkspaceNestedInput
    bankConnections?: BankConnectionUpdateManyWithoutWorkspaceNestedInput
    autoRules?: AutoRuleUpdateManyWithoutWorkspaceNestedInput
    cashFlowProjections?: CashFlowProjectionUpdateManyWithoutWorkspaceNestedInput
    Transaction?: TransactionUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutEnvelopesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUncheckedUpdateManyWithoutWorkspaceNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutWorkspaceNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutWorkspaceNestedInput
    goals?: GoalUncheckedUpdateManyWithoutWorkspaceNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutWorkspaceNestedInput
    imports?: ImportJobUncheckedUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutWorkspaceNestedInput
    assets?: AssetUncheckedUpdateManyWithoutWorkspaceNestedInput
    liabilities?: LiabilityUncheckedUpdateManyWithoutWorkspaceNestedInput
    aiInsights?: AIInsightUncheckedUpdateManyWithoutWorkspaceNestedInput
    scenarios?: ScenarioUncheckedUpdateManyWithoutWorkspaceNestedInput
    bankConnections?: BankConnectionUncheckedUpdateManyWithoutWorkspaceNestedInput
    autoRules?: AutoRuleUncheckedUpdateManyWithoutWorkspaceNestedInput
    cashFlowProjections?: CashFlowProjectionUncheckedUpdateManyWithoutWorkspaceNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type CategoryUpsertWithoutEnvelopesInput = {
    update: XOR<CategoryUpdateWithoutEnvelopesInput, CategoryUncheckedUpdateWithoutEnvelopesInput>
    create: XOR<CategoryCreateWithoutEnvelopesInput, CategoryUncheckedCreateWithoutEnvelopesInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutEnvelopesInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutEnvelopesInput, CategoryUncheckedUpdateWithoutEnvelopesInput>
  }

  export type CategoryUpdateWithoutEnvelopesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: StringFieldUpdateOperationsInput | string
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutCategoriesNestedInput
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    children?: CategoryUpdateManyWithoutParentNestedInput
    transactions?: TransactionUpdateManyWithoutCategoryNestedInput
    budgets?: BudgetCategoryUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutEnvelopesInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: StringFieldUpdateOperationsInput | string
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCategoryNestedInput
    budgets?: BudgetCategoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type WorkspaceCreateWithoutAssetsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    type: string
    currency?: string
    timezone?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberCreateNestedManyWithoutWorkspaceInput
    accounts?: AccountCreateNestedManyWithoutWorkspaceInput
    categories?: CategoryCreateNestedManyWithoutWorkspaceInput
    goals?: GoalCreateNestedManyWithoutWorkspaceInput
    budgets?: BudgetCreateNestedManyWithoutWorkspaceInput
    imports?: ImportJobCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogCreateNestedManyWithoutWorkspaceInput
    envelopes?: EnvelopeCreateNestedManyWithoutWorkspaceInput
    liabilities?: LiabilityCreateNestedManyWithoutWorkspaceInput
    aiInsights?: AIInsightCreateNestedManyWithoutWorkspaceInput
    scenarios?: ScenarioCreateNestedManyWithoutWorkspaceInput
    bankConnections?: BankConnectionCreateNestedManyWithoutWorkspaceInput
    autoRules?: AutoRuleCreateNestedManyWithoutWorkspaceInput
    cashFlowProjections?: CashFlowProjectionCreateNestedManyWithoutWorkspaceInput
    Transaction?: TransactionCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutAssetsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    type: string
    currency?: string
    timezone?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberUncheckedCreateNestedManyWithoutWorkspaceInput
    accounts?: AccountUncheckedCreateNestedManyWithoutWorkspaceInput
    categories?: CategoryUncheckedCreateNestedManyWithoutWorkspaceInput
    goals?: GoalUncheckedCreateNestedManyWithoutWorkspaceInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutWorkspaceInput
    imports?: ImportJobUncheckedCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutWorkspaceInput
    envelopes?: EnvelopeUncheckedCreateNestedManyWithoutWorkspaceInput
    liabilities?: LiabilityUncheckedCreateNestedManyWithoutWorkspaceInput
    aiInsights?: AIInsightUncheckedCreateNestedManyWithoutWorkspaceInput
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutWorkspaceInput
    bankConnections?: BankConnectionUncheckedCreateNestedManyWithoutWorkspaceInput
    autoRules?: AutoRuleUncheckedCreateNestedManyWithoutWorkspaceInput
    cashFlowProjections?: CashFlowProjectionUncheckedCreateNestedManyWithoutWorkspaceInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutAssetsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutAssetsInput, WorkspaceUncheckedCreateWithoutAssetsInput>
  }

  export type WorkspaceUpsertWithoutAssetsInput = {
    update: XOR<WorkspaceUpdateWithoutAssetsInput, WorkspaceUncheckedUpdateWithoutAssetsInput>
    create: XOR<WorkspaceCreateWithoutAssetsInput, WorkspaceUncheckedCreateWithoutAssetsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutAssetsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutAssetsInput, WorkspaceUncheckedUpdateWithoutAssetsInput>
  }

  export type WorkspaceUpdateWithoutAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUpdateManyWithoutWorkspaceNestedInput
    accounts?: AccountUpdateManyWithoutWorkspaceNestedInput
    categories?: CategoryUpdateManyWithoutWorkspaceNestedInput
    goals?: GoalUpdateManyWithoutWorkspaceNestedInput
    budgets?: BudgetUpdateManyWithoutWorkspaceNestedInput
    imports?: ImportJobUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUpdateManyWithoutWorkspaceNestedInput
    envelopes?: EnvelopeUpdateManyWithoutWorkspaceNestedInput
    liabilities?: LiabilityUpdateManyWithoutWorkspaceNestedInput
    aiInsights?: AIInsightUpdateManyWithoutWorkspaceNestedInput
    scenarios?: ScenarioUpdateManyWithoutWorkspaceNestedInput
    bankConnections?: BankConnectionUpdateManyWithoutWorkspaceNestedInput
    autoRules?: AutoRuleUpdateManyWithoutWorkspaceNestedInput
    cashFlowProjections?: CashFlowProjectionUpdateManyWithoutWorkspaceNestedInput
    Transaction?: TransactionUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUncheckedUpdateManyWithoutWorkspaceNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutWorkspaceNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutWorkspaceNestedInput
    goals?: GoalUncheckedUpdateManyWithoutWorkspaceNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutWorkspaceNestedInput
    imports?: ImportJobUncheckedUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutWorkspaceNestedInput
    envelopes?: EnvelopeUncheckedUpdateManyWithoutWorkspaceNestedInput
    liabilities?: LiabilityUncheckedUpdateManyWithoutWorkspaceNestedInput
    aiInsights?: AIInsightUncheckedUpdateManyWithoutWorkspaceNestedInput
    scenarios?: ScenarioUncheckedUpdateManyWithoutWorkspaceNestedInput
    bankConnections?: BankConnectionUncheckedUpdateManyWithoutWorkspaceNestedInput
    autoRules?: AutoRuleUncheckedUpdateManyWithoutWorkspaceNestedInput
    cashFlowProjections?: CashFlowProjectionUncheckedUpdateManyWithoutWorkspaceNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceCreateWithoutLiabilitiesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    type: string
    currency?: string
    timezone?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberCreateNestedManyWithoutWorkspaceInput
    accounts?: AccountCreateNestedManyWithoutWorkspaceInput
    categories?: CategoryCreateNestedManyWithoutWorkspaceInput
    goals?: GoalCreateNestedManyWithoutWorkspaceInput
    budgets?: BudgetCreateNestedManyWithoutWorkspaceInput
    imports?: ImportJobCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogCreateNestedManyWithoutWorkspaceInput
    envelopes?: EnvelopeCreateNestedManyWithoutWorkspaceInput
    assets?: AssetCreateNestedManyWithoutWorkspaceInput
    aiInsights?: AIInsightCreateNestedManyWithoutWorkspaceInput
    scenarios?: ScenarioCreateNestedManyWithoutWorkspaceInput
    bankConnections?: BankConnectionCreateNestedManyWithoutWorkspaceInput
    autoRules?: AutoRuleCreateNestedManyWithoutWorkspaceInput
    cashFlowProjections?: CashFlowProjectionCreateNestedManyWithoutWorkspaceInput
    Transaction?: TransactionCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutLiabilitiesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    type: string
    currency?: string
    timezone?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberUncheckedCreateNestedManyWithoutWorkspaceInput
    accounts?: AccountUncheckedCreateNestedManyWithoutWorkspaceInput
    categories?: CategoryUncheckedCreateNestedManyWithoutWorkspaceInput
    goals?: GoalUncheckedCreateNestedManyWithoutWorkspaceInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutWorkspaceInput
    imports?: ImportJobUncheckedCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutWorkspaceInput
    envelopes?: EnvelopeUncheckedCreateNestedManyWithoutWorkspaceInput
    assets?: AssetUncheckedCreateNestedManyWithoutWorkspaceInput
    aiInsights?: AIInsightUncheckedCreateNestedManyWithoutWorkspaceInput
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutWorkspaceInput
    bankConnections?: BankConnectionUncheckedCreateNestedManyWithoutWorkspaceInput
    autoRules?: AutoRuleUncheckedCreateNestedManyWithoutWorkspaceInput
    cashFlowProjections?: CashFlowProjectionUncheckedCreateNestedManyWithoutWorkspaceInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutLiabilitiesInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutLiabilitiesInput, WorkspaceUncheckedCreateWithoutLiabilitiesInput>
  }

  export type WorkspaceUpsertWithoutLiabilitiesInput = {
    update: XOR<WorkspaceUpdateWithoutLiabilitiesInput, WorkspaceUncheckedUpdateWithoutLiabilitiesInput>
    create: XOR<WorkspaceCreateWithoutLiabilitiesInput, WorkspaceUncheckedCreateWithoutLiabilitiesInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutLiabilitiesInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutLiabilitiesInput, WorkspaceUncheckedUpdateWithoutLiabilitiesInput>
  }

  export type WorkspaceUpdateWithoutLiabilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUpdateManyWithoutWorkspaceNestedInput
    accounts?: AccountUpdateManyWithoutWorkspaceNestedInput
    categories?: CategoryUpdateManyWithoutWorkspaceNestedInput
    goals?: GoalUpdateManyWithoutWorkspaceNestedInput
    budgets?: BudgetUpdateManyWithoutWorkspaceNestedInput
    imports?: ImportJobUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUpdateManyWithoutWorkspaceNestedInput
    envelopes?: EnvelopeUpdateManyWithoutWorkspaceNestedInput
    assets?: AssetUpdateManyWithoutWorkspaceNestedInput
    aiInsights?: AIInsightUpdateManyWithoutWorkspaceNestedInput
    scenarios?: ScenarioUpdateManyWithoutWorkspaceNestedInput
    bankConnections?: BankConnectionUpdateManyWithoutWorkspaceNestedInput
    autoRules?: AutoRuleUpdateManyWithoutWorkspaceNestedInput
    cashFlowProjections?: CashFlowProjectionUpdateManyWithoutWorkspaceNestedInput
    Transaction?: TransactionUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutLiabilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUncheckedUpdateManyWithoutWorkspaceNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutWorkspaceNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutWorkspaceNestedInput
    goals?: GoalUncheckedUpdateManyWithoutWorkspaceNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutWorkspaceNestedInput
    imports?: ImportJobUncheckedUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutWorkspaceNestedInput
    envelopes?: EnvelopeUncheckedUpdateManyWithoutWorkspaceNestedInput
    assets?: AssetUncheckedUpdateManyWithoutWorkspaceNestedInput
    aiInsights?: AIInsightUncheckedUpdateManyWithoutWorkspaceNestedInput
    scenarios?: ScenarioUncheckedUpdateManyWithoutWorkspaceNestedInput
    bankConnections?: BankConnectionUncheckedUpdateManyWithoutWorkspaceNestedInput
    autoRules?: AutoRuleUncheckedUpdateManyWithoutWorkspaceNestedInput
    cashFlowProjections?: CashFlowProjectionUncheckedUpdateManyWithoutWorkspaceNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type UserCreateWithoutAiInsightsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    avatarUrl?: string | null
    phone?: string | null
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    workspaces?: WorkspaceMemberCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    gamification?: UserGamificationCreateNestedOneWithoutUserInput
    scenarios?: ScenarioCreateNestedManyWithoutUserInput
    autoRules?: AutoRuleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAiInsightsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    avatarUrl?: string | null
    phone?: string | null
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    workspaces?: WorkspaceMemberUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    gamification?: UserGamificationUncheckedCreateNestedOneWithoutUserInput
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutUserInput
    autoRules?: AutoRuleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAiInsightsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAiInsightsInput, UserUncheckedCreateWithoutAiInsightsInput>
  }

  export type WorkspaceCreateWithoutAiInsightsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    type: string
    currency?: string
    timezone?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberCreateNestedManyWithoutWorkspaceInput
    accounts?: AccountCreateNestedManyWithoutWorkspaceInput
    categories?: CategoryCreateNestedManyWithoutWorkspaceInput
    goals?: GoalCreateNestedManyWithoutWorkspaceInput
    budgets?: BudgetCreateNestedManyWithoutWorkspaceInput
    imports?: ImportJobCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogCreateNestedManyWithoutWorkspaceInput
    envelopes?: EnvelopeCreateNestedManyWithoutWorkspaceInput
    assets?: AssetCreateNestedManyWithoutWorkspaceInput
    liabilities?: LiabilityCreateNestedManyWithoutWorkspaceInput
    scenarios?: ScenarioCreateNestedManyWithoutWorkspaceInput
    bankConnections?: BankConnectionCreateNestedManyWithoutWorkspaceInput
    autoRules?: AutoRuleCreateNestedManyWithoutWorkspaceInput
    cashFlowProjections?: CashFlowProjectionCreateNestedManyWithoutWorkspaceInput
    Transaction?: TransactionCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutAiInsightsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    type: string
    currency?: string
    timezone?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberUncheckedCreateNestedManyWithoutWorkspaceInput
    accounts?: AccountUncheckedCreateNestedManyWithoutWorkspaceInput
    categories?: CategoryUncheckedCreateNestedManyWithoutWorkspaceInput
    goals?: GoalUncheckedCreateNestedManyWithoutWorkspaceInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutWorkspaceInput
    imports?: ImportJobUncheckedCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutWorkspaceInput
    envelopes?: EnvelopeUncheckedCreateNestedManyWithoutWorkspaceInput
    assets?: AssetUncheckedCreateNestedManyWithoutWorkspaceInput
    liabilities?: LiabilityUncheckedCreateNestedManyWithoutWorkspaceInput
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutWorkspaceInput
    bankConnections?: BankConnectionUncheckedCreateNestedManyWithoutWorkspaceInput
    autoRules?: AutoRuleUncheckedCreateNestedManyWithoutWorkspaceInput
    cashFlowProjections?: CashFlowProjectionUncheckedCreateNestedManyWithoutWorkspaceInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutAiInsightsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutAiInsightsInput, WorkspaceUncheckedCreateWithoutAiInsightsInput>
  }

  export type UserUpsertWithoutAiInsightsInput = {
    update: XOR<UserUpdateWithoutAiInsightsInput, UserUncheckedUpdateWithoutAiInsightsInput>
    create: XOR<UserCreateWithoutAiInsightsInput, UserUncheckedCreateWithoutAiInsightsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAiInsightsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAiInsightsInput, UserUncheckedUpdateWithoutAiInsightsInput>
  }

  export type UserUpdateWithoutAiInsightsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workspaces?: WorkspaceMemberUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    gamification?: UserGamificationUpdateOneWithoutUserNestedInput
    scenarios?: ScenarioUpdateManyWithoutUserNestedInput
    autoRules?: AutoRuleUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAiInsightsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workspaces?: WorkspaceMemberUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    gamification?: UserGamificationUncheckedUpdateOneWithoutUserNestedInput
    scenarios?: ScenarioUncheckedUpdateManyWithoutUserNestedInput
    autoRules?: AutoRuleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WorkspaceUpsertWithoutAiInsightsInput = {
    update: XOR<WorkspaceUpdateWithoutAiInsightsInput, WorkspaceUncheckedUpdateWithoutAiInsightsInput>
    create: XOR<WorkspaceCreateWithoutAiInsightsInput, WorkspaceUncheckedCreateWithoutAiInsightsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutAiInsightsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutAiInsightsInput, WorkspaceUncheckedUpdateWithoutAiInsightsInput>
  }

  export type WorkspaceUpdateWithoutAiInsightsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUpdateManyWithoutWorkspaceNestedInput
    accounts?: AccountUpdateManyWithoutWorkspaceNestedInput
    categories?: CategoryUpdateManyWithoutWorkspaceNestedInput
    goals?: GoalUpdateManyWithoutWorkspaceNestedInput
    budgets?: BudgetUpdateManyWithoutWorkspaceNestedInput
    imports?: ImportJobUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUpdateManyWithoutWorkspaceNestedInput
    envelopes?: EnvelopeUpdateManyWithoutWorkspaceNestedInput
    assets?: AssetUpdateManyWithoutWorkspaceNestedInput
    liabilities?: LiabilityUpdateManyWithoutWorkspaceNestedInput
    scenarios?: ScenarioUpdateManyWithoutWorkspaceNestedInput
    bankConnections?: BankConnectionUpdateManyWithoutWorkspaceNestedInput
    autoRules?: AutoRuleUpdateManyWithoutWorkspaceNestedInput
    cashFlowProjections?: CashFlowProjectionUpdateManyWithoutWorkspaceNestedInput
    Transaction?: TransactionUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutAiInsightsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUncheckedUpdateManyWithoutWorkspaceNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutWorkspaceNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutWorkspaceNestedInput
    goals?: GoalUncheckedUpdateManyWithoutWorkspaceNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutWorkspaceNestedInput
    imports?: ImportJobUncheckedUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutWorkspaceNestedInput
    envelopes?: EnvelopeUncheckedUpdateManyWithoutWorkspaceNestedInput
    assets?: AssetUncheckedUpdateManyWithoutWorkspaceNestedInput
    liabilities?: LiabilityUncheckedUpdateManyWithoutWorkspaceNestedInput
    scenarios?: ScenarioUncheckedUpdateManyWithoutWorkspaceNestedInput
    bankConnections?: BankConnectionUncheckedUpdateManyWithoutWorkspaceNestedInput
    autoRules?: AutoRuleUncheckedUpdateManyWithoutWorkspaceNestedInput
    cashFlowProjections?: CashFlowProjectionUncheckedUpdateManyWithoutWorkspaceNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type UserCreateWithoutScenariosInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    avatarUrl?: string | null
    phone?: string | null
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    workspaces?: WorkspaceMemberCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    gamification?: UserGamificationCreateNestedOneWithoutUserInput
    aiInsights?: AIInsightCreateNestedManyWithoutUserInput
    autoRules?: AutoRuleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutScenariosInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    avatarUrl?: string | null
    phone?: string | null
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    workspaces?: WorkspaceMemberUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    gamification?: UserGamificationUncheckedCreateNestedOneWithoutUserInput
    aiInsights?: AIInsightUncheckedCreateNestedManyWithoutUserInput
    autoRules?: AutoRuleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutScenariosInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutScenariosInput, UserUncheckedCreateWithoutScenariosInput>
  }

  export type WorkspaceCreateWithoutScenariosInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    type: string
    currency?: string
    timezone?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberCreateNestedManyWithoutWorkspaceInput
    accounts?: AccountCreateNestedManyWithoutWorkspaceInput
    categories?: CategoryCreateNestedManyWithoutWorkspaceInput
    goals?: GoalCreateNestedManyWithoutWorkspaceInput
    budgets?: BudgetCreateNestedManyWithoutWorkspaceInput
    imports?: ImportJobCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogCreateNestedManyWithoutWorkspaceInput
    envelopes?: EnvelopeCreateNestedManyWithoutWorkspaceInput
    assets?: AssetCreateNestedManyWithoutWorkspaceInput
    liabilities?: LiabilityCreateNestedManyWithoutWorkspaceInput
    aiInsights?: AIInsightCreateNestedManyWithoutWorkspaceInput
    bankConnections?: BankConnectionCreateNestedManyWithoutWorkspaceInput
    autoRules?: AutoRuleCreateNestedManyWithoutWorkspaceInput
    cashFlowProjections?: CashFlowProjectionCreateNestedManyWithoutWorkspaceInput
    Transaction?: TransactionCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutScenariosInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    type: string
    currency?: string
    timezone?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberUncheckedCreateNestedManyWithoutWorkspaceInput
    accounts?: AccountUncheckedCreateNestedManyWithoutWorkspaceInput
    categories?: CategoryUncheckedCreateNestedManyWithoutWorkspaceInput
    goals?: GoalUncheckedCreateNestedManyWithoutWorkspaceInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutWorkspaceInput
    imports?: ImportJobUncheckedCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutWorkspaceInput
    envelopes?: EnvelopeUncheckedCreateNestedManyWithoutWorkspaceInput
    assets?: AssetUncheckedCreateNestedManyWithoutWorkspaceInput
    liabilities?: LiabilityUncheckedCreateNestedManyWithoutWorkspaceInput
    aiInsights?: AIInsightUncheckedCreateNestedManyWithoutWorkspaceInput
    bankConnections?: BankConnectionUncheckedCreateNestedManyWithoutWorkspaceInput
    autoRules?: AutoRuleUncheckedCreateNestedManyWithoutWorkspaceInput
    cashFlowProjections?: CashFlowProjectionUncheckedCreateNestedManyWithoutWorkspaceInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutScenariosInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutScenariosInput, WorkspaceUncheckedCreateWithoutScenariosInput>
  }

  export type UserUpsertWithoutScenariosInput = {
    update: XOR<UserUpdateWithoutScenariosInput, UserUncheckedUpdateWithoutScenariosInput>
    create: XOR<UserCreateWithoutScenariosInput, UserUncheckedCreateWithoutScenariosInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutScenariosInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutScenariosInput, UserUncheckedUpdateWithoutScenariosInput>
  }

  export type UserUpdateWithoutScenariosInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workspaces?: WorkspaceMemberUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    gamification?: UserGamificationUpdateOneWithoutUserNestedInput
    aiInsights?: AIInsightUpdateManyWithoutUserNestedInput
    autoRules?: AutoRuleUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutScenariosInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workspaces?: WorkspaceMemberUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    gamification?: UserGamificationUncheckedUpdateOneWithoutUserNestedInput
    aiInsights?: AIInsightUncheckedUpdateManyWithoutUserNestedInput
    autoRules?: AutoRuleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WorkspaceUpsertWithoutScenariosInput = {
    update: XOR<WorkspaceUpdateWithoutScenariosInput, WorkspaceUncheckedUpdateWithoutScenariosInput>
    create: XOR<WorkspaceCreateWithoutScenariosInput, WorkspaceUncheckedCreateWithoutScenariosInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutScenariosInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutScenariosInput, WorkspaceUncheckedUpdateWithoutScenariosInput>
  }

  export type WorkspaceUpdateWithoutScenariosInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUpdateManyWithoutWorkspaceNestedInput
    accounts?: AccountUpdateManyWithoutWorkspaceNestedInput
    categories?: CategoryUpdateManyWithoutWorkspaceNestedInput
    goals?: GoalUpdateManyWithoutWorkspaceNestedInput
    budgets?: BudgetUpdateManyWithoutWorkspaceNestedInput
    imports?: ImportJobUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUpdateManyWithoutWorkspaceNestedInput
    envelopes?: EnvelopeUpdateManyWithoutWorkspaceNestedInput
    assets?: AssetUpdateManyWithoutWorkspaceNestedInput
    liabilities?: LiabilityUpdateManyWithoutWorkspaceNestedInput
    aiInsights?: AIInsightUpdateManyWithoutWorkspaceNestedInput
    bankConnections?: BankConnectionUpdateManyWithoutWorkspaceNestedInput
    autoRules?: AutoRuleUpdateManyWithoutWorkspaceNestedInput
    cashFlowProjections?: CashFlowProjectionUpdateManyWithoutWorkspaceNestedInput
    Transaction?: TransactionUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutScenariosInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUncheckedUpdateManyWithoutWorkspaceNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutWorkspaceNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutWorkspaceNestedInput
    goals?: GoalUncheckedUpdateManyWithoutWorkspaceNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutWorkspaceNestedInput
    imports?: ImportJobUncheckedUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutWorkspaceNestedInput
    envelopes?: EnvelopeUncheckedUpdateManyWithoutWorkspaceNestedInput
    assets?: AssetUncheckedUpdateManyWithoutWorkspaceNestedInput
    liabilities?: LiabilityUncheckedUpdateManyWithoutWorkspaceNestedInput
    aiInsights?: AIInsightUncheckedUpdateManyWithoutWorkspaceNestedInput
    bankConnections?: BankConnectionUncheckedUpdateManyWithoutWorkspaceNestedInput
    autoRules?: AutoRuleUncheckedUpdateManyWithoutWorkspaceNestedInput
    cashFlowProjections?: CashFlowProjectionUncheckedUpdateManyWithoutWorkspaceNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceCreateWithoutBankConnectionsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    type: string
    currency?: string
    timezone?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberCreateNestedManyWithoutWorkspaceInput
    accounts?: AccountCreateNestedManyWithoutWorkspaceInput
    categories?: CategoryCreateNestedManyWithoutWorkspaceInput
    goals?: GoalCreateNestedManyWithoutWorkspaceInput
    budgets?: BudgetCreateNestedManyWithoutWorkspaceInput
    imports?: ImportJobCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogCreateNestedManyWithoutWorkspaceInput
    envelopes?: EnvelopeCreateNestedManyWithoutWorkspaceInput
    assets?: AssetCreateNestedManyWithoutWorkspaceInput
    liabilities?: LiabilityCreateNestedManyWithoutWorkspaceInput
    aiInsights?: AIInsightCreateNestedManyWithoutWorkspaceInput
    scenarios?: ScenarioCreateNestedManyWithoutWorkspaceInput
    autoRules?: AutoRuleCreateNestedManyWithoutWorkspaceInput
    cashFlowProjections?: CashFlowProjectionCreateNestedManyWithoutWorkspaceInput
    Transaction?: TransactionCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutBankConnectionsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    type: string
    currency?: string
    timezone?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberUncheckedCreateNestedManyWithoutWorkspaceInput
    accounts?: AccountUncheckedCreateNestedManyWithoutWorkspaceInput
    categories?: CategoryUncheckedCreateNestedManyWithoutWorkspaceInput
    goals?: GoalUncheckedCreateNestedManyWithoutWorkspaceInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutWorkspaceInput
    imports?: ImportJobUncheckedCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutWorkspaceInput
    envelopes?: EnvelopeUncheckedCreateNestedManyWithoutWorkspaceInput
    assets?: AssetUncheckedCreateNestedManyWithoutWorkspaceInput
    liabilities?: LiabilityUncheckedCreateNestedManyWithoutWorkspaceInput
    aiInsights?: AIInsightUncheckedCreateNestedManyWithoutWorkspaceInput
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutWorkspaceInput
    autoRules?: AutoRuleUncheckedCreateNestedManyWithoutWorkspaceInput
    cashFlowProjections?: CashFlowProjectionUncheckedCreateNestedManyWithoutWorkspaceInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutBankConnectionsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutBankConnectionsInput, WorkspaceUncheckedCreateWithoutBankConnectionsInput>
  }

  export type AccountCreateWithoutBankConnectionsInput = {
    id?: string
    name: string
    type: string
    description?: string | null
    bankName?: string | null
    bankCode?: string | null
    agency?: string | null
    accountNumber?: string | null
    initialBalance?: number
    currentBalance?: number
    creditLimit?: number | null
    closingDay?: number | null
    dueDay?: number | null
    color?: string
    icon?: string
    isActive?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutAccountsInput
    transactions?: TransactionCreateNestedManyWithoutAccountInput
    fromTransfers?: TransferCreateNestedManyWithoutFromAccountInput
    toTransfers?: TransferCreateNestedManyWithoutToAccountInput
  }

  export type AccountUncheckedCreateWithoutBankConnectionsInput = {
    id?: string
    workspaceId: string
    name: string
    type: string
    description?: string | null
    bankName?: string | null
    bankCode?: string | null
    agency?: string | null
    accountNumber?: string | null
    initialBalance?: number
    currentBalance?: number
    creditLimit?: number | null
    closingDay?: number | null
    dueDay?: number | null
    color?: string
    icon?: string
    isActive?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutAccountInput
    fromTransfers?: TransferUncheckedCreateNestedManyWithoutFromAccountInput
    toTransfers?: TransferUncheckedCreateNestedManyWithoutToAccountInput
  }

  export type AccountCreateOrConnectWithoutBankConnectionsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutBankConnectionsInput, AccountUncheckedCreateWithoutBankConnectionsInput>
  }

  export type WorkspaceUpsertWithoutBankConnectionsInput = {
    update: XOR<WorkspaceUpdateWithoutBankConnectionsInput, WorkspaceUncheckedUpdateWithoutBankConnectionsInput>
    create: XOR<WorkspaceCreateWithoutBankConnectionsInput, WorkspaceUncheckedCreateWithoutBankConnectionsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutBankConnectionsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutBankConnectionsInput, WorkspaceUncheckedUpdateWithoutBankConnectionsInput>
  }

  export type WorkspaceUpdateWithoutBankConnectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUpdateManyWithoutWorkspaceNestedInput
    accounts?: AccountUpdateManyWithoutWorkspaceNestedInput
    categories?: CategoryUpdateManyWithoutWorkspaceNestedInput
    goals?: GoalUpdateManyWithoutWorkspaceNestedInput
    budgets?: BudgetUpdateManyWithoutWorkspaceNestedInput
    imports?: ImportJobUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUpdateManyWithoutWorkspaceNestedInput
    envelopes?: EnvelopeUpdateManyWithoutWorkspaceNestedInput
    assets?: AssetUpdateManyWithoutWorkspaceNestedInput
    liabilities?: LiabilityUpdateManyWithoutWorkspaceNestedInput
    aiInsights?: AIInsightUpdateManyWithoutWorkspaceNestedInput
    scenarios?: ScenarioUpdateManyWithoutWorkspaceNestedInput
    autoRules?: AutoRuleUpdateManyWithoutWorkspaceNestedInput
    cashFlowProjections?: CashFlowProjectionUpdateManyWithoutWorkspaceNestedInput
    Transaction?: TransactionUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutBankConnectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUncheckedUpdateManyWithoutWorkspaceNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutWorkspaceNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutWorkspaceNestedInput
    goals?: GoalUncheckedUpdateManyWithoutWorkspaceNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutWorkspaceNestedInput
    imports?: ImportJobUncheckedUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutWorkspaceNestedInput
    envelopes?: EnvelopeUncheckedUpdateManyWithoutWorkspaceNestedInput
    assets?: AssetUncheckedUpdateManyWithoutWorkspaceNestedInput
    liabilities?: LiabilityUncheckedUpdateManyWithoutWorkspaceNestedInput
    aiInsights?: AIInsightUncheckedUpdateManyWithoutWorkspaceNestedInput
    scenarios?: ScenarioUncheckedUpdateManyWithoutWorkspaceNestedInput
    autoRules?: AutoRuleUncheckedUpdateManyWithoutWorkspaceNestedInput
    cashFlowProjections?: CashFlowProjectionUncheckedUpdateManyWithoutWorkspaceNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type AccountUpsertWithoutBankConnectionsInput = {
    update: XOR<AccountUpdateWithoutBankConnectionsInput, AccountUncheckedUpdateWithoutBankConnectionsInput>
    create: XOR<AccountCreateWithoutBankConnectionsInput, AccountUncheckedCreateWithoutBankConnectionsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutBankConnectionsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutBankConnectionsInput, AccountUncheckedUpdateWithoutBankConnectionsInput>
  }

  export type AccountUpdateWithoutBankConnectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankCode?: NullableStringFieldUpdateOperationsInput | string | null
    agency?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initialBalance?: FloatFieldUpdateOperationsInput | number
    currentBalance?: FloatFieldUpdateOperationsInput | number
    creditLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    closingDay?: NullableIntFieldUpdateOperationsInput | number | null
    dueDay?: NullableIntFieldUpdateOperationsInput | number | null
    color?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutAccountsNestedInput
    transactions?: TransactionUpdateManyWithoutAccountNestedInput
    fromTransfers?: TransferUpdateManyWithoutFromAccountNestedInput
    toTransfers?: TransferUpdateManyWithoutToAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutBankConnectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankCode?: NullableStringFieldUpdateOperationsInput | string | null
    agency?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initialBalance?: FloatFieldUpdateOperationsInput | number
    currentBalance?: FloatFieldUpdateOperationsInput | number
    creditLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    closingDay?: NullableIntFieldUpdateOperationsInput | number | null
    dueDay?: NullableIntFieldUpdateOperationsInput | number | null
    color?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutAccountNestedInput
    fromTransfers?: TransferUncheckedUpdateManyWithoutFromAccountNestedInput
    toTransfers?: TransferUncheckedUpdateManyWithoutToAccountNestedInput
  }

  export type UserCreateWithoutAutoRulesInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    avatarUrl?: string | null
    phone?: string | null
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    workspaces?: WorkspaceMemberCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    gamification?: UserGamificationCreateNestedOneWithoutUserInput
    aiInsights?: AIInsightCreateNestedManyWithoutUserInput
    scenarios?: ScenarioCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAutoRulesInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    avatarUrl?: string | null
    phone?: string | null
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    workspaces?: WorkspaceMemberUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    gamification?: UserGamificationUncheckedCreateNestedOneWithoutUserInput
    aiInsights?: AIInsightUncheckedCreateNestedManyWithoutUserInput
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAutoRulesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAutoRulesInput, UserUncheckedCreateWithoutAutoRulesInput>
  }

  export type WorkspaceCreateWithoutAutoRulesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    type: string
    currency?: string
    timezone?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberCreateNestedManyWithoutWorkspaceInput
    accounts?: AccountCreateNestedManyWithoutWorkspaceInput
    categories?: CategoryCreateNestedManyWithoutWorkspaceInput
    goals?: GoalCreateNestedManyWithoutWorkspaceInput
    budgets?: BudgetCreateNestedManyWithoutWorkspaceInput
    imports?: ImportJobCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogCreateNestedManyWithoutWorkspaceInput
    envelopes?: EnvelopeCreateNestedManyWithoutWorkspaceInput
    assets?: AssetCreateNestedManyWithoutWorkspaceInput
    liabilities?: LiabilityCreateNestedManyWithoutWorkspaceInput
    aiInsights?: AIInsightCreateNestedManyWithoutWorkspaceInput
    scenarios?: ScenarioCreateNestedManyWithoutWorkspaceInput
    bankConnections?: BankConnectionCreateNestedManyWithoutWorkspaceInput
    cashFlowProjections?: CashFlowProjectionCreateNestedManyWithoutWorkspaceInput
    Transaction?: TransactionCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutAutoRulesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    type: string
    currency?: string
    timezone?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberUncheckedCreateNestedManyWithoutWorkspaceInput
    accounts?: AccountUncheckedCreateNestedManyWithoutWorkspaceInput
    categories?: CategoryUncheckedCreateNestedManyWithoutWorkspaceInput
    goals?: GoalUncheckedCreateNestedManyWithoutWorkspaceInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutWorkspaceInput
    imports?: ImportJobUncheckedCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutWorkspaceInput
    envelopes?: EnvelopeUncheckedCreateNestedManyWithoutWorkspaceInput
    assets?: AssetUncheckedCreateNestedManyWithoutWorkspaceInput
    liabilities?: LiabilityUncheckedCreateNestedManyWithoutWorkspaceInput
    aiInsights?: AIInsightUncheckedCreateNestedManyWithoutWorkspaceInput
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutWorkspaceInput
    bankConnections?: BankConnectionUncheckedCreateNestedManyWithoutWorkspaceInput
    cashFlowProjections?: CashFlowProjectionUncheckedCreateNestedManyWithoutWorkspaceInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutAutoRulesInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutAutoRulesInput, WorkspaceUncheckedCreateWithoutAutoRulesInput>
  }

  export type UserUpsertWithoutAutoRulesInput = {
    update: XOR<UserUpdateWithoutAutoRulesInput, UserUncheckedUpdateWithoutAutoRulesInput>
    create: XOR<UserCreateWithoutAutoRulesInput, UserUncheckedCreateWithoutAutoRulesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAutoRulesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAutoRulesInput, UserUncheckedUpdateWithoutAutoRulesInput>
  }

  export type UserUpdateWithoutAutoRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workspaces?: WorkspaceMemberUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    gamification?: UserGamificationUpdateOneWithoutUserNestedInput
    aiInsights?: AIInsightUpdateManyWithoutUserNestedInput
    scenarios?: ScenarioUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAutoRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workspaces?: WorkspaceMemberUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    gamification?: UserGamificationUncheckedUpdateOneWithoutUserNestedInput
    aiInsights?: AIInsightUncheckedUpdateManyWithoutUserNestedInput
    scenarios?: ScenarioUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WorkspaceUpsertWithoutAutoRulesInput = {
    update: XOR<WorkspaceUpdateWithoutAutoRulesInput, WorkspaceUncheckedUpdateWithoutAutoRulesInput>
    create: XOR<WorkspaceCreateWithoutAutoRulesInput, WorkspaceUncheckedCreateWithoutAutoRulesInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutAutoRulesInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutAutoRulesInput, WorkspaceUncheckedUpdateWithoutAutoRulesInput>
  }

  export type WorkspaceUpdateWithoutAutoRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUpdateManyWithoutWorkspaceNestedInput
    accounts?: AccountUpdateManyWithoutWorkspaceNestedInput
    categories?: CategoryUpdateManyWithoutWorkspaceNestedInput
    goals?: GoalUpdateManyWithoutWorkspaceNestedInput
    budgets?: BudgetUpdateManyWithoutWorkspaceNestedInput
    imports?: ImportJobUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUpdateManyWithoutWorkspaceNestedInput
    envelopes?: EnvelopeUpdateManyWithoutWorkspaceNestedInput
    assets?: AssetUpdateManyWithoutWorkspaceNestedInput
    liabilities?: LiabilityUpdateManyWithoutWorkspaceNestedInput
    aiInsights?: AIInsightUpdateManyWithoutWorkspaceNestedInput
    scenarios?: ScenarioUpdateManyWithoutWorkspaceNestedInput
    bankConnections?: BankConnectionUpdateManyWithoutWorkspaceNestedInput
    cashFlowProjections?: CashFlowProjectionUpdateManyWithoutWorkspaceNestedInput
    Transaction?: TransactionUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutAutoRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUncheckedUpdateManyWithoutWorkspaceNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutWorkspaceNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutWorkspaceNestedInput
    goals?: GoalUncheckedUpdateManyWithoutWorkspaceNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutWorkspaceNestedInput
    imports?: ImportJobUncheckedUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutWorkspaceNestedInput
    envelopes?: EnvelopeUncheckedUpdateManyWithoutWorkspaceNestedInput
    assets?: AssetUncheckedUpdateManyWithoutWorkspaceNestedInput
    liabilities?: LiabilityUncheckedUpdateManyWithoutWorkspaceNestedInput
    aiInsights?: AIInsightUncheckedUpdateManyWithoutWorkspaceNestedInput
    scenarios?: ScenarioUncheckedUpdateManyWithoutWorkspaceNestedInput
    bankConnections?: BankConnectionUncheckedUpdateManyWithoutWorkspaceNestedInput
    cashFlowProjections?: CashFlowProjectionUncheckedUpdateManyWithoutWorkspaceNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceCreateWithoutCashFlowProjectionsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    type: string
    currency?: string
    timezone?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberCreateNestedManyWithoutWorkspaceInput
    accounts?: AccountCreateNestedManyWithoutWorkspaceInput
    categories?: CategoryCreateNestedManyWithoutWorkspaceInput
    goals?: GoalCreateNestedManyWithoutWorkspaceInput
    budgets?: BudgetCreateNestedManyWithoutWorkspaceInput
    imports?: ImportJobCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogCreateNestedManyWithoutWorkspaceInput
    envelopes?: EnvelopeCreateNestedManyWithoutWorkspaceInput
    assets?: AssetCreateNestedManyWithoutWorkspaceInput
    liabilities?: LiabilityCreateNestedManyWithoutWorkspaceInput
    aiInsights?: AIInsightCreateNestedManyWithoutWorkspaceInput
    scenarios?: ScenarioCreateNestedManyWithoutWorkspaceInput
    bankConnections?: BankConnectionCreateNestedManyWithoutWorkspaceInput
    autoRules?: AutoRuleCreateNestedManyWithoutWorkspaceInput
    Transaction?: TransactionCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutCashFlowProjectionsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    type: string
    currency?: string
    timezone?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberUncheckedCreateNestedManyWithoutWorkspaceInput
    accounts?: AccountUncheckedCreateNestedManyWithoutWorkspaceInput
    categories?: CategoryUncheckedCreateNestedManyWithoutWorkspaceInput
    goals?: GoalUncheckedCreateNestedManyWithoutWorkspaceInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutWorkspaceInput
    imports?: ImportJobUncheckedCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutWorkspaceInput
    envelopes?: EnvelopeUncheckedCreateNestedManyWithoutWorkspaceInput
    assets?: AssetUncheckedCreateNestedManyWithoutWorkspaceInput
    liabilities?: LiabilityUncheckedCreateNestedManyWithoutWorkspaceInput
    aiInsights?: AIInsightUncheckedCreateNestedManyWithoutWorkspaceInput
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutWorkspaceInput
    bankConnections?: BankConnectionUncheckedCreateNestedManyWithoutWorkspaceInput
    autoRules?: AutoRuleUncheckedCreateNestedManyWithoutWorkspaceInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutCashFlowProjectionsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutCashFlowProjectionsInput, WorkspaceUncheckedCreateWithoutCashFlowProjectionsInput>
  }

  export type WorkspaceUpsertWithoutCashFlowProjectionsInput = {
    update: XOR<WorkspaceUpdateWithoutCashFlowProjectionsInput, WorkspaceUncheckedUpdateWithoutCashFlowProjectionsInput>
    create: XOR<WorkspaceCreateWithoutCashFlowProjectionsInput, WorkspaceUncheckedCreateWithoutCashFlowProjectionsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutCashFlowProjectionsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutCashFlowProjectionsInput, WorkspaceUncheckedUpdateWithoutCashFlowProjectionsInput>
  }

  export type WorkspaceUpdateWithoutCashFlowProjectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUpdateManyWithoutWorkspaceNestedInput
    accounts?: AccountUpdateManyWithoutWorkspaceNestedInput
    categories?: CategoryUpdateManyWithoutWorkspaceNestedInput
    goals?: GoalUpdateManyWithoutWorkspaceNestedInput
    budgets?: BudgetUpdateManyWithoutWorkspaceNestedInput
    imports?: ImportJobUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUpdateManyWithoutWorkspaceNestedInput
    envelopes?: EnvelopeUpdateManyWithoutWorkspaceNestedInput
    assets?: AssetUpdateManyWithoutWorkspaceNestedInput
    liabilities?: LiabilityUpdateManyWithoutWorkspaceNestedInput
    aiInsights?: AIInsightUpdateManyWithoutWorkspaceNestedInput
    scenarios?: ScenarioUpdateManyWithoutWorkspaceNestedInput
    bankConnections?: BankConnectionUpdateManyWithoutWorkspaceNestedInput
    autoRules?: AutoRuleUpdateManyWithoutWorkspaceNestedInput
    Transaction?: TransactionUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutCashFlowProjectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUncheckedUpdateManyWithoutWorkspaceNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutWorkspaceNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutWorkspaceNestedInput
    goals?: GoalUncheckedUpdateManyWithoutWorkspaceNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutWorkspaceNestedInput
    imports?: ImportJobUncheckedUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutWorkspaceNestedInput
    envelopes?: EnvelopeUncheckedUpdateManyWithoutWorkspaceNestedInput
    assets?: AssetUncheckedUpdateManyWithoutWorkspaceNestedInput
    liabilities?: LiabilityUncheckedUpdateManyWithoutWorkspaceNestedInput
    aiInsights?: AIInsightUncheckedUpdateManyWithoutWorkspaceNestedInput
    scenarios?: ScenarioUncheckedUpdateManyWithoutWorkspaceNestedInput
    bankConnections?: BankConnectionUncheckedUpdateManyWithoutWorkspaceNestedInput
    autoRules?: AutoRuleUncheckedUpdateManyWithoutWorkspaceNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceMemberCreateManyUserInput = {
    id?: string
    workspaceId: string
    role: string
    joinedAt?: Date | string
    invitedBy?: string | null
  }

  export type SessionCreateManyUserInput = {
    id?: string
    token: string
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    workspaceId?: string | null
    type: string
    title: string
    message: string
    data?: string | null
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    workspaceId?: string | null
    action: string
    entityType: string
    entityId?: string | null
    oldData?: string | null
    newData?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type PasswordResetCreateManyUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type RefreshTokenCreateManyUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    revokedAt?: Date | string | null
  }

  export type AIInsightCreateManyUserInput = {
    id?: string
    workspaceId: string
    type: string
    title: string
    description: string
    severity: string
    suggestedAction?: string | null
    actionTaken?: boolean
    confidenceScore?: number | null
    dismissedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ScenarioCreateManyUserInput = {
    id?: string
    workspaceId: string
    name: string
    description?: string | null
    type: string
    parameters: string
    isFavorite?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AutoRuleCreateManyUserInput = {
    id?: string
    workspaceId: string
    name: string
    description?: string | null
    isActive?: boolean
    priority?: number
    conditions: string
    actions: string
    timesApplied?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkspaceMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    workspace?: WorkspaceUpdateOneRequiredWithoutMembersNestedInput
  }

  export type WorkspaceMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkspaceMemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldData?: NullableStringFieldUpdateOperationsInput | string | null
    newData?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Workspace?: WorkspaceUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldData?: NullableStringFieldUpdateOperationsInput | string | null
    newData?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldData?: NullableStringFieldUpdateOperationsInput | string | null
    newData?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefreshTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AIInsightUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    suggestedAction?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: BoolFieldUpdateOperationsInput | boolean
    confidenceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Workspace?: WorkspaceUpdateOneRequiredWithoutAiInsightsNestedInput
  }

  export type AIInsightUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    suggestedAction?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: BoolFieldUpdateOperationsInput | boolean
    confidenceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIInsightUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    suggestedAction?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: BoolFieldUpdateOperationsInput | boolean
    confidenceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScenarioUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    parameters?: StringFieldUpdateOperationsInput | string
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Workspace?: WorkspaceUpdateOneRequiredWithoutScenariosNestedInput
  }

  export type ScenarioUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    parameters?: StringFieldUpdateOperationsInput | string
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScenarioUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    parameters?: StringFieldUpdateOperationsInput | string
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutoRuleUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    conditions?: StringFieldUpdateOperationsInput | string
    actions?: StringFieldUpdateOperationsInput | string
    timesApplied?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Workspace?: WorkspaceUpdateOneRequiredWithoutAutoRulesNestedInput
  }

  export type AutoRuleUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    conditions?: StringFieldUpdateOperationsInput | string
    actions?: StringFieldUpdateOperationsInput | string
    timesApplied?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutoRuleUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    conditions?: StringFieldUpdateOperationsInput | string
    actions?: StringFieldUpdateOperationsInput | string
    timesApplied?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceMemberCreateManyWorkspaceInput = {
    id?: string
    userId: string
    role: string
    joinedAt?: Date | string
    invitedBy?: string | null
  }

  export type AccountCreateManyWorkspaceInput = {
    id?: string
    name: string
    type: string
    description?: string | null
    bankName?: string | null
    bankCode?: string | null
    agency?: string | null
    accountNumber?: string | null
    initialBalance?: number
    currentBalance?: number
    creditLimit?: number | null
    closingDay?: number | null
    dueDay?: number | null
    color?: string
    icon?: string
    isActive?: boolean
    archivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryCreateManyWorkspaceInput = {
    id?: string
    parentId?: string | null
    name: string
    type: string
    color?: string
    icon?: string
    description?: string | null
    keywords: string
    isSystem?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GoalCreateManyWorkspaceInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    targetAmount: number
    currentAmount?: number
    startDate: Date | string
    targetDate?: Date | string | null
    completedAt?: Date | string | null
    status: string
    icon?: string
    color?: string
    autoAllocate?: boolean
    allocationPercentage?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BudgetCreateManyWorkspaceInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    totalBudgeted: number
    totalSpent?: number
    isActive?: boolean
    alertThreshold?: number
    alertSent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImportJobCreateManyWorkspaceInput = {
    id?: string
    accountId: string
    format: string
    fileName: string
    fileSize: number
    fileUrl?: string | null
    status: string
    progress?: number
    totalRows?: number
    processedRows?: number
    importedRows?: number
    errorLog?: string | null
    mappingConfig?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateManyWorkspaceInput = {
    id?: string
    userId?: string | null
    action: string
    entityType: string
    entityId?: string | null
    oldData?: string | null
    newData?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type EnvelopeCreateManyWorkspaceInput = {
    id?: string
    categoryId?: string | null
    name: string
    description?: string | null
    color?: string
    budgetedAmount: number
    availableAmount?: number
    spentAmount?: number
    month: number
    year: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssetCreateManyWorkspaceInput = {
    id?: string
    name: string
    type: string
    description?: string | null
    currentValue: number
    purchaseValue?: number | null
    purchaseDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LiabilityCreateManyWorkspaceInput = {
    id?: string
    name: string
    type: string
    description?: string | null
    currentBalance: number
    originalAmount: number
    interestRate?: number | null
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIInsightCreateManyWorkspaceInput = {
    id?: string
    userId: string
    type: string
    title: string
    description: string
    severity: string
    suggestedAction?: string | null
    actionTaken?: boolean
    confidenceScore?: number | null
    dismissedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ScenarioCreateManyWorkspaceInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    type: string
    parameters: string
    isFavorite?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankConnectionCreateManyWorkspaceInput = {
    id?: string
    accountId: string
    bankName: string
    bankCode: string
    accessToken: string
    status: string
    lastSyncAt?: Date | string | null
    lastSyncError?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AutoRuleCreateManyWorkspaceInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    isActive?: boolean
    priority?: number
    conditions: string
    actions: string
    timesApplied?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CashFlowProjectionCreateManyWorkspaceInput = {
    id?: string
    month: number
    year: number
    projectedIncome: number
    projectedExpense: number
    projectedBalance: number
    generatedAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateManyWorkspaceInput = {
    id?: string
    accountId: string
    categoryId?: string | null
    creditCardId?: string | null
    type: string
    description: string
    amount: number
    currency?: string
    status: string
    transactionDate: Date | string
    confirmedAt?: Date | string | null
    recurrenceId?: string | null
    notes?: string | null
    tags: string
    attachmentUrl?: string | null
    location?: string | null
    importId?: string | null
    rawData?: string | null
    aiConfidence?: number | null
    aiCategory?: string | null
    aiCategorizedAt?: Date | string | null
    aiModelVersion?: string | null
    autoRuleId?: string | null
    bankConnectionId?: string | null
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkspaceMemberUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutWorkspacesNestedInput
  }

  export type WorkspaceMemberUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkspaceMemberUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankCode?: NullableStringFieldUpdateOperationsInput | string | null
    agency?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initialBalance?: FloatFieldUpdateOperationsInput | number
    currentBalance?: FloatFieldUpdateOperationsInput | number
    creditLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    closingDay?: NullableIntFieldUpdateOperationsInput | number | null
    dueDay?: NullableIntFieldUpdateOperationsInput | number | null
    color?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUpdateManyWithoutAccountNestedInput
    fromTransfers?: TransferUpdateManyWithoutFromAccountNestedInput
    toTransfers?: TransferUpdateManyWithoutToAccountNestedInput
    bankConnections?: BankConnectionUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankCode?: NullableStringFieldUpdateOperationsInput | string | null
    agency?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initialBalance?: FloatFieldUpdateOperationsInput | number
    currentBalance?: FloatFieldUpdateOperationsInput | number
    creditLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    closingDay?: NullableIntFieldUpdateOperationsInput | number | null
    dueDay?: NullableIntFieldUpdateOperationsInput | number | null
    color?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutAccountNestedInput
    fromTransfers?: TransferUncheckedUpdateManyWithoutFromAccountNestedInput
    toTransfers?: TransferUncheckedUpdateManyWithoutToAccountNestedInput
    bankConnections?: BankConnectionUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankCode?: NullableStringFieldUpdateOperationsInput | string | null
    agency?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    initialBalance?: FloatFieldUpdateOperationsInput | number
    currentBalance?: FloatFieldUpdateOperationsInput | number
    creditLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    closingDay?: NullableIntFieldUpdateOperationsInput | number | null
    dueDay?: NullableIntFieldUpdateOperationsInput | number | null
    color?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: StringFieldUpdateOperationsInput | string
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    children?: CategoryUpdateManyWithoutParentNestedInput
    transactions?: TransactionUpdateManyWithoutCategoryNestedInput
    budgets?: BudgetCategoryUpdateManyWithoutCategoryNestedInput
    envelopes?: EnvelopeUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: StringFieldUpdateOperationsInput | string
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCategoryNestedInput
    budgets?: BudgetCategoryUncheckedUpdateManyWithoutCategoryNestedInput
    envelopes?: EnvelopeUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: StringFieldUpdateOperationsInput | string
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoalUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    targetAmount?: FloatFieldUpdateOperationsInput | number
    currentAmount?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    autoAllocate?: BoolFieldUpdateOperationsInput | boolean
    allocationPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contributions?: GoalContributionUpdateManyWithoutGoalNestedInput
  }

  export type GoalUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    targetAmount?: FloatFieldUpdateOperationsInput | number
    currentAmount?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    autoAllocate?: BoolFieldUpdateOperationsInput | boolean
    allocationPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contributions?: GoalContributionUncheckedUpdateManyWithoutGoalNestedInput
  }

  export type GoalUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    targetAmount?: FloatFieldUpdateOperationsInput | number
    currentAmount?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    autoAllocate?: BoolFieldUpdateOperationsInput | boolean
    allocationPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalBudgeted?: FloatFieldUpdateOperationsInput | number
    totalSpent?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    alertThreshold?: IntFieldUpdateOperationsInput | number
    alertSent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: BudgetCategoryUpdateManyWithoutBudgetNestedInput
  }

  export type BudgetUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalBudgeted?: FloatFieldUpdateOperationsInput | number
    totalSpent?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    alertThreshold?: IntFieldUpdateOperationsInput | number
    alertSent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: BudgetCategoryUncheckedUpdateManyWithoutBudgetNestedInput
  }

  export type BudgetUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalBudgeted?: FloatFieldUpdateOperationsInput | number
    totalSpent?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    alertThreshold?: IntFieldUpdateOperationsInput | number
    alertSent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImportJobUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    totalRows?: IntFieldUpdateOperationsInput | number
    processedRows?: IntFieldUpdateOperationsInput | number
    importedRows?: IntFieldUpdateOperationsInput | number
    errorLog?: NullableStringFieldUpdateOperationsInput | string | null
    mappingConfig?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImportJobUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    totalRows?: IntFieldUpdateOperationsInput | number
    processedRows?: IntFieldUpdateOperationsInput | number
    importedRows?: IntFieldUpdateOperationsInput | number
    errorLog?: NullableStringFieldUpdateOperationsInput | string | null
    mappingConfig?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImportJobUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    totalRows?: IntFieldUpdateOperationsInput | number
    processedRows?: IntFieldUpdateOperationsInput | number
    importedRows?: IntFieldUpdateOperationsInput | number
    errorLog?: NullableStringFieldUpdateOperationsInput | string | null
    mappingConfig?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldData?: NullableStringFieldUpdateOperationsInput | string | null
    newData?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldData?: NullableStringFieldUpdateOperationsInput | string | null
    newData?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldData?: NullableStringFieldUpdateOperationsInput | string | null
    newData?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnvelopeUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    budgetedAmount?: FloatFieldUpdateOperationsInput | number
    availableAmount?: FloatFieldUpdateOperationsInput | number
    spentAmount?: FloatFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Category?: CategoryUpdateOneWithoutEnvelopesNestedInput
  }

  export type EnvelopeUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    budgetedAmount?: FloatFieldUpdateOperationsInput | number
    availableAmount?: FloatFieldUpdateOperationsInput | number
    spentAmount?: FloatFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnvelopeUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    budgetedAmount?: FloatFieldUpdateOperationsInput | number
    availableAmount?: FloatFieldUpdateOperationsInput | number
    spentAmount?: FloatFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currentValue?: FloatFieldUpdateOperationsInput | number
    purchaseValue?: NullableFloatFieldUpdateOperationsInput | number | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currentValue?: FloatFieldUpdateOperationsInput | number
    purchaseValue?: NullableFloatFieldUpdateOperationsInput | number | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currentValue?: FloatFieldUpdateOperationsInput | number
    purchaseValue?: NullableFloatFieldUpdateOperationsInput | number | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LiabilityUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currentBalance?: FloatFieldUpdateOperationsInput | number
    originalAmount?: FloatFieldUpdateOperationsInput | number
    interestRate?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LiabilityUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currentBalance?: FloatFieldUpdateOperationsInput | number
    originalAmount?: FloatFieldUpdateOperationsInput | number
    interestRate?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LiabilityUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currentBalance?: FloatFieldUpdateOperationsInput | number
    originalAmount?: FloatFieldUpdateOperationsInput | number
    interestRate?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIInsightUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    suggestedAction?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: BoolFieldUpdateOperationsInput | boolean
    confidenceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutAiInsightsNestedInput
  }

  export type AIInsightUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    suggestedAction?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: BoolFieldUpdateOperationsInput | boolean
    confidenceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIInsightUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    suggestedAction?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: BoolFieldUpdateOperationsInput | boolean
    confidenceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScenarioUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    parameters?: StringFieldUpdateOperationsInput | string
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutScenariosNestedInput
  }

  export type ScenarioUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    parameters?: StringFieldUpdateOperationsInput | string
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScenarioUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    parameters?: StringFieldUpdateOperationsInput | string
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankConnectionUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    bankCode?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSyncError?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Account?: AccountUpdateOneRequiredWithoutBankConnectionsNestedInput
  }

  export type BankConnectionUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    bankCode?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSyncError?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankConnectionUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    bankCode?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSyncError?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutoRuleUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    conditions?: StringFieldUpdateOperationsInput | string
    actions?: StringFieldUpdateOperationsInput | string
    timesApplied?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutAutoRulesNestedInput
  }

  export type AutoRuleUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    conditions?: StringFieldUpdateOperationsInput | string
    actions?: StringFieldUpdateOperationsInput | string
    timesApplied?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutoRuleUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    conditions?: StringFieldUpdateOperationsInput | string
    actions?: StringFieldUpdateOperationsInput | string
    timesApplied?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashFlowProjectionUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    projectedIncome?: FloatFieldUpdateOperationsInput | number
    projectedExpense?: FloatFieldUpdateOperationsInput | number
    projectedBalance?: FloatFieldUpdateOperationsInput | number
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashFlowProjectionUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    projectedIncome?: FloatFieldUpdateOperationsInput | number
    projectedExpense?: FloatFieldUpdateOperationsInput | number
    projectedBalance?: FloatFieldUpdateOperationsInput | number
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashFlowProjectionUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    projectedIncome?: FloatFieldUpdateOperationsInput | number
    projectedExpense?: FloatFieldUpdateOperationsInput | number
    projectedBalance?: FloatFieldUpdateOperationsInput | number
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditCardId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recurrenceId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: StringFieldUpdateOperationsInput | string
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    importId?: NullableStringFieldUpdateOperationsInput | string | null
    rawData?: NullableStringFieldUpdateOperationsInput | string | null
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiCategory?: NullableStringFieldUpdateOperationsInput | string | null
    aiCategorizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiModelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    autoRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    bankConnectionId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutTransactionsNestedInput
    category?: CategoryUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    creditCardId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recurrenceId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: StringFieldUpdateOperationsInput | string
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    importId?: NullableStringFieldUpdateOperationsInput | string | null
    rawData?: NullableStringFieldUpdateOperationsInput | string | null
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiCategory?: NullableStringFieldUpdateOperationsInput | string | null
    aiCategorizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiModelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    autoRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    bankConnectionId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    creditCardId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recurrenceId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: StringFieldUpdateOperationsInput | string
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    importId?: NullableStringFieldUpdateOperationsInput | string | null
    rawData?: NullableStringFieldUpdateOperationsInput | string | null
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiCategory?: NullableStringFieldUpdateOperationsInput | string | null
    aiCategorizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiModelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    autoRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    bankConnectionId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyAccountInput = {
    id?: string
    workspaceId: string
    categoryId?: string | null
    creditCardId?: string | null
    type: string
    description: string
    amount: number
    currency?: string
    status: string
    transactionDate: Date | string
    confirmedAt?: Date | string | null
    recurrenceId?: string | null
    notes?: string | null
    tags: string
    attachmentUrl?: string | null
    location?: string | null
    importId?: string | null
    rawData?: string | null
    aiConfidence?: number | null
    aiCategory?: string | null
    aiCategorizedAt?: Date | string | null
    aiModelVersion?: string | null
    autoRuleId?: string | null
    bankConnectionId?: string | null
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferCreateManyFromAccountInput = {
    id?: string
    workspaceId: string
    toAccountId: string
    description: string
    amount: number
    fee?: number | null
    transferDate: Date | string
    createdAt?: Date | string
  }

  export type TransferCreateManyToAccountInput = {
    id?: string
    workspaceId: string
    fromAccountId: string
    description: string
    amount: number
    fee?: number | null
    transferDate: Date | string
    createdAt?: Date | string
  }

  export type BankConnectionCreateManyAccountInput = {
    id?: string
    workspaceId: string
    bankName: string
    bankCode: string
    accessToken: string
    status: string
    lastSyncAt?: Date | string | null
    lastSyncError?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditCardId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recurrenceId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: StringFieldUpdateOperationsInput | string
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    importId?: NullableStringFieldUpdateOperationsInput | string | null
    rawData?: NullableStringFieldUpdateOperationsInput | string | null
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiCategory?: NullableStringFieldUpdateOperationsInput | string | null
    aiCategorizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiModelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    autoRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    bankConnectionId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutTransactionNestedInput
    category?: CategoryUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    creditCardId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recurrenceId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: StringFieldUpdateOperationsInput | string
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    importId?: NullableStringFieldUpdateOperationsInput | string | null
    rawData?: NullableStringFieldUpdateOperationsInput | string | null
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiCategory?: NullableStringFieldUpdateOperationsInput | string | null
    aiCategorizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiModelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    autoRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    bankConnectionId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    creditCardId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recurrenceId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: StringFieldUpdateOperationsInput | string
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    importId?: NullableStringFieldUpdateOperationsInput | string | null
    rawData?: NullableStringFieldUpdateOperationsInput | string | null
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiCategory?: NullableStringFieldUpdateOperationsInput | string | null
    aiCategorizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiModelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    autoRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    bankConnectionId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferUpdateWithoutFromAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    toAccount?: AccountUpdateOneRequiredWithoutToTransfersNestedInput
  }

  export type TransferUncheckedUpdateWithoutFromAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    toAccountId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferUncheckedUpdateManyWithoutFromAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    toAccountId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferUpdateWithoutToAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromAccount?: AccountUpdateOneRequiredWithoutFromTransfersNestedInput
  }

  export type TransferUncheckedUpdateWithoutToAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    fromAccountId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferUncheckedUpdateManyWithoutToAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    fromAccountId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    fee?: NullableFloatFieldUpdateOperationsInput | number | null
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankConnectionUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    bankCode?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSyncError?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Workspace?: WorkspaceUpdateOneRequiredWithoutBankConnectionsNestedInput
  }

  export type BankConnectionUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    bankCode?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSyncError?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankConnectionUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    bankCode?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSyncError?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateManyParentInput = {
    id?: string
    workspaceId: string
    name: string
    type: string
    color?: string
    icon?: string
    description?: string | null
    keywords: string
    isSystem?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateManyCategoryInput = {
    id?: string
    workspaceId: string
    accountId: string
    creditCardId?: string | null
    type: string
    description: string
    amount: number
    currency?: string
    status: string
    transactionDate: Date | string
    confirmedAt?: Date | string | null
    recurrenceId?: string | null
    notes?: string | null
    tags: string
    attachmentUrl?: string | null
    location?: string | null
    importId?: string | null
    rawData?: string | null
    aiConfidence?: number | null
    aiCategory?: string | null
    aiCategorizedAt?: Date | string | null
    aiModelVersion?: string | null
    autoRuleId?: string | null
    bankConnectionId?: string | null
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BudgetCategoryCreateManyCategoryInput = {
    id?: string
    budgetId: string
    budgeted: number
    spent?: number
  }

  export type EnvelopeCreateManyCategoryInput = {
    id?: string
    workspaceId: string
    name: string
    description?: string | null
    color?: string
    budgetedAmount: number
    availableAmount?: number
    spentAmount?: number
    month: number
    year: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: StringFieldUpdateOperationsInput | string
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutCategoriesNestedInput
    children?: CategoryUpdateManyWithoutParentNestedInput
    transactions?: TransactionUpdateManyWithoutCategoryNestedInput
    budgets?: BudgetCategoryUpdateManyWithoutCategoryNestedInput
    envelopes?: EnvelopeUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: StringFieldUpdateOperationsInput | string
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCategoryNestedInput
    budgets?: BudgetCategoryUncheckedUpdateManyWithoutCategoryNestedInput
    envelopes?: EnvelopeUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: StringFieldUpdateOperationsInput | string
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditCardId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recurrenceId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: StringFieldUpdateOperationsInput | string
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    importId?: NullableStringFieldUpdateOperationsInput | string | null
    rawData?: NullableStringFieldUpdateOperationsInput | string | null
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiCategory?: NullableStringFieldUpdateOperationsInput | string | null
    aiCategorizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiModelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    autoRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    bankConnectionId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutTransactionNestedInput
    account?: AccountUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    creditCardId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recurrenceId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: StringFieldUpdateOperationsInput | string
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    importId?: NullableStringFieldUpdateOperationsInput | string | null
    rawData?: NullableStringFieldUpdateOperationsInput | string | null
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiCategory?: NullableStringFieldUpdateOperationsInput | string | null
    aiCategorizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiModelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    autoRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    bankConnectionId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    creditCardId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recurrenceId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: StringFieldUpdateOperationsInput | string
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    importId?: NullableStringFieldUpdateOperationsInput | string | null
    rawData?: NullableStringFieldUpdateOperationsInput | string | null
    aiConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    aiCategory?: NullableStringFieldUpdateOperationsInput | string | null
    aiCategorizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiModelVersion?: NullableStringFieldUpdateOperationsInput | string | null
    autoRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    bankConnectionId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetCategoryUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgeted?: FloatFieldUpdateOperationsInput | number
    spent?: FloatFieldUpdateOperationsInput | number
    budget?: BudgetUpdateOneRequiredWithoutCategoriesNestedInput
  }

  export type BudgetCategoryUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetId?: StringFieldUpdateOperationsInput | string
    budgeted?: FloatFieldUpdateOperationsInput | number
    spent?: FloatFieldUpdateOperationsInput | number
  }

  export type BudgetCategoryUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetId?: StringFieldUpdateOperationsInput | string
    budgeted?: FloatFieldUpdateOperationsInput | number
    spent?: FloatFieldUpdateOperationsInput | number
  }

  export type EnvelopeUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    budgetedAmount?: FloatFieldUpdateOperationsInput | number
    availableAmount?: FloatFieldUpdateOperationsInput | number
    spentAmount?: FloatFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Workspace?: WorkspaceUpdateOneRequiredWithoutEnvelopesNestedInput
  }

  export type EnvelopeUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    budgetedAmount?: FloatFieldUpdateOperationsInput | number
    availableAmount?: FloatFieldUpdateOperationsInput | number
    spentAmount?: FloatFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnvelopeUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    budgetedAmount?: FloatFieldUpdateOperationsInput | number
    availableAmount?: FloatFieldUpdateOperationsInput | number
    spentAmount?: FloatFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetCategoryCreateManyBudgetInput = {
    id?: string
    categoryId: string
    budgeted: number
    spent?: number
  }

  export type BudgetCategoryUpdateWithoutBudgetInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgeted?: FloatFieldUpdateOperationsInput | number
    spent?: FloatFieldUpdateOperationsInput | number
    category?: CategoryUpdateOneRequiredWithoutBudgetsNestedInput
  }

  export type BudgetCategoryUncheckedUpdateWithoutBudgetInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    budgeted?: FloatFieldUpdateOperationsInput | number
    spent?: FloatFieldUpdateOperationsInput | number
  }

  export type BudgetCategoryUncheckedUpdateManyWithoutBudgetInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    budgeted?: FloatFieldUpdateOperationsInput | number
    spent?: FloatFieldUpdateOperationsInput | number
  }

  export type GoalContributionCreateManyGoalInput = {
    id?: string
    amount: number
    description?: string | null
    contributedAt?: Date | string
  }

  export type GoalContributionUpdateWithoutGoalInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contributedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoalContributionUncheckedUpdateWithoutGoalInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contributedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoalContributionUncheckedUpdateManyWithoutGoalInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contributedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementCreateManyUserGamificationInput = {
    id?: string
    achievementId: string
    unlockedAt?: Date | string
  }

  export type UserAchievementUpdateWithoutUserGamificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementUncheckedUpdateWithoutUserGamificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementUncheckedUpdateManyWithoutUserGamificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkspaceCountOutputTypeDefaultArgs instead
     */
    export type WorkspaceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkspaceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccountCountOutputTypeDefaultArgs instead
     */
    export type AccountCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccountCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryCountOutputTypeDefaultArgs instead
     */
    export type CategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BudgetCountOutputTypeDefaultArgs instead
     */
    export type BudgetCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BudgetCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GoalCountOutputTypeDefaultArgs instead
     */
    export type GoalCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GoalCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserGamificationCountOutputTypeDefaultArgs instead
     */
    export type UserGamificationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserGamificationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionDefaultArgs instead
     */
    export type SessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RefreshTokenDefaultArgs instead
     */
    export type RefreshTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RefreshTokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PasswordResetDefaultArgs instead
     */
    export type PasswordResetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PasswordResetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkspaceDefaultArgs instead
     */
    export type WorkspaceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkspaceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkspaceMemberDefaultArgs instead
     */
    export type WorkspaceMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkspaceMemberDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccountDefaultArgs instead
     */
    export type AccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryDefaultArgs instead
     */
    export type CategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TransactionDefaultArgs instead
     */
    export type TransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TransactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RecurrenceDefaultArgs instead
     */
    export type RecurrenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RecurrenceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TransferDefaultArgs instead
     */
    export type TransferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TransferDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BudgetDefaultArgs instead
     */
    export type BudgetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BudgetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BudgetCategoryDefaultArgs instead
     */
    export type BudgetCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BudgetCategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GoalDefaultArgs instead
     */
    export type GoalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GoalDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GoalContributionDefaultArgs instead
     */
    export type GoalContributionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GoalContributionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ImportJobDefaultArgs instead
     */
    export type ImportJobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ImportJobDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserGamificationDefaultArgs instead
     */
    export type UserGamificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserGamificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AchievementDefaultArgs instead
     */
    export type AchievementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AchievementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserAchievementDefaultArgs instead
     */
    export type UserAchievementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserAchievementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EnvelopeDefaultArgs instead
     */
    export type EnvelopeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EnvelopeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AssetDefaultArgs instead
     */
    export type AssetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AssetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LiabilityDefaultArgs instead
     */
    export type LiabilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LiabilityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AIInsightDefaultArgs instead
     */
    export type AIInsightArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AIInsightDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ScenarioDefaultArgs instead
     */
    export type ScenarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ScenarioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BankConnectionDefaultArgs instead
     */
    export type BankConnectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BankConnectionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AutoRuleDefaultArgs instead
     */
    export type AutoRuleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AutoRuleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CashFlowProjectionDefaultArgs instead
     */
    export type CashFlowProjectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CashFlowProjectionDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}